Some problems you might encounter:


* GNU sed 1.06 cannot handle the sed script in mf/convert.

* GNU Make 3.57 does not pass arguments to shell scripts (like convert),
under system V.  3.56 does not have this problem, and neither does 3.58.

* On a 386 machine, GNU C 1.36 does not compile tex.5 correctly when
making a 32-bit TeX.  1.37 fixes this bug.

* On the AT&T 3b2, under System V release 3.2, cc thinks that
eject_penalty (which is -1000, defined at line 3216), is a very large
positive number.  (From karl@cs.umb.edu.)

* On a Sun 3 running 3.x, cc cannot compile mf2.c or mf4.c, because the
preprocessor puts a # directive at the end of line 1811 or so, instead
of at the beginning.  You have to manually move it.

* On a Sun 386i running 4.0.1, cc cannot compile Metafont with -O, because it
can't compile x = x + y correctly.  Don't use -O, or don't use cc. 
(From morgan@ics.uci.edu.)

* Some parts of this work on an Apollo, other parts don't.  Ditto for an
Amiga.  bsuggs@hac2arpa.hac.com is working on this, but would be happy
to have help.


* On a Sun Sparcstation running 4.0.3c and also a Sun 3 running 3.x, ,
cc on both gftodvi.c and vftovp.c fails with a `yacc stack overflow'
message.  (From ekrell@ulysses.att.com.)  justin@crim.ca has contributed
a patch to the change files, which follows.

*** mfware/gftodvi.ch-	Sat Jan 20 12:33:03 1990
--- mfware/gftodvi.ch	Thu Apr  5 12:54:14 1990
***************
*** 702,707 ****
--- 702,750 ----
  @y
  @z
  
+ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
+ % [??] Sun cc cannot handle 165 labels for the same branch of a switch.
+ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
+ @x
+ @<Read and process...@>=
+ loop  @+begin continue: case cur_gf of
+   sixty_four_cases(0): k:=cur_gf;
+   paint1:k:=get_byte;
+   paint2:k:=get_two_bytes;
+   paint3:k:=get_three_bytes;
+   eoc:goto done1;
+   skip0:end_with(blank_rows:=0; do_skip);
+   skip1:end_with(blank_rows:=get_byte; do_skip);
+   skip2:end_with(blank_rows:=get_two_bytes; do_skip);
+   skip3:end_with(blank_rows:=get_three_bytes; do_skip);
+   sixty_four_cases(new_row_0),sixty_four_cases(new_row_0+64),
+    thirty_two_cases(new_row_0+128),five_cases(new_row_0+160):
+     end_with(z:=cur_gf-new_row_0;paint_black:=true);
+   xxx1,xxx2,xxx3,xxx4,yyy,no_op:begin skip_nop; goto continue;
+     end;
+   othercases bad_gf('Improper opcode')
+   endcases;@/
+ @y
+ @<Read and process...@>=
+ loop  @+begin continue:
+  if (cur_gf>=new_row_0)and(cur_gf<=new_row_0+164) then
+     end_with(z:=cur_gf-new_row_0;paint_black:=true)
+  else case cur_gf of
+   sixty_four_cases(0): k:=cur_gf;
+   paint1:k:=get_byte;
+   paint2:k:=get_two_bytes;
+   paint3:k:=get_three_bytes;
+   eoc:goto done1;
+   skip0:end_with(blank_rows:=0; do_skip);
+   skip1:end_with(blank_rows:=get_byte; do_skip);
+   skip2:end_with(blank_rows:=get_two_bytes; do_skip);
+   skip3:end_with(blank_rows:=get_three_bytes; do_skip);
+   xxx1,xxx2,xxx3,xxx4,yyy,no_op:begin skip_nop; goto continue;
+     end;
+   othercases bad_gf('Improper opcode')
+   endcases;@/
+ @z
+ 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % [??] call set_paths before gf_start to initialize paths.
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
*** fontutil/vftovp.ch-	Thu Feb  8 16:17:50 1990
--- fontutil/vftovp.ch	Thu Apr  5 14:23:19 1990
***************
*** 389,394 ****
--- 389,427 ----
  @z
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+ % [124] Sun cc can't handle 136 case labels in a row.
+ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+ @x
+     begin o:=vf[vf_ptr]; incr(vf_ptr);
+     case o of
+     @<Cases of \.{DVI} instructions that can appear in character packets@>
+ @y
+     begin o:=vf[vf_ptr]; incr(vf_ptr);
+     if ((o>=set_char_0)and(o<=set_char_0+127))or
+        ((o>=set1)and(o<=set1+3))or((o>=put1)and(o<=put1+3)) then
+ begin if o>=set1 then
+     if o>=put1 then c:=get_bytes(o-put1+1,false)
+     else c:=get_bytes(o-set1+1,false)
+   else c:=o;
+   if f=font_ptr then
+     bad_vf('Character ',c:1,' in undeclared font will be ignored')
+ @.Character...will be ignored@>
+   else begin vf[font_start[f+1]-1]:=c; {store |c| in the ``hole'' we left}
+     k:=font_chars[f];@+while vf[k]<>c do incr(k);
+     if k=font_start[f+1]-1 then
+       bad_vf('Character ',c:1,' in font ',f:1,' will be ignored')
+     else begin if o>=put1 then out('(PUSH)');
+       left; out('SETCHAR'); out_char(c);
+       if o>=put1 then out(')(POP');
+       right;
+       end;
+     end;
+   end
+     else case o of
+     @<Cases of \.{DVI} instructions that can appear in character packets@>
+ @z
+ 
+ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % [125] `signed' is a keyword in ANSI C.
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  @x
***************
*** 410,415 ****
--- 443,479 ----
      begin print_ln('Stack overflow!'); goto final_end;
  @y
      begin print_ln('Stack overflow!'); uexit(1);
+ @z
+ 
+ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+ % [??] This code moved outside the case statement
+ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+ @x
+ @ Before we typeset a character we make sure that it exists.
+ 
+ @<Cases...@>=
+ sixty_four_cases(set_char_0),sixty_four_cases(set_char_0+64),
+  four_cases(set1),four_cases(put1):begin if o>=set1 then
+     if o>=put1 then c:=get_bytes(o-put1+1,false)
+     else c:=get_bytes(o-set1+1,false)
+   else c:=o;
+   if f=font_ptr then
+     bad_vf('Character ',c:1,' in undeclared font will be ignored')
+ @.Character...will be ignored@>
+   else begin vf[font_start[f+1]-1]:=c; {store |c| in the ``hole'' we left}
+     k:=font_chars[f];@+while vf[k]<>c do incr(k);
+     if k=font_start[f+1]-1 then
+       bad_vf('Character ',c:1,' in font ',f:1,' will be ignored')
+     else begin if o>=put1 then out('(PUSH)');
+       left; out('SETCHAR'); out_char(c);
+       if o>=put1 then out(')(POP');
+       right;
+       end;
+     end;
+   end;
+ @y
+ @ Before we typeset a character we make sure that it exists.
+ (These cases moved outside the case statement, section 124.)
  @z
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 



* On a 386 machine running 386/ix, cc cannot compile itex.c, according
to Reiner Petersen <reiner@db0tui62.bitnet>.  Here is an ed script to
get around the problem (alternatively, you can get gcc, and compile with
that):

:
#       Reiner Petersen (reiner@coma.uucp)
#       Technical University of Berlin
#
ed - $1 << end-of-edscript
!echo change:
/  register integer for_end; i = 1 ; for_end = 31 ; if ( i <= for_end) do
+1,.+2p
-2,.c
  register integer for_end;
   register char j;             /* 386/ix cc bug workaround  rp */
   i = 1 ;
   for_end = 31 ;
   if ( i <= for_end) do 
        j = i;
        xchr [ j ] = chr ( i ) ;
    
    while ( i++ < for_end ) ; 
.
!echo to:
-8,.p
w $1
end-of-edscript

If you want, you can put this into the pipeline in ./tex/convert.

* undump doesn't work under 386/ix.  Here is a diff to undump.SYS_V.c to
fix the around, again contributed by reiner:
*** undump.SYS_V.c      Mon Apr 20 00:57:23 1987
--- undump.c    Fri Aug 19 17:55:27 1988
***************
*** 1,7 ****
  /*
   * undump - resurrect a core file into a running program.
   *
!  *    for UNIX System V on a 3Bx
   *    that uses the Common Object File Format
   *
   * Author:
--- 1,7 ----
  /*
   * undump - resurrect a core file into a running program.
   *
!  *    for UNIX System V on a 3Bx or Interactive 386/ix
   *    that uses the Common Object File Format
   *
   * Author:
***************
*** 9,14 ****
--- 9,19 ----
   *    New York University
   *    Tue Mar  3 13:18:25 EST 1987
   *
+  * Additions for 386/ix:
+  *    Reiner Petersen (reiner@coma.uucp)
+  *    Technical University of Berlin
+  *    Thu Aug 18 13:40:20 MET DST 1988
+  *
   * Adapted from:
   *     Spencer Thomas's undump and the file unexec.c in GNU emacs
   */
***************
*** 15,22 ****
--- 20,33 ----

  #include <sys/param.h>
  #include <sys/types.h>
+
+ #ifndef       ISC_386ix       /* not availible in ISC 386/ix */
+
  #include <sys/psw.h>
  #include <sys/pcb.h>
+
+ #endif        /* ISC_386ix */
+
  #include <sys/signal.h>
  #include <sys/fs/s5dir.h>
  #include <sys/user.h>
***************
*** 37,46 ****
--- 48,66 ----
  struct scnhdr dsc;
  struct scnhdr bsc;

+ #ifdef        ISC_386ix
+ struct scnhdr csc;            /* Comment section used by ISC 386/ix */
+ #endif        /* ISC_386ix */
+
  long bias;
  long lnnoptr;
  long text_scnptr;
  long data_scnptr;
+
+ #ifdef        ISC_386ix
+ long comment_scnptr;
+ #endif        /* ISC_386ix */
+
  long symlocptr;

  main(argc, argv)
***************
*** 89,94 ****
--- 109,118 ----
                        dsc = sc;
                 else if (strcmp(sc.s_name, ".bss") == 0) 
                        bsc = sc;
+ #ifdef        ISC_386ix
+                else if (strcmp(sc.s_name, ".comment") == 0) 
+                       csc = sc;
+ #endif        /* ISC_386ix */
                
        

***************
*** 97,103 ****
        if (u.u_exdata.ux_tsize != aout.tsize ||
            u.u_exdata.ux_dsize != aout.dsize ||
            u.u_exdata.ux_bsize != aout.bsize) 
!               fprintf("mismatch between %s and %s sizes\n", a_out_name,
 core_name);
                exit(1);
        

--- 121,128 ----
        if (u.u_exdata.ux_tsize != aout.tsize ||
            u.u_exdata.ux_dsize != aout.dsize ||
            u.u_exdata.ux_bsize != aout.bsize) 
!               fprintf( stderr, "mismatch between %s and %s sizes\n",
!                                                       a_out_name, core_name);
                exit(1);
        

***************
*** 122,128 ****
--- 147,159 ----
        bsc.s_paddr = bsc.s_vaddr = aout.data_start + aout.dsize;
        bsc.s_size = aout.bsize;
        bsc.s_scnptr = 0L;
+ #ifndef       ISC_386ix
        bias = dsc.s_scnptr + dsc.s_size - lnnoptr;
+ #else
+       comment_scnptr = csc.s_scnptr;
+       csc.s_scnptr = dsc.s_scnptr + dsc.s_size;
+       bias = csc.s_scnptr + csc.s_size - lnnoptr;
+ #endif        /* ISC_386ix */

        if (fh.f_symptr > 0L)
                fh.f_symptr += bias;
***************
*** 139,149 ****
--- 170,186 ----
                Perror("ds write");
        if (fwrite(&bsc, sizeof(bsc), 1, nfp) != 1)
                Perror("bs write");
+       if (fwrite(&csc, sizeof(csc), 1, nfp) != 1)
+               Perror("cs write");
        fseek(nfp, (long)text_scnptr, 0);
        copy(afp, nfp, aout.tsize);
        fseek(cfp, off, 0);
        fseek(nfp, (long)data_scnptr, 0);
        copy(cfp, nfp, size);
+ #ifdef        ISC_386ix
+       fseek(afp, (long)comment_scnptr, 0);
+       copy(afp, nfp, csc.s_size);
+ #endif        /* ISC_386ix */
        copy_syms(afp, nfp);
        fclose(nfp);
        fclose(afp);
