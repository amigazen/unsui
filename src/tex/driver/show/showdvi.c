/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from showdvi.c
*/
/*
 *
 * AUTHOR(s) -- Porting Postscript SUN-Version to ATARI ST
 *  Robert Stabl   -- managing dvi-file, screen driver for ATARI ST
 *  Georg Hessmann -- porting ATARI ST version to AMIGA 1000
 *
 */


/* Change log:
 *
 * 26-Nov-89 (hes) -- Changelog now in file util/version.h
 *                 -- v0.60
 */


/**********************************************************************/
/***********************  external definitions  ***********************/
/**********************************************************************/

#include "defines.h"

#define MAIN		/*	for globals.h		*/

#ifdef AMIGA
#define LONG_ARGS	/*	For now only the Amiga knows about GetOpt.c */
#endif

#include <stdio.h>
#include <ctype.h>
#ifdef ANSI
#  include <string.h>
#  include <stdlib.h>
#endif

#include "commands.h"
#include "globals.h"
#include "bitmap.h"
#include "liste.h"
#include "dvihand.h"
#include "flmt.h"
#include "new_font.h"

#ifdef AMIGA
#  include <intuition/intuition.h>
#  include <dos/dos.h>
#  include "amscreen.h"
#  include <clib/exec_protos.h>
#  include <clib/dos_protos.h>
#  include <clib/intuition_protos.h>

#ifdef AZTEC_C
#  include <functions.h>
#endif

#ifdef LATTICE
#  include <pragmas/exec_pragmas.h>
#  include <pragmas/dos_pragmas.h>
#  include <pragmas/intuition_pragmas.h>
#endif
#endif /* AMIGA */

#include "showdvi.i"
#include "globals.i"
#include "liste.i"
#include "gadget.i"
#include "dvihand.i"
#include "dospecia.i"
#include "new_font.i"
#include "sbitmap.i"
#include "skippage.i"
#include "search.i"

#ifdef ATARI
#  include "atscreen.i"
#  ifdef DISPLAY
     extern int showbars;
#  endif
#endif

#ifdef AMIGA
# include "amscreen.i"
# include "fast_cp.i"
#endif

#if defined(LONG_ARGS)
#define TEX		/*	for GetOpt.h		*/

#include "GetOpt.h"
#include "GetOpt.i"
#endif /* LONG_ARGS */



/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"




/** lokale Funktionen **/
static int read_file		Args((DVIFILE *fp,
              		      	      int show));
static int do_command		Args((long k,
       		      		      DVIFILE *fp,
               			      long cpagep));

#if defined(LONG_ARGS)
extern struct Options opt[];	/* forward deklaration wg. PrintHelp nach init_task */
static void PrintHelp		Args((struct Options opt[],
					short long_hlp));

#else /* LONG_ARGS */
static void PrintHelp		Args((void));
static void offset_to_inch	Args((float *inch,
				      float *offset,
				      char *einh));
static void not_a_valid_integer	Args((void));
#endif /* LONG_ARGS */


#ifdef AZTEC_C
#pragma regcall( /* d0 = */ read_file(a0,d0,a1,d1))
#pragma regcall( /* d0 = */ do_command(d0,a0,a1,d1))
#pragma regcall( offset_to_inch(a0,a1,a2))
#pragma regcall( DecodeArgs(d0,a1))
#endif



#define EQ(a,b) (strcmp(a,b)==0)
#define RESET_FL_PAGE FirstPage = -1000000L; LastPage = 1000000L;



/**********************************************************************/
/*************************  Global Variables  *************************/
/**********************************************************************/

/* see globvars.h */


extern char *_ProgramName;
extern struct WBStartup	*WBenchMsg;



/**********************************************************************/
/*************************  Local Variables  **************************/
/**********************************************************************/


struct stack_entry {	 	/* stack entry */
   long hh, h, vv, v, w, x, y, z; 	/* what's on stack                    */
 };

static struct stack_entry stack[STACKSIZE];   /* stack                */

static char ParamStr[STRSIZE];	/* used bye GetBytes()		      */



/*********************************************************************/
/**********************  read_file  **********************************/
/*********************************************************************/
static int read_file(DVIFILE *fp, int show)
{
  register int i;          /* temporary variable                       */
  register int ret;        /* return code of this function             */
  int command;             /* current command                          */
  long count[10];          /* the 10 counters at beginning of each page*/
  long cpagep=0L;          /* current page pointer                     */
/*    long h_pptr; */            /* temporary filepointer              */
/*    long h_page; */            /* temporary pagecounter              */
  long k;                  /* temporary variable                       */
/*    int SkipMode = FALSE; */   /* in skip mode flag                  */

  int sp;                  /* stack pointer                            */
  long val, val2;          /* temporarys to hold command information   */
  long w;                  /* current horizontal spacing               */
  long x;                  /* current horizontal spacing               */
  long y;                  /* current vertical spacing                 */
  long z;                  /* current vertical spacing                 */


  OffsetBitmap_X = hoffset;
  OffsetBitmap_Y = voffset;


  ret = 0;

  h = v = w = x = y = z = 0;
  hh = vv = 0;
  sp = 0;


 if (fp == NULL)
  {
   Message(MSG_NO_FILE_GIVEN);
#ifdef AMIGA
   unset_dvif;
#endif
   while ((k = ShowPage(0)) != KOMM+4L)
    {
     if (k == KOMM+10L)
      { return(10); }
    }
   return(4);
  }
#ifdef AMIGA
 else
  {
   set_dvif;
  }
#endif

 if (ret != 10) {
   Message(MSG_BUILD_BITMAP);
 }

 while (ret != 3 && ret != 4 && ret != 10)
  {
   command = Read1Byte(fp);

   if (command >= SETC_000 && command <= SETC_127) {
     SetChar((long)command, command);
     if (InSearchMode && SearchRect) {
       SearchFoundRect = SearchRect;
     }
   }
   else {
     if (command >= FONT_00 && command <= FONT_63) {
        SetFntNum((long) (command - FONT_00));
     }
     else {
       switch (command) {
         case SET1:
         case SET2:
         case SET3:
         case SET4:
          val = NoSignExtend(fp, command-SET1+1);
          SetChar(val, command);
          if (InSearchMode && SearchRect) {
            SearchFoundRect = SearchRect;
          }
          break;

         case SET_RULE:
           val = Read4Byte(fp);
           val2 = Read4Byte(fp);
           SetRule(val, val2, 1);
           break;

         case PUT1:
         case PUT2:
         case PUT3:
         case PUT4:
           val = NoSignExtend(fp,command-PUT1+1);
           SetChar(val, command);
           if (InSearchMode && SearchRect) {
             SearchFoundRect = SearchRect;
           }
           break;

         case PUT_RULE:
           val = Read4Byte(fp);
           val2 = Read4Byte(fp);
           SetRule(val, val2, 0);
           break;

           case NOP:
             break;

           case BOP:
              cpagep = DVIftell(fp) - 1;

              for (i=0; i<=9; i++)
               {
                count[i] = Read4Byte(fp);
               }
              ppagep = Read4Byte(fp);

              current_page = count[0];  

                           /* each new page should be marked */
              if ( take_pptr(current_page, cpagep, 0L, FALSE)==0L )
               {
                in_list(current_page,cpagep, 0L);
               }
              current_page_phy = get_phy_number(cpagep);

              h = v = w = x = y = z = 0;
              hh = vv = 0;
              sp = 0;
#ifdef kdsjfgkfgd
              if( count[0] < FirstPage || count[0] > LastPage )
               {
                if (SkipMode && Reverse)
                 {
                  DVIfseekSet(fp, ppagep); /* one page back */
                  break;
                 } 
                if (!SkipMode) 
                 {
                  take_greater(current_page,cpagep,&h_page,&h_pptr);
                  if (h_pptr != (long) NULL)
                   { 
                    DVIfseekSet(fp,h_pptr);
                    current_page = h_page;
                    SkipMode = TRUE;
                    break;
                    /*  Reverse = TRUE; */
                   }
                 }
                SkipMode = TRUE;
               }
              else
               SkipMode = FALSE;
#endif
              break;

           case EOP:
             if (!InSearchMode) MessageStr(NULL);		/* copyright string */

             if (InSearchMode) {
               // Seite abschliessen
               BMSearch('\0', 0, 0, 0, 0);
               if (SearchRect) {
                 SearchFoundRect = SearchRect;
                }
             }

             ret = 0;			/* (hes) 20-may-91 (same_page) */
             do { 			/* show same page */
               k=ShowPage(ret);
               RESET_FL_PAGE;
               ret = do_command(k,fp,cpagep);
             } while (ret == 1);
             if (ret != 10) {
               if (!InSearchMode) Message(MSG_BUILD_BITMAP);
             }
             break;

           case PUSH:
             if (sp >= STACKSIZE) Fatal(5, MSG_STACK_OVER);
             stack[sp].hh = hh;
             stack[sp].vv = vv;
             stack[sp].h  = h;
             stack[sp].v  = v;
             stack[sp].w  = w;
             stack[sp].x  = x;
             stack[sp].y  = y;
             stack[sp].z  = z;
             sp++;
             break;

           case POP:
             --sp;
             if (sp < 0) Fatal(5, MSG_STACK_UNDER);
             hh = stack[sp].hh;
             vv = stack[sp].vv;
             h  = stack[sp].h;
             v  = stack[sp].v;
             w  = stack[sp].w;
             x  = stack[sp].x;
             y  = stack[sp].y;
             z  = stack[sp].z;
             break;

           case RIGHT1:
           case RIGHT2:
           case RIGHT3:
           case RIGHT4:
             val = SignExtend(fp,command-RIGHT1+1);
             MoveOver(val);
             break;

           case W0:
             MoveOver(w);
             break;

           case W1:
           case W2:
           case W3:
           case W4:
             w = SignExtend(fp,command-W1+1);
             MoveOver(w);
             break;

           case X0:
             MoveOver(x);
             break;

           case X1:
           case X2:
           case X3:
           case X4:
             x = SignExtend(fp,command-X1+1);
             MoveOver(x);
             break;

           case DOWN1:
           case DOWN2:
           case DOWN3:
           case DOWN4:
             val = SignExtend(fp,command-DOWN1+1);
             MoveDown(val);
             break;

           case Y0:
             MoveDown(y);
             break;

           case Y1:
           case Y2:
           case Y3:
           case Y4:
             y = SignExtend(fp,command-Y1+1);
             MoveDown(y);
             break;

           case Z0:
             MoveDown(z);
             break;

           case Z1:
           case Z2:
           case Z3:
           case Z4:
             z = SignExtend(fp,command-Z1+1);
             MoveDown(z);
             break;

           case FNT1:
           case FNT2:
           case FNT3:
           case FNT4:
             SetFntNum(NoSignExtend(fp,command-FNT1+1));
             break;

           case XXX1:
           case XXX2:
           case XXX3:
           case XXX4:
		{ unsigned long len = NoSignExtend(fp, command-XXX1+1);
		  DoSpecial(fp, len);
		}
		break;
#ifdef OLD_DOSPECIAL
/*
             if (!SkipMode)
*/
              {
               k = NoSignExtend(fp,command-XXX1+1);
               GetBytes(fp, ParamStr, k);
               DoSpecial(ParamStr, k);
              }
             break;
#endif
 
           case FNT_DEF1:
           case FNT_DEF2:
           case FNT_DEF3:
           case FNT_DEF4:
             k = NoSignExtend(fp, command-FNT_DEF1+1);
             if (PreLoad   || HasBeenRead(k)  )
              {
               SkipFontDef ();
              }
             else
              {
               ReadFontDef (k, TRUE);
              }
             break;

           case PRE:
             Fatal(5, MSG_PRE_IN_FILE);
             break;

           case POST:
             { long h_pptr;

               take_last(&current_page,&h_pptr);
               current_page_phy = get_phy_number(h_pptr);
               current_page = get_page_number(current_page_phy);	// _phy added (hes) 20.07.94
               DVIfseekSet(fp,h_pptr);
             }
             Warning(MSG_POST_IN_FILE);
             break;

           case POST_POST:
             Fatal(5, MSG_POST_POST);
             break;

           default:
                Warning(MSG_DVI_FILE_ERROR);
                corrupt = FALSE;		/* zuruecksetzen, da nun das ganze File bekannt ist */
                max_page_number = current_page;
                Set_PgPotGadRange();
                DVIfseekSet(fp, cpagep-1L);
                ret = 0;			/* (hes) 30-may-91 */
                do { /* show same page */
                  k=ShowPage(ret);		/* ret: damit ich weiss, ob ich wieder an der selben Seite bin */
                  RESET_FL_PAGE;
                  ret = do_command(k,fp,cpagep);
                } while (ret == 1);
  
                if (ret != 10) {
                  if (!InSearchMode) Message(MSG_BUILD_BITMAP);
                }
             break;
         }	/* switch */
     }		/* else font */
   }		/* else char */
  }		/* end while */
 return (ret);
}

/*********************************************************************/
/**************************** do_command *****************************/
/*********************************************************************/
static int do_command(long k, DVIFILE *fp,long cpagep)
{
  register int ret;
  register int hk;
  long h_pptr;                    /* temporary filepointer            */
  long last_page_dvifile;         /* number of last page in dvi file  */
  long first_page_dvifile;        /* number of first page in dvi file */
  long cur_pag;
  
/***
  if (k == 0) {
    return 1;		/ * do nothing * /
  }
***/

  take_last (&last_page_dvifile, &h_pptr);
  take_first(&first_page_dvifile,&h_pptr);

  ret = 0;  /* *  ret ==  0 => ok,				* 
               *  ret ==  1 => show page without any changes,	*
               *  ret ==  3 => load same dvi file again,	*
               *  ret ==  4 => load new dvi file,		*
               *  ret ==  6 => search in progress               *
               *  ret == 10 => terminate program.               *        */

  if (k>= KOMM-3L)
   {
    hk = (int)(k-KOMM);
    switch(hk)
     {
     case 10: /* terminate program */
             { 
              ret = 10;
              break;
             }

     case 6: /* start search */
             take_greater(current_page, cpagep, &cur_pag, &h_pptr);
             if (h_pptr != 0L) {					// zyklisch suchen
                DVIfseekSet(fp, h_pptr);	    /* da samma scho (meistens) */
                current_page_phy = get_phy_number(h_pptr);
                current_page = get_page_number(current_page_phy);
                //ClearBitmap();
             } 
             else {
                take_first(&current_page,&h_pptr);
                current_page_phy = get_phy_number(h_pptr);
                current_page = get_page_number(current_page_phy);
                DVIfseekSet(fp,h_pptr);
                //ClearBitmap();
             }
             ret = 6;
             break;
             
     case 7: /* end search...auf die Seite springen, bei der die Suche gestartet wurde */
             /*              sprich alle Variablen zuruecksetzen, die geaendert wurden */
             
             // auf phy Seite springen
             h_pptr = take_pptr(SearchFoundPage, 0L, SearchFoundPage, TRUE);
             if (h_pptr) {
               current_page_phy = get_phy_number(h_pptr);
               current_page = get_page_number(current_page_phy);
               DVIfseekSet(fp,h_pptr);
               //ClearBitmap(); (nur wenn nicht selbe Seite)
             }

             if (SearchFoundPage == SearchStartPage) {
               ret = 1;		// selbe Seite ohne Aenderungen
             }
             else {
               ClearBitmap();
               ret = 0;
             }
             
             break;

     case 3: /* work with new dvi file (load again) */
     case 4: /* work with new dvi file */
             { 
              corrupt = FALSE;
              free_liste();  /* deallocate page pointers */
              resetfont();       /* delete font numbers      */
              ret = hk;
              break;
             }

     case -2: /* go to begin of dvi file */ 
             { 
              if (current_page==get_page_number(first_page_dvifile)) 
               {
                Message(MSG_ALREADY_FIRST); 
                beep();
                ret = 1;
               }
              else 
               {
                take_first(&current_page,&h_pptr);
                current_page_phy = get_phy_number(h_pptr);
                current_page = get_page_number(current_page_phy);
                DVIfseekSet(fp,h_pptr);
                ClearBitmap();
               } 
              break;
             }

     case 2: /* go to end of dvi file */
             {
	      if (corrupt) {
                long cp = cpagep;
                int endoffile = FALSE;
 
                /* fseek(fp,cpagep,0); */	/* first to current page */
                while (!endoffile) {
                  endoffile = skippage(fp, &cp, &ppagep, &current_page, &current_page_phy);
                  if (!endoffile) {
                    cpagep = cp;
                  }
                }
	        DVIfseekSet(fp,cpagep);
                ClearBitmap();
	      }
	      else {
                if (current_page==get_page_number(last_page_dvifile))
                 {
                  Message(MSG_ALREADY_LAST); 
                  beep();
                  ret = 1;
                 }
                else
                 {
                  take_last(&current_page,&h_pptr);
                  current_page_phy = get_phy_number(h_pptr);
                  current_page = get_page_number(current_page_phy);
                  DVIfseekSet(fp,h_pptr);
                  ClearBitmap();
                 }
              }
              break;
             }

     case -1: /* one page back */
             {
                take_less(current_page, cpagep, &cur_pag, &h_pptr);
                if (h_pptr != 0L)
                 {
                  DVIfseekSet(fp, h_pptr);
                  current_page_phy = get_phy_number(h_pptr);
                  current_page = get_page_number(current_page_phy);
                  ClearBitmap();
                 }
                else
                 {
                  Message(MSG_ALREADY_FIRST);
                  beep();
                  DVIfseekSet(fp, cpagep);
                  ret = 1;
                 }
              break;
             }

     case 1: /* one page forward */
             {
              if (!corrupt) {
                take_greater(current_page, cpagep, &cur_pag, &h_pptr);
                if (h_pptr != 0L)
                 {
                  /* geht nicht zur physikalisch naechsten, sondern zur *
                   * logisch (Seitennummer) naechsten Seite.		*/
                  DVIfseekSet(fp, h_pptr);	    /* da samma scho (meistens) */
                  current_page_phy = get_phy_number(h_pptr);
                  current_page = get_page_number(current_page_phy);
                  ClearBitmap();
                 }
                else
                 {
                  Message(MSG_ALREADY_LAST);
                  beep();
                  DVIfseekSet(fp, cpagep);
                  ret = 1;
                 }
              }
              else {
                ClearBitmap();
              }
              break;
             }

       default:
             break;
      }
     } /* end switch */
    else     /* then it is a pagenumber */
     {
      if (corrupt) {
        h_pptr = take_pptr(k, 0L, k, use_phy_number);
        if (h_pptr==0L) {		/* page not marked */ 
          int endoffile = FALSE;
 
          /* fseek(fp,cpagep,0); */	/* first to current page */
          while (!endoffile && get_page_number(current_page_phy) != k) {
            endoffile = skippage(fp, &cpagep, &ppagep, &current_page, &current_page_phy);
          }
          if (endoffile) {
	    Warning(MSG_PAGE_NOT_FOUND,k);
          }
	  DVIfseekSet(fp,cpagep);
        }
        else { 		/* page is marked */
          current_page_phy = get_phy_number(h_pptr);
          current_page = get_page_number(current_page_phy);
          DVIfseekSet(fp,h_pptr);
        }
        ClearBitmap();
      }
      else {
        k = (k < first_page_dvifile) ? first_page_dvifile : k;
        k = (k > last_page_dvifile ) ? last_page_dvifile  : k;
        if (k != ((use_phy_number) ? current_page_phy : get_page_number(current_page_phy)))
         {
          h_pptr = take_pptr(k, 0L, k, use_phy_number);
          if (h_pptr==0L) 		/* page not marked */ 
           { 
            Message(MSG_PAGE_NOT_FOUND, k);
            beep();
            ret = 1;		/* page k dosn't exists -> same page */
#ifdef uralt
            FirstPage = k;  /* go to page k */
            LastPage = k;
            DVIfseekSet(fp,cpagep); /* first to current page */
            Reverse = (get_page_number(current_page)>k);
#endif
           }
          else  /* page is marked */
           { 
            current_page_phy = get_phy_number(h_pptr);
            current_page = get_page_number(current_page_phy);
            DVIfseekSet(fp,h_pptr);
            ClearBitmap();
           }
         }
        else
         {
          ret = 1;
         }
       }
     }
  return (ret);
}


/**********************************************************************/
/*******************************  main  *******************************/
/**********************************************************************/

void main(int argc, char *argv[])

{
  int i; 	                  /* command parameter; loop index        */
  long h_pptr;                    /* temporary filepointer                */
  long tpagep;	    		  /* temporary page pointer		  */
  long dummy;                     /* temporary variable                   */
  int return_from_display;        /* what shall we do -- 10 : terminate   */
                                  /*                  --  3 : change file */
                                  /*                  -- -1 : first start */
  int show = 1;                   /* output to screen or printer (unused) */
  long l1;

    g_Logname = SHOWDVI_LOGFILE;
    g_logging = -1;	/* disable it until DecodeArgs()	*/

    bytesperlong = sizeof (long);
    /* bitsperlong = 8 * bytesperlong; */
    
    landscape = FALSE;
    twopage   = FALSE;
    leftpage  = FALSE;
    
    start_specialhost = FALSE;

    resolution = RESOLUTION;
    hconvresolution = hconvRESOLUTION;
    vconvresolution = vconvRESOLUTION;

    MaxDviBufSize = 20*1024;	// bis zu 20k grosse DVI Files sollen komplett geladen werden

    filename[0] = '\0';
    dirname[0] = '\0';

    hoffset_in_fix  = HOFFSET_IN;		/* inch */
    hoffset_is_true = TRUE;			/* true inch? */
    voffset_in_fix  = VOFFSET_IN;		/* inch */
    voffset_is_true = TRUE;			/* true inch? */
    
    // -13.13: Zeigt GetOpt(), daß nichts definiert wurde
    user_paper_height_in = -13.13;
    user_paper_width_in  = -13.13;
    
    mark_fonts = FALSE;
    
    InSearchMode = FALSE;
    SearchRect = NULL;
    SearchFoundRect = NULL;

    {
      struct Options * o;
      o = GetOneOpt(&hoffset_in_fix, opt);
      if (o) o->special = hoffset_is_true;
      o = GetOneOpt(&voffset_in_fix, opt);
      if (o) o->special = voffset_is_true;
    }
    
    fontmemsize = FONTMEMSIZE;
    RESET_FL_PAGE;	/* oder 0 ? */

    Enable_Abort = 1;
    task_priority = 0;

    if (argc == 0) {
      set_wbench;
      g_progname = _ProgramName;
    }
    else {
      unset_wbench;
      g_progname = argv[0];
    }

    if (init_task_name(argc, argv) == 1) {	/* set task-name and test for another showdvi */
      PrintHelp(opt, TRUE);
      AbortRun(0);
    }
    Init_ShowDVI();				/* initialisiert diverse Variablen */

    if (argc == 0) {
      WBenchMsg = (struct WBStartup *)argv;
    }
    else {
      WBenchMsg = NULL;
    }

    DecodeArgs( argc, argv );

#  ifdef AMIGA

    SetShowDVIVars(filename);

    old_task_priority = (unsigned long)SetTaskPri(FindTask(NULL), task_priority);
    Open_ShowDVI(dvifp != NULL);		/* oeffnet screen .... */
#  endif
#  ifdef ATARI
    use_phy_number = FALSE;	/* use logical numbers by default */
    init_screen();		/* dito */
#  endif

    MessageStr(NULL);	/* Copyright-String */
    LoggingStr(NULL);

#ifdef ATARI
    LogTOSVersion();
#endif

#if defined(BETACOPYRIGHT)
    PrintBetaCopy();
#endif

    current_page = 0L          /* FirstPage */;
    current_page_phy = 0L;
    return_from_display = -1;	/* first Start */

    init_fontmt (1);		/* we are ShowDVI */
    /* ********* Main-Loop: *********** */
    while (return_from_display != 10 )
     {
      if (!init_liste()) {
        Fatal(10,MSG_NO_MEM);
      }

#if 0 /* unnoetig, wird entweder in ReadPostAmble() oder weiter unten gesetzt */
/* aber wenn dvifp = NULL ? */
      hoffset = (int)((float)hconvresolution * hoffset_in_fix);/*hes: offset_in noch nicht definiert!*/
      voffset = (int)((float)vconvresolution * voffset_in_fix);/*hes: * mag / 1000 ? */
#endif

      if (abs(user_paper_width_in+13.13) > 0.01) {
        paper_width = (long)((float)hconvresolution * user_paper_width_in);
      }
      else {
        paper_width  = hconvresolution * HSIZE;		/* for !preload */
      }							/*   default    */
							/*    size      */
      if (abs(user_paper_height_in+13.13) > 0.01) {
        paper_height = (long)((float)vconvresolution * user_paper_height_in);
      }
      else {
        paper_height = vconvresolution * VSIZE;
      }

      if (dvifp != NULL)
       {
        if ((i = (int) Read1Byte(dvifp)) != PRE)
         {
          Fatal(5,MSG_MISSING_PRE);
         }

        i = SignExtend(dvifp, 1);
        if (i != DVIFORMAT)
         {
          Fatal(5,MSG_WRONG_DVI_TYPE,i, DVIFORMAT);
         }

/* it is important that these be the very first things output !!! */

	LoggingStr("");	/* blank line */
	Logging(MSG_LOADING_DVI, filename);
	Message(MSG_LOADING_DVI, filename);

        tpagep = DVIftell(dvifp);

        if (ReadPostAmble(PreLoad))
         {
	    Warning(MSG_INCOMPLETE_DVI_PRELOAD);
	    PreLoad = FALSE;
	    corrupt = TRUE;
	    DVIfseekSet(dvifp, tpagep);
	    num = NoSignExtend(dvifp, 4);
	    den = NoSignExtend(dvifp, 4);
	    mag = NoSignExtend(dvifp, 4);
            hconv = DoConv(num, den, hconvresolution);
            vconv = DoConv(num, den, vconvresolution);

	    /* man muss beim h/v-Offset die Magnification beruecksichtigen! */       
	    hoffset_in = hoffset_in_fix * mag / 1000;
	    voffset_in = voffset_in_fix * mag / 1000;

	    hoffset = (int)((float)hconvresolution * hoffset_in);
	    voffset = (int)((float)vconvresolution * voffset_in);

	    alpha = (((double)den / 7227.0) / 0x100000) * (25400000.0 / (double) num) ;
	    /** fsizetol = 1 + (long)(resolution/(72270.0 * hconv)) ; **/

         }
        else
         {
          GetFontDef(PreLoad);
          DVIfseekSet(dvifp, 14L);
         }
        dummy = Read1Byte(dvifp);
        GetBytes(dvifp, ParamStr, dummy);

        h_pptr = (long) DVIftell(dvifp);

        l1 = ppagep;
        if (!corrupt)
         {
          dummy = 0L;		/* physical page number */
          Message(MSG_SCAN_DVI_FILE);
                           /* mark all pages */ 
          do
           {
            DVIfseekSet(dvifp, l1);
            if (Read1Byte(dvifp) != BOP)
             {
              Warning(MSG_DVI_FILE_ERROR);
              break;
/*		aber das File ist doch !corrupt ?????
              Fatal(5,"Error occured within DVI file!");
*/
             }
            else
             {
              dummy++;
              in_list(Read4Byte(dvifp), l1, dummy);
              GetBytes(dvifp, ParamStr, 36L);
              l1 = Read4Byte(dvifp);
             }
           }
          while (l1 != -1L);
          max_page_number = dummy;
          Set_PgPotGadRange();
          calc_phy_nr(dummy);	/* reverse the phy number */
#if defined(DEBUG)
          if (Stats) {
            print_list();
          }
#endif
         
          DVIfseekSet(dvifp, h_pptr);
         }
       }

      InitBitmap(paper_height, paper_width);
      MessageStr(NULL);	/* print Copyright-String */

#if 0 /* das war meine Version (hes)
      if (hconvresolution <= 599)	hmaxdrift = hconvresolution / 100 ;
      else if (hconvresolution < 1199)	hmaxdrift = hconvresolution / 200 + 3 ;
      else				hmaxdrift = hconvresolution / 400 + 6 ;

      if (vconvresolution <= 599)	vmaxdrift = vconvresolution / 100 ;
      else if (vconvresolution < 1199)	vmaxdrift = vconvresolution / 200 + 3 ;
      else				vmaxdrift = vconvresolution / 400 + 6 ;

      thinspace      = (long)(0.025*hconvresolution*hconv) ; /* 0.025 inches */
      vertsmallspace = (long)(0.025*vconvresolution*vconv) ; /* 0.025 inches */
      backspace      = -(long)(0.124533 * hconvresolution * hconv);
		/* vertspace  =approx.  0.8 * 10pt =  0.110696 inches */
#else	/* das ist Bernd's Version */
      if (hconvresolution < 100)	hmaxdrift = 0;
      else if (hconvresolution < 200)	hmaxdrift = 1;
      else				hmaxdrift = 2;

      if (vconvresolution < 100)	vmaxdrift = 0;
      else if (vconvresolution < 200)	vmaxdrift = 1;
      else				vmaxdrift = 2;

      /* Setup initial spaces for 10pt Font: */
		/* wordspace  =approx.  0.2 * 10pt =  0.027674 inches */
      thinspace      =  (long)(0.027674 * hconvresolution * hconv);
		/* -backspace =approx. -0.9 * 10pt = -0.124533 inches */
      backspace      = -(long)(0.124533 * hconvresolution * hconv);
		/* vertspace  =approx.  0.8 * 10pt =  0.110696 inches */
      vertsmallspace =  (long)(0.110696 * vconvresolution * vconv);
#endif

#ifdef PROTOCOL
      protocol ();
#endif

      /* go to first page (hes) */
      if (return_from_display == -1 && FirstPage != -1000000L) {
        long k = FirstPage;
        long h_pptr;                    /* temporary filepointer            */
        long last_page_dvifile;         /* number of last page in dvi file  */
        long first_page_dvifile;        /* number of first page in dvi file */

        take_last (&last_page_dvifile, &h_pptr);
        take_first(&first_page_dvifile,&h_pptr);
        k = (k < first_page_dvifile) ? first_page_dvifile : k;
        k = (k > last_page_dvifile ) ? last_page_dvifile  : k;
        h_pptr = take_pptr(k, 0L, k, use_phy_number);
        if (h_pptr!=0L) {		/* page marked */ 
          DVIfseekSet(dvifp, h_pptr);
          current_page_phy = get_phy_number(h_pptr);
          current_page = get_page_number(current_page_phy);
        }
      }

      /* holt den Pointer auf die 'current page' */
      if (return_from_display == 3) {	/* load file again */
        if (corrupt) {
          long cp;
          long current = current_page-1;
          int endoffile = FALSE;
 
          /* fseek(dvifp,cpagep,0); */	/* first to current page */
          while (!endoffile && current_page != current) {
            endoffile = skippage(dvifp, &cp, &ppagep, &current, &current_page_phy);
          }
          current_page = current;
          current_page_phy = get_phy_number(cp);
	  DVIfseekSet(dvifp,cp);
        }
        else {
          long h_pptr;                    /* temporary filepointer            */
          long last_page_dvifile;         /* number of last page in dvi file  */
          long first_page_dvifile;        /* number of first page in dvi file */

          take_last (&last_page_dvifile, &h_pptr);
          take_first(&first_page_dvifile,&h_pptr);

	  if (use_phy_number) {
	    current_page_phy = (current_page_phy < first_page_dvifile)
				? first_page_dvifile : current_page_phy;
	    current_page_phy = (current_page_phy > last_page_dvifile)
				? last_page_dvifile : current_page_phy;
	    current_page = get_log_page_number(current_page_phy);
	    h_pptr = take_pptr(0L, 0L, current_page_phy, TRUE);
	    if (h_pptr == NULL) {
	      take_first(&first_page_dvifile,&h_pptr);
	      current_page = get_log_page_number(first_page_dvifile);
	      current_page_phy = first_page_dvifile;
	    }
	  }
	  else {
	    current_page = (current_page < first_page_dvifile)
				? first_page_dvifile : current_page;
	    current_page = (current_page > last_page_dvifile)
				? last_page_dvifile : current_page;
	    h_pptr = take_pptr(current_page, 0L, 0L, FALSE);
	    if (h_pptr == NULL) {
	      take_first(&first_page_dvifile,&h_pptr);
	      current_page_phy = get_phy_number(h_pptr);
	      current_page = first_page_dvifile;
	    }
	  }
	  DVIfseekSet(dvifp, h_pptr);
        }
      }

      /* ****** Show the file. ******* */
      return_from_display = read_file(dvifp, show);

     }  /* ***** end Main-loop ***** */
    AbortRun(0);
}



/*==========================================================================*/


static long help;
static char *filenameptr = NULL;
static long o_nlogging;
static char *g_paper     = NULL;


START_PARAM(opt)
  /* req?      key-name      abbrev type         variable       help-txt */
  NOREQ_PARAM ("HELP",        "?",  OPT_HELP,    &help,		    MSG_OPTIONS_HELP, 0)
  NOREQ_PARAM ("FONTDir",     "-a", OPT_STRING,  &PXLpath,	    MSG_OPTIONS_FONTDIR, 0)
  NOREQ_PARAM ("FONTMem",     "-b", OPT_LONG,    &fontmemsize,	    MSG_OPTIONS_FONTMEM, 0)
  NOREQ_PARAM ("From",        "-f", OPT_LONG,    &FirstPage,	    MSG_OPTIONS_FROM, 0)
  NOREQ_PARAM ("HOFFset",     "-h", OPT_TEX_DIM, &hoffset_in_fix,   MSG_OPTIONS_HOFFSET,MSG_OPTIONS_HVOFFSET2)
  NOREQ_PARAM ("VOFFset",     "-v", OPT_TEX_DIM, &voffset_in_fix,   MSG_OPTIONS_VOFFSET,MSG_OPTIONS_HVOFFSET2)
  NOREQ_PARAM ("WIDTH",       NULL, OPT_TEX_DIM, &user_paper_width_in,  MSG_OPTIONS_WIDTH, 0)
  NOREQ_PARAM ("HEIGHT",      NULL, OPT_TEX_DIM, &user_paper_height_in, MSG_OPTIONS_HEIGHT, 0)
  NOREQ_PARAM ("PAPERSIZE",   NULL, OPT_STRING,  &g_paper,          MSG_OPTIONS_PAPER, MSG_OPTIONS_PAPER2)
  NOREQ_PARAM ("PUBscreen",   NULL, OPT_STRING,  &ArgPubname,       MSG_OPTIONS_PUBSCREEN, 0)
  NOREQ_PARAM ("PREload",     "-p", OPT_BOOLEAN, &PreLoad,	    MSG_OPTIONS_PRELOAD, 0)
  NOREQ_PARAM ("RESolution",  "-z", OPT_LONG,    &resolution,	    MSG_OPTIONS_RESOLUTION, 0)
  NOREQ_PARAM ("MARK",        NULL, OPT_BOOLEAN, &mark_fonts,       MSG_OPTIONS_MARK, 0)
  NOREQ_PARAM ("STATistic",   "-s", OPT_BOOLEAN, &Stats,	    MSG_OPTIONS_STATISTIC, 0)
  NOREQ_PARAM ("DEBUGStat",   "-S", OPT_BOOLEAN, &DebugStats,	    MSG_OPTIONS_DEBUGSTAT, 0)
  NOREQ_PARAM ("LOGName",     NULL, OPT_STRING,  &g_Logname,	    MSG_OPTIONS_LOGNAME, 0)
  NOREQ_PARAM ("NOLog",       "-l", OPT_BOOLEAN, &o_nlogging,	    MSG_OPTIONS_NOLOG, 0)
  NOREQ_PARAM ("PRIOrity",    NULL, OPT_LONG,    &task_priority,    MSG_OPTIONS_PRIORITY, 0)
  NOREQ_PARAM ("SPECIALhost", NULL, OPT_BOOLEAN, &start_specialhost,MSG_OPTIONS_SPECIALHOST, 0)
  HIDDEN_PARAM("PRINTAUthor", "-c", OPT_BOOLEAN, &g_authors,	    MSG_OPTIONS_PRINTAUTHOR, 0)
  NOREQ_PARAM (NULL,          NULL, OPT_OPTIONSTRING, &filenameptr, MSG_OPTIONS_DVIFILE, 0)
END_PARAM


/*-->DecodeArgs*/
/*********************************************************************/
/***************************** DecodeArgs ****************************/
/*********************************************************************/


char * DecodeArgs(int argc, char *argv[])
{
  BOOL error;
  char pri;

  /*----------------------------------------------------------*/
  error = GetOpt(argc, argv, "ShowDVI", !background, opt);
  /*----------------------------------------------------------*/

  if (error) {
    PrintHelp(opt, FALSE);
    AbortRun(5);	/* Programm Ende */
  }
  if (help) {
    PrintHelp(opt, TRUE);
    AbortRun(0);	/* Programm Ende */
  }
  
  /* Now we can check the arguments		*/
  g_logging	= o_nlogging ? -1 : 0;
  if (DebugStats)	Stats = 2;	/* g_logging is not touched */
  hconvresolution = vconvresolution = resolution;
  /* fontmemsize ueberpruefen ? */


  if (g_paper) {
    int i;
    
    for (i=0; psizes[i].name; i++) {
      if (!stricmp(g_paper, psizes[i].name)) {
        // Papiergroesse *inklusive* dem Offset!
        if (abs(user_paper_width_in+13.13)  > 0.01) Warning(MSG_PAPER_WIDTH_HEIGHT_ERR, "WIDTH");
        if (abs(user_paper_height_in+13.13) > 0.01) Warning(MSG_PAPER_WIDTH_HEIGHT_ERR, "HEIGHT");
        // Offsets aufaddieren, da sie ja gleich wieder abgezogen werden
        user_paper_width_in  = psizes[i].width;
        user_paper_height_in = psizes[i].height;
        break;
      }
    }
    if (!psizes[i].name) {
      Fatal(5, MSG_UNKNOWN_PAPER_SIZE, g_paper);
    }
  }


  /* true Flags setzen */
  hoffset_is_true = GetOneOpt(&hoffset_in_fix, opt)->special;
  voffset_is_true = GetOneOpt(&voffset_in_fix, opt)->special;


  pri = (char)task_priority;
  if (task_priority > 127 || task_priority < -127) {
    task_priority = 0;
  }
  else {
    task_priority = 0;
    task_priority |= (unsigned long)((unsigned char)pri);
  }
  
  /* ToDo initialisieren ? */

  /* Folgender Teil ist noch Amiga spezifisch */
  if (filenameptr != NULL) {
    if (!is_dir(filenameptr)) {
      char namebuf[PATHLEN];
      BPTR lck;
      char *ptr;
 
      strcpy(namebuf, filenameptr);
      if ((ptr = strrchr(namebuf, '.')) == NULL) {
        strcat(namebuf, ".dvi");
      }
      else {
        if (stricmp(ptr, ".tex") == 0) {
          strcpy(ptr, ".dvi");	/* Ueberschreibe das '.tex' */
        }
        else {
          if (stricmp(ptr, ".dvi") != 0) {
            strcat(namebuf, ".dvi");
          }
        }
      }

      dvifp = NULL;
      lck = Lock(namebuf, ACCESS_READ);
      if (lck) {
        NameFromLock(lck, filename, sizeof(filename)-1);
        getdir(namebuf, dirname);
        dvifp = OpenDVI(namebuf, MaxDviBufSize);
        UnLock(lck);
      }
      if (!dvifp) {
        Warning(MSG_CANT_FIND_FILE,namebuf);
	getdir("",filename);
      }
    }
    else { 	/* isdir(filenameptr)	*/
      getdir(filenameptr, filename);
    }
  }
  else { 	/* NULL==filenameptr	*/
    getdir("",filename);	/* kein Name angegeben => nimm das aktuelle Dir. */
  }
  
  return filenameptr;
}




/*-->PrintHelp*/
/*********************************************************************/
/***************************** PrintHelp *****************************/
/*********************************************************************/

static void PrintHelp(struct Options opt[], short long_hlp)
{
  char hlp[140];

  /*Message("");*/ /*hes:wozu, NULL bringt doch die (c) Meldung ? (als Leerzeile) */
  MessageStr(NULL);
  Message(MSG_COPYRIGHT,__DATE__);

  sprintf(hlp, GetTeXString(MSG_USAGE), g_progname);
  GetOptShortHelp(hlp, 73, opt);

  if (long_hlp) {
    MessageStr("");
    GetOptHelp(opt);  
  }
}



/* called only by changing the dvi file (from (am/at)screen) */
void OpenNewDVI(char *filename, int theSame)
/* filename with full path and with (.dvi) extension !!!!!!! */
{
  /* theSame: ist TRUE, falls exact das selbe DVI-File neu geladen werden soll */
  /*          z.B. wenn man nur die Aufloesung aendert.                        */
  

  if (theSame && dvifp != NULL) {
    // wenn ein dvifp Pointer != NULL ist, so ist das File entweder
    // korrekt offen, oder aber TempClose'd. Nach TempOpen muss das File
    // also korrekt offen sein. Falls nicht TempClose'd war, so macht das nichts.
    
    TempOpenDVI(&dvifp);
    if (!dvifp) {
      Fatal(5, MSG_CANT_FIND_FILE, filename);
    }
    DVIrewind(dvifp);
  }
  else {
    if (dvifp != NULL) {
      CloseDVI(dvifp);
    }

#ifdef DEBUG
    if (DeBug) {
      Message("Opening DVI file: %s",filename);
    }
#endif

    if ((dvifp=OpenDVI(filename, MaxDviBufSize)) == NULL) {
      Fatal(5, MSG_CANT_FIND_FILE, filename);
    }
  }

  if (abs(user_paper_width_in+13.13) > 0.01) {
    paper_width = (long)((float)hconvresolution * user_paper_width_in);
  }
  else {
    paper_width  = hconvresolution * HSIZE;		/* for !preload */
  }							/*   default    */
							/*    size      */
  if (abs(user_paper_height_in+13.13) > 0.01) {
    paper_height = (long)((float)vconvresolution * user_paper_height_in);
  }
  else {
    paper_height = vconvresolution * VSIZE;
  }

#ifdef AMIGA
  set_ndvif;		/* new DVI-file is loaded */
  set_dvif;		/* a DVI-File is loaded */
  
  SetShowDVIVars(filename);
  Set_PgPotGadRange();
#endif
}




/*************    C O U N T E R   H A N D L I N G    ********************/
/*									*/
/*  #define clear_counter(i)	page_counter(i,0)			*/
/*  #define set_counter(i)	page_counter(i,1)			*/
/*  #define take_counter(i)	page_counter(i,2)			*/
/*									*/
int page_counter(int i, int m)
{
  static int counter;
  int ret;

  switch (m) {
    case 0:	ret = counter;			/* loeschen	*/
		counter = -1;
#ifdef AMIGA
		write_status();
#endif
		break;
    case 1:	if (counter == -1) {
    		  counter = i;
		}
		else {
		  counter = counter * 10 + i;	/* eintragen	*/
		}
		ret = counter;
#ifdef AMIGA
		write_status();
#endif
		break;
    case 2:	ret = counter;			/* abrufen	*/
		break;
  }
  if (counter != -1 && counter/10000 > 0) {
    counter = counter % 10000;
    ret = counter;
  }

  return (ret);
}
