/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from config.c
*/
/** config.c **/


#include "defines.h"
#include <stdio.h>
#include <ctype.h>

#ifdef AMIGA
# include <fcntl.h>
# include <intuition/intuition.h>
# include "small_arp.h"
#endif

#ifdef ANSI
# include <stdlib.h>
# include <string.h>
#endif

#ifdef AZTEC_C
#  include <functions.h>
#endif

#include <clib/intuition_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <pragmas/graphics_pragmas.h>

#include "globals.h"
#include "globvars.h"
#include "version.h"

#ifdef AMIGA
# include "amscreen.h"
#endif

#include "config.h"

#include "amscreen.i"

#if defined(APP_WINDOW)
# include "app_win.i"
#else
# include "app_icon.i"
#endif

#include "globals.i"
#include "config.i"
#include "dvihand.i"

/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



/* lokale Funktionen */
static FILE *open_config_file			Args((int mode));
static int  parse_line				Args((char *ptr));
static int  readcontents			Args((FILE *config_fp));
static void writecontents			Args((FILE *config_fp));
#ifdef AMIGA
static short what_keyword			Args((char **line));
static char  *get_on_off			Args((int flag));
#endif



static FILE *open_config_file(int mode)
{
  FILE *config_fp;
  int modus;

  if (mode == 0) modus = MODE_READ; 			/* read */
  else modus = MODE_WRITE; 				/* write */

  config_fp = OpenConfigFile(CONFIG_NAME, modus);

  if (config_fp == NULL) {
      Warning(MSG_CANT_OPEN_CONFIG, CONFIG_NAME);
      return(NULL);
  }

  if (mode == 0) {
    Logging(MSG_LOAD_CONFIG, CONFIG_NAME);
  }
  else {
    Logging(MSG_WRITE_CONFIG, CONFIG_NAME);
  }

  return(config_fp);
}



/* bekommt Pointer auf erstes Wort der Zeile, liefert Key-Nummer und	*/
/* Pointer auf naechstes Wort						*/
/* wenn kein korrektes Keyword->line = keyword				*/
static short what_keyword(char **line)
{
  char *keyword, *rest;
  short i;

  rest = keyword = *line;

  /* skip keyword */  
  while (*rest != ' ' && *rest != '\t' && *rest != '\0') {
    rest++;
  }
  /* skip blanks */
  if (*rest != '\0') {
    *rest = '\0';
    rest++;
    while (*rest == ' ' || *rest == '\t') {		/* skip blanks */
      rest++;
    }
  }
  *line = rest;

  for (i=0; i<NKEYS && stricmp(KeyTab[i].keyword,keyword); i++);
  
  if (i == NKEYS) {
    *line = keyword;
    return NR_NO_KEYWORD;
  }
  else {
    return KeyTab[i].keynumber;
  }
}


static int parse_line(char *ptr)
{
  short key;
  long help;
  char *hptr, *keyword_start;
  int ret, on, onok;

  ret = 1;

  while (*ptr == ' ' || *ptr == '\t') {		/* skip blanks */
    ptr++;
  }
  if (*ptr == '\0') return 1;	/* empty line - ok */

  if ((ptr[0] == 'f' || ptr[0] == 'F') && ptr[1] >= '0' && ptr[1] <= '9') {
    /* function key assignment */
    help = ptr[1] - '0' - 1;
    if (ptr[0] == 'F') {
      help += 10;
    }
    if (ptr[1] == '1' && ptr[2] == '0') {
      help += 9;
    }
    while (*ptr != ' ' && *ptr != '\t' && *ptr != '\0') {
      ptr++;
    }
    while (*ptr == ' ' || *ptr == '\t') {		/* skip blanks */
      ptr++;
    }
    if (*ptr == '\0') {
      Warning(MSG_NO_AREXX_FOR_FX,help);
    }
    else {
      show_state.ftast[help] = strdup(ptr);
    }
  }
  else {
    keyword_start = ptr;
    key = what_keyword(&ptr);

    if (key & 1) {
      /* on/off Zeilen */
      onok = TRUE;
      if (!strnicmp(ptr,STR_ON,strlen(STR_ON))) {
        on = TRUE;
      }
      else {
	if (!strnicmp(ptr,STR_OFF,strlen(STR_OFF))) {
	  on = FALSE;
	}
	else {
	  ret = 0;
	  if (*ptr == '\0') {
	    Warning(MSG_NO_ON_OFF);
	  }
	  else {
	    Warning(MSG_WRONG_ON_OFF,ptr);
	  }
	  onok = FALSE;
	}
      }
      if (onok) {
        if (on) {
          switch (key) {
            case NR_SCR_BAR:	set_gadg;
				break;
            case NR_LACE:	set_lace;
				break;
            case NR_BEEP:	set_beep;
				break;
            case NR_ESCEX:	set_escex;
				break;
	    case NR_IMENU:	set_imenu;
				break;
            case NR_BIG_MENU:	set_bmenu;
				break;
            case NR_USE_PHY:	set_usephy;
				break;
	    case NR_APPICON:
            case NR_APP_WIN:	set_appwin;
				break;
            case NR_OS_MENU:	unset_osmenu;
				break;
            case NR_AUTO_AGAIN:	set_autoag;
				break;
	    case NR_USECOL4:	set_col4;
				break;
	    case NR_MIDMENU:	set_midmenu;
				break;
	    case NR_CLWBCOL:	set_clwbcol;
				break;
	    case NR_QUICKQUIT:	set_quickex;
				break;
	    case NR_BLINE:	set_dotbord;
				break;
	    case NR_OWN_SCREEN:	set_ownscr;
				break;
	    case NR_ALWBMFAST:	set_alwbmfast;
				break;
	    case NR_SMARTWIN:	set_smartwin;
				break;
	    case NR_BACKHOOK:	set_bhook;
				break;
          }
        }
        else {
          switch (key) {
            case NR_SCR_BAR:	unset_gadg;
				break;
            case NR_LACE:	unset_lace;
				break;
            case NR_BEEP:	unset_beep;
				break;
            case NR_ESCEX:	unset_escex;
				break;
	    case NR_IMENU:	unset_imenu;
				break;
            case NR_BIG_MENU:	unset_bmenu;
				break;
            case NR_USE_PHY:	unset_usephy;
				break;
	    case NR_APPICON:
            case NR_APP_WIN:	unset_appwin;
				break;
            case NR_OS_MENU:	set_osmenu;
				break;
            case NR_AUTO_AGAIN: unset_autoag;
				break;
	    case NR_USECOL4:	unset_col4;
				break;
	    case NR_MIDMENU:	unset_midmenu;
				break;
	    case NR_CLWBCOL:	unset_clwbcol;
				break;
	    case NR_QUICKQUIT:	unset_quickex;
				break;
	    case NR_BLINE:	unset_dotbord;
				break;
	    case NR_OWN_SCREEN:	unset_ownscr;
				break;
	    case NR_ALWBMFAST:	unset_alwbmfast;
				break;
	    case NR_SMARTWIN:	unset_smartwin;
				break;
	    case NR_BACKHOOK:	unset_bhook;
				break;
          }
        }
      }
    }
    else {
      long i1, i2, i3;
      long numi;
    
      /* weg mit den Spaces am rechten Rand */
      hptr = ptr + strlen(ptr)-1;
      while (isspace(*hptr)) hptr--;
      *(hptr+1) = '\0';

      /* auf Verdacht mal drei Int's lesen */
      numi = sscanf(ptr,"%ld,%ld,%ld",&i1, &i2, &i3);

      switch (key) {
	case NR_NO_KEYWORD :
		Warning(MSG_UNKNOWN_KEYWORD, keyword_start);
		ret = 0;
		break;
	case NR_SCR_MODE :
		if      (strnicmp("pal",ptr,3) == 0)		set_pal;
		else if (strnicmp("ntsc",ptr,4) == 0)		set_ntsc;
		else if (strnicmp("productivity",ptr,12) == 0)	set_prod;
		else if (strnicmp("a2024",ptr,5) == 0)		set_a2024;
		else if (strnicmp("workbench",ptr,5) == 0)	set_wbmode;
		else if (strnicmp("default",ptr,5) == 0)	undef_scrmode;
		else if (numi == 1 || sscanf(ptr, "%lx", &i1) == 1) {
		  /* es *muss* noch die gueltigkeit der ID getestet werden */
		  if (is_os2 && !ModeNotAvailable(i1)) {
		    set_numeric;
		    show_state.DisplayID = i1;
		  }
		  else {
		    Warning(MSG_UNKNOWN_MODEID, i1);
		    ret = 0;
		  }
		}
		else ret = 0;
		break;
	case NR_COLOR_0 :
	case NR_COLOR_1 :
	case NR_COLOR_2 :
	case NR_COLOR_3 :
		if (numi == 3) {
		  const long colR = i1;
		  const long colG = i2;
		  const long colB = i3;
		  if (0 <= colR && colR < 16 && 0 <= colG && colG < 16
			&& 0 <= colB && colB < 16) {
		    switch (key) {
		    	case NR_COLOR_0:
				current_col.red_0   = colR;
				current_col.green_0 = colG;
				current_col.blue_0  = colB;
				break;
			case NR_COLOR_1:
				current_col.red_1   = colR;
				current_col.green_1 = colG;
				current_col.blue_1  = colB;
				break;
		    	case NR_COLOR_2:
				current_col.red_2   = colR;
				current_col.green_2 = colG;
				current_col.blue_2  = colB;
				break;
			case NR_COLOR_3:
				current_col.red_3   = colR;
				current_col.green_3 = colG;
				current_col.blue_3  = colB;
				break;
		    }
		  }
		  else {
		    Warning(MSG_ILLEGAL_COLOR);
		    ret = 0;
		  }
		}
		else {
		  Warning(MSG_WRONG_COLOR_PARAMS);
		  ret = 0;
		}
		break;
	case NR_BASE_DPI :
		if (numi == 1) {
		  resolution      = i1;	/* global variable */
		  hconvresolution = i1;
		  vconvresolution = i1;
		}
		else {
		  Warning(MSG_WRONG_DEF_RESO);
		  ret = 0;
		}
		break;
	case NR_DPI_MENU :
		help = 0;
		while (help < 10 && (hptr = strchr(ptr,',')) != NULL) {
		  *hptr = '\0';
		  show_state.mres[help] = (unsigned short)atoi(ptr);
		  if (show_state.mres[help] == 0 || show_state.mres[help] > 2000) {
		    Warning(MSG_WRONG_VAL_IN_RES_MENU);
		    //help = 0;
		    return 0;
		  }
		  help++;
		  ptr = hptr+1;
		}
		if (help < 10) {
		  show_state.mres[help] = (unsigned short)atoi(ptr);
		  if (show_state.mres[help] == 0 || show_state.mres[help] > 2000) {
		    Warning(MSG_WRONG_VAL_IN_RES_MENU);
		    //help = 0;
		    return 0;
		  }
		  help++;
		}

		if (help > 0) {
		  show_state.menu_res_lines = help;
		}
		break;
	case NR_UNIT :
		if (strnicmp("cm",ptr,2) == 0) {
		  set_unit_cm;
		}
		else if (strnicmp("in",ptr,2) == 0) {
		  set_unit_in;
		}
		else if (strnicmp("pt",ptr,2) == 0) {
		  set_unit_pt;
		}
		else  {
		  Warning(MSG_WRONG_UNITS,ptr);
		  ret = 0;
		}
		break;
	case NR_APP_NAME :
		if (hptr = strdup(ptr)) app_icon_name = hptr;	/* string ok, take it */
		/* man haette vielleicht testen sollen, ob das Icon-File existiert */
		break;
	case NR_APPICONPOS :
		if (numi == 2) {
		  show_state.AppIconX = i1;
		  show_state.AppIconY = i2;
		}
		else {
		  Warning(MSG_WRONG_APPICON_POS,ptr);
		  ret = 0;
		}
		break;
	case NR_SCREEN_SIZE :
		if (numi == 2) {
		  const long scr_x = i1;
		  const long scr_y = i2;
		  if (scr_x != 0 && scr_y != 0 && 
		      (scr_x > 5000 || scr_x > 5000 || 
		       scr_x < 540 || scr_y < 200)) {
		    Warning(MSG_WRONG_MIN_SCREEN_SIZE,ptr);
		    ret = 0;
		  }
		  else {
		    show_state.screen_size_x = scr_x;
		    show_state.screen_size_y = scr_y;
		  }
		}
		else {
		  Warning(MSG_WRONG_SCREEN_SIZE,ptr);
		  ret = 0;
		}
		break;
	case NR_COMMAND :
		show_state.command = strdup(ptr);
		break;
	case NR_AREXXSTART :
		show_state.arexxstart = strdup(ptr);
		break;
	case NR_MONITOR_SIZE :
		if (numi == 2) {
		  show_state.monitor_size_x = i1;
		  show_state.monitor_size_y = i2;
		}
		else {
		  Warning(MSG_WRONG_MONITOR_SIZE, ptr);
		  ret = 0;
		}
		break;
	case NR_PUBSCR_NAME :
		strncpy(PubScreenName, ptr, MAXPUBSCREENNAME);
		break;
	case NR_MY_PUBSCR_NAME :
		strncpy(MyPubScreenName, ptr, MAXPUBSCREENNAME);
		break;
	case NR_WINDOW_POS :
		if (numi == 2) {
		  show_state.window_pos_x = i1;
		  show_state.window_pos_y = i2;
		}
		else {
		  Warning(MSG_WRONG_WIN_POS, ptr);
		  ret = 0;
		}
		break;
	case NR_WINDOW_POS_OWN_SCR :
		if (numi == 2) {
		  show_state.window_pos_own_scr_x = i1;
		  show_state.window_pos_own_scr_y = i2;
		}
		else {
		  Warning(MSG_WRONG_WIN_POS, ptr);
		  ret = 0;
		}
		break;
	case NR_WINDOW_SIZE :
		if (numi == 2) {
		  show_state.window_size_x = i1;
		  show_state.window_size_y = i2;
		}
		else {
		  Warning(MSG_WRONG_WIN_SIZE, ptr);
		  ret = 0;
		}
		break;
	case NR_MAXDVIBUF_SIZE :
		if (numi == 1) {
		  MaxDviBufSize = i1;
		}
		else {
		  Warning(MSG_WRONG_MAX_DVIBUF_SIZE, ptr);
		  ret = 0;
		}
		break;
	case NR_APEN :
		if (numi == 1 && i1 >= 0 && i1 < 256) {
		  show_state.APen = i1;
		}
		else {
		  Warning(MSG_WRONG_PEN, ptr);
		  ret = 0;
		}
		break;
	case NR_BPEN :
		if (numi == 1 && i1 >= 0 && i1 < 256) {
		  show_state.BPen = i1;
		}
		else {
		  Warning(MSG_WRONG_PEN, ptr);
		  ret = 0;
		}
		break;
      }	/* switch */
    }	/* else on/off */
  }	/* else F-tast */

  return ret;
}



static int readcontents(FILE *config_fp)
{
  char line[150], *ptr, *p;
  int ret, rret;
  int i;
  
  /* initialize f-tast array */
  for (i=0; i<20; i++) {
    show_state.ftast[i] = NULL;		/* not used */
  }

  rret = 1;	/* keine Probleme */

  do {
    ptr = fgets(line,149,config_fp);
    if (ptr != NULL) {
      p = strchr(ptr,';');
      if (p != NULL) {		/* cut comment */
        *p = '\0';
      }
      else {
        p = strrchr(ptr,'\n');
        if (p != NULL) {
          *p = '\0';
        }
      }
      ret = parse_line(ptr);
      if (ret != 1) rret = 0;	/* return-code sichern */
    }
  } while (ptr != NULL);

  return rret;
}


static char *get_on_off(int flag)
{
  if (flag) {
    return STR_ON;
  }
  else {
    return STR_OFF;
  }
}


static void writecontents(FILE *config_fp)
{
  int i;

  fprintf(config_fp,GetTeXString(MSG_CONFIG_HEADER), SHOWDVI_VERSION);
  fprintf(config_fp,"%s\t\t\t%d,%d,%d\t\t\t; %s\n",
		STR_COLOR_0,current_col.red_0,current_col.green_0,current_col.blue_0,
		GetTeXString(MSG_CONFIG_RGB_BACK));
  fprintf(config_fp,"%s\t\t\t%d,%d,%d\t\t\t; %s\n",
		STR_COLOR_1,current_col.red_1,current_col.green_1,current_col.blue_1,
		GetTeXString(MSG_CONFIG_RGB_FORE));
  fprintf(config_fp,"%s\t\t\t%d,%d,%d\t\t\t; %s\n",
		STR_COLOR_2,current_col.red_2,current_col.green_2,current_col.blue_2,
		GetTeXString(MSG_CONFIG_RGB_2));
  fprintf(config_fp,"%s\t\t\t%d,%d,%d\t\t\t; %s\n",
		STR_COLOR_3,current_col.red_3,current_col.green_3,current_col.blue_3,
		GetTeXString(MSG_CONFIG_RGB_3));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_SCR_BAR,get_on_off(is_gadg),GetTeXString(MSG_CONFIG_SCROLL_STATE));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_BLINE,get_on_off(is_dotbord),GetTeXString(MSG_CONFIG_BORDER_LINE));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_LACE,get_on_off(is_lace),GetTeXString(MSG_CONFIG_LACE));

  fprintf(config_fp,"%s\t\t\t%s\t\t\t; %s\n",
		STR_BEEP,get_on_off(is_beep),GetTeXString(MSG_CONFIG_BEEP));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_ESCEX,get_on_off(is_escex),GetTeXString(MSG_CONFIG_ESC));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_QUICKQUIT,get_on_off(is_quickex),GetTeXString(MSG_CONFIG_QUICK_EXIT));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_OS_MENU,get_on_off(!is_osmenu),GetTeXString(MSG_CONFIG_POPUP));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_IMENU,get_on_off(is_imenu),GetTeXString(MSG_CONFIG_INT_POPUP));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_BIG_MENU,get_on_off(is_bmenu),GetTeXString(MSG_CONFIG_BIG_POPUP));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_MIDMENU,get_on_off(is_midmenu),GetTeXString(MSG_CONFIG_MIDDLE_POPUP));

  fprintf(config_fp,"%s\t%s\t\t\t; %s\n",
		STR_USE_PHY,get_on_off(is_usephy),GetTeXString(MSG_CONFIG_USEPHY));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_AUTO_AGAIN,get_on_off(is_autoag),GetTeXString(MSG_CONFIG_ACT_LOAD_AGAIN));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_OWN_SCREEN,get_on_off(is_ownscr),GetTeXString(MSG_CONFIG_USE_OWN_SCR));

  fprintf(config_fp,"%s\t%s\t\t; %s\n",
		STR_MY_PUBSCR_NAME,MyPubScreenName,GetTeXString(MSG_CONFIG_SHOW_PUBSCR_NAME));

  fprintf(config_fp,"%s\t%s\t\t; %s\n",
		STR_PUBSCR_NAME,PubScreenName,GetTeXString(MSG_CONFIG_DEF_PUBSCR_NAME));

  fprintf(config_fp,"%s\t\t%ld, %ld\t\t\t; %s\n",
		STR_WINDOW_POS, win2->LeftEdge, win2->TopEdge,
		GetTeXString(MSG_CONFIG_WIN_POS));

  fprintf(config_fp,"%s\t\t%ld, %ld\t\t\t; %s\n",
		STR_WINDOW_SIZE,
		show_state.window_size_x,
		show_state.window_size_y,
		GetTeXString(MSG_CONFIG_WIN_SIZE));

  fprintf(config_fp,"%s\t%ld, %ld\t\t\t; %s\n",
		STR_WINDOW_POS_OWN_SCR, show_state.window_pos_own_scr_x, show_state.window_pos_own_scr_y,
		GetTeXString(MSG_CONFIG_SCR_POS));

  fprintf(config_fp,"%s\t%ld, %ld\t\t\t; %s\n",
		STR_WINDOW_SIZE_OWN_SCR,
		show_state.window_size_own_scr_x,
		show_state.window_size_own_scr_y,
		GetTeXString(MSG_CONFIG_SHOW_WIN_SIZE));

  fprintf(config_fp,"%s\t%s\t\t\t; %s\n",
		STR_BACKHOOK,get_on_off(is_bhook),GetTeXString(MSG_CONFIG_BACK_HOOK));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_USECOL4,get_on_off(is_col4),GetTeXString(MSG_CONFIG_4_COL_SCR));

  fprintf(config_fp,"%s\t\t%s\t\t\t; %s\n",
		STR_CLWBCOL,get_on_off(is_clwbcol),GetTeXString(MSG_CONFIG_USE_WB_COLS));
  
  fprintf(config_fp,"%s\t\t\t%s\t\t\t; %s\n",STR_UNIT,
		(is_unit_in) ? "in" : ((is_unit_cm) ? "cm" : "pt"),GetTeXString(MSG_CONFIG_UNIT));

  fprintf(config_fp,"%s\t%s\t\t\t; %s\n",
		STR_APPICON,get_on_off(is_appwin),GetTeXString(MSG_CONFIG_APP_ICON));

  fprintf(config_fp,"%s\t\t%s\t; %s\n",
		STR_APP_NAME,app_icon_name,GetTeXString(MSG_CONFIG_INFO_APP_ICON));

  fprintf(config_fp,"%s\t\t%d, %d\t\t\t; %s\n",
		STR_APPICONPOS,show_state.AppIconX,show_state.AppIconY,
		GetTeXString(MSG_CONFIG_APP_ICON_POS));

  fprintf(config_fp,"%s\t\t%s\t; %s\n",
		STR_COMMAND, show_state.command, GetTeXString(MSG_CONIFG_SCRIPT_FILE));

  fprintf(config_fp,"%s\t%s\t; %s\n",
		STR_AREXXSTART, show_state.arexxstart, GetTeXString(MSG_CONFIG_TEX_SERVER));

  fprintf(config_fp,"%s\t\t%d, %d\t\t\t; %s\n",
		STR_SCREEN_SIZE,show_state.screen_size_x,show_state.screen_size_y,
		GetTeXString(MSG_CONFIG_SCR_SIZE));

  fprintf(config_fp, "%s\t\t", STR_SCR_MODE);
  if (is_numeric) {
    fprintf(config_fp,"%ld", show_state.DisplayID);
  }
  else {
    fprintf(config_fp,"%s", (is_pal) ? "pal" : ((is_ntsc) ? "ntsc" : 
			((is_prod) ? "productivity": ((is_a2024) ? "a2024" : 
			((is_wbmode) ? "workbench" : "default")))));
  }
  fprintf(config_fp,"\t\t\t; %s\n", GetTeXString(MSG_CONFIG_SCR_MODE));

  fprintf(config_fp,"%s\t\t%d, %d\t\t\t; %s\n",
		STR_MONITOR_SIZE, show_state.monitor_size_x,  show_state.monitor_size_y, 
		GetTeXString(MSG_CONFIG_MONITOR_SIZE));

  fprintf(config_fp,"%s\t%s\t\t\t; %s\n",
		STR_ALWBMFAST, get_on_off(is_alwbmfast), GetTeXString(MSG_CONFIG_ALWBMFAST));

  fprintf(config_fp,"%s\t%s\t\t\t; %s\n",
		STR_SMARTWIN, get_on_off(is_smartwin), GetTeXString(MSG_CONFIG_SMARTWIN));

  fprintf(config_fp,"%s\t%d\t\t\t; %s\n",
		STR_MAXDVIBUF_SIZE, MaxDviBufSize,
		GetTeXString(MSG_CONFIG_MAX_DVIBUF));

  fprintf(config_fp,"%s\t\t\t%d\t\t\t; %s\n",
		STR_APEN, show_state.APen,
		GetTeXString(MSG_CONFIG_APEN));

  fprintf(config_fp,"%s\t\t\t%d\t\t\t; %s\n",
		STR_BPEN, show_state.BPen,
		GetTeXString(MSG_CONFIG_BPEN));

  fprintf(config_fp,"%s\t%d\t\t\t; %s\n",
		STR_BASE_DPI,resolution,GetTeXString(MSG_CONFIG_DEF_RESO));

  fprintf(config_fp,"%s\t\t",STR_DPI_MENU);
  for (i=0; i<show_state.menu_res_lines-1; i++) {
      fprintf(config_fp,"%d,",show_state.mres[i]);
  }
  fprintf(config_fp,"%d\t; %s\n",
		show_state.mres[show_state.menu_res_lines-1],
		GetTeXString(MSG_CONFIG_RESO_MENU));

  for (i=0; i<10; i++) {
    if (show_state.ftast[i] != NULL) {
      fprintf(config_fp,"f%d\t\t\t%s\n",i+1,show_state.ftast[i]);
    }
  }
  for (i=10; i<20; i++) {
    if (show_state.ftast[i] != NULL) {
      fprintf(config_fp,"F%d\t\t\t%s\n",i-9,show_state.ftast[i]);
    }
  }
}


/****************************************************************************/

/* read the config file */
int read_config_file(void)			/* return: success */
{
  FILE *config_fp;
  int ret = 0;

  config_fp = open_config_file(0);	/* read */
  if (config_fp != NULL) {
    ret = readcontents(config_fp);
    (void)fclose(config_fp);
  }

  return ret;
}


/* write the config file */
void write_config_file(void)			/* return: success */
{
  FILE *config_fp;

#if defined(APP_WINDOW)
  if (!save_app_win_pos()) {
    Warning("Can't save app-win-position!");
  }
#else
  (void)save_app_icon_pos();	/* geht eh nicht */
#endif

  config_fp = open_config_file(1);	/* write */
  if (config_fp != NULL) {
    writecontents(config_fp);
    (void)fclose(config_fp);
    Message(MSG_CONFIG_SAVED_OK);
  }
  else {
    Warning(MSG_CANT_SAVE_CONFIG);
    beep();
  }
}

