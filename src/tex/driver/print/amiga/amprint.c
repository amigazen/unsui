/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from amprint.c
*/
#ifdef AMIGA
/************************************************************************/
/*									*/
/*	amprint.c               Druckeransteuerung ueber Device.	*/
/*									*/
/*	make_room(void)		schickt aktuellen Puffer an Drucker	*/
/*	prnflush()              muss zum Schluss gemacht werden, um	*/
/*                              den Puffer auf den Drucker auszugeben	*/
/*									*/
/*	Georg Hessmann          06.07.89 / 11.04.91			*/
/*									*/
/************************************************************************/

#include "defines.h"

#include <sprof.h>

#include <exec/types.h>
#include <exec/execbase.h>
#include <stdio.h>
#include <exec/exec.h>
#include <exec/tasks.h>
#include <exec/ports.h>
#include <dos/dos.h>
#include <dos/dosextens.h>
#include <devices/printer.h>
#include <graphics/rastport.h>

#ifdef ANSI
#  include <dos.h>
#  include <string.h>
#  include <stdlib.h>
#endif

#ifdef LATTICE
#  include <clib/exec_protos.h>
#  include <clib/dos_protos.h>
#  include <pragmas/exec_pragmas.h>
#  include <pragmas/dos_pragmas.h>
#endif

#ifdef AZTEC_C
#  include <functions.h>
#endif

#include "globals.h"
#include "amprint.h"
#include "bitmap.h"

#include "globals.i"
#include "dviprint.i"
#include "amprint.i"
#include "amprhelp.i"
#include "muiprint.i"


/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"





/* Globale Variablen */
/* long bufflen; (schon in dviprint) */
long bufferz;
char *buffer;
char *bufferA, *bufferB;
int  bufferZu_A, bufferZu_B;
int  aktBufNr;

int background;

#ifdef DEBUG
unsigned long count_print_bytes=0;
#endif


/* Externe globale Variablen */
extern union printerIO *request;
extern struct MsgPort *printerPort;
extern int  is_printer_started;		/* 0: nein, 1: init ok, 2: print gestartet   */
extern int  is_printing_aborted;	/* 0: nein, 1: ja, also kein prnzero!	     */
/*extern long error;*/

extern struct ExecBase *SysBase;


void check_background(void)
{
  struct Process *my_proc;
  struct CommandLineInterface *cli;

  background = FALSE;  
  my_proc =(struct Process *)FindTask(NULL);
  if (my_proc != NULL && my_proc->pr_TaskNum != 0) {	/* cli-process */
    cli = (struct CommandLineInterface *)(my_proc->pr_CLI << 2);
    if (cli != NULL) {
      background = (cli->cli_Background != DOSFALSE);
    }
  }
  os_2 = SysBase->LibNode.lib_Version >= 36L;
}


#ifdef IO_TEST
void prn_string(char *str, int len)
{
  BYTE error;
  (void)Chk_Abort();
  request->iostd.io_Command = PRD_RAWWRITE;
  request->iostd.io_Length = len;
  request->iostd.io_Data = (APTR) str;
  error = DoIO((struct IORequest *)request);
  if (error != 0L) PrinterError(error);
}
#endif


/*****  make_room() makes the other buffer current ***************/
void make_room()
{
  char *full_buffer=buffer;
  long full_length=bufferz;

  if (aktBufNr == BUF_A) {
    buffer = bufferB;
    aktBufNr = BUF_B;
  }
  else {
    buffer = bufferA;
    aktBufNr = BUF_A;
  }
  bufferz = 0L;

#if defined(HARDDEB)
    printf("J:make_room(%ld)\n",full_length);
#endif

  if (output_file_ptr) {
    /* Ausgabe in ein File, nicht zum Drucker */
    if (fwrite(full_buffer,sizeof(char),full_length,output_file_ptr) != full_length) {
      Fatal(5,MSG_CANT_WRITE_OUTPUT_FILE);	/* Deadlock ?	*/
    }
    MUIEvent();		// mal die Oberflaeche antesten...
  }
  else {
    /* Ausgabe auf den Drucker */
    if (aktBufNr==BUF_B) {
      bufferZu_A = BUF_VOLL;		/* buffer A ist voll */
      if (bufferZu_B==BUF_VOLL) {	/* der andere auch */
        WaitForPrinterOK();		/* wartet auch auf ^C und wertet Fehler aus */
        bufferZu_B = BUF_LEER;
      }                                 /* nu is er leer */
    }
    else {
      bufferZu_B = BUF_VOLL;
      if (bufferZu_A==BUF_VOLL) {
        WaitForPrinterOK();		/* wartet auch auf ^C und wertet Fehler aus */
        bufferZu_A = BUF_LEER;
      }                                /* nu is er leer */
    }
    request->iostd.io_Command = PRD_RAWWRITE;
    request->iostd.io_Length = full_length;
    request->iostd.io_Data = (APTR) full_buffer;
    SendIO((struct IORequest *)request);
    is_printer_started = 2;
  }
}


/*****  prnflush                        ***************/
void prnflush(void)
{
#ifdef DEBUG
  if (DeBug) {
    fprintf(stderr,"flushing printing-buffer! %d bytes printed.\n",
			count_print_bytes);
  }
#endif
#if defined(HARDDEB)
  printf("J:prnflush (%ld)\n",bufferz);
#endif

  if (iffprint)	return;

  if (bufferz)	make_room();
  /*  bufferz ist nun = 0 */
  if (is_printer_started > 1) {
    WaitForPrinterOK(); 	/* wartet auch auf ^C und wertet Fehler aus */
    bufferZu_A = BUF_LEER;
    bufferZu_B = BUF_LEER;
  }
#if 0
  aktBufNr = BUF_A;
  buffer = &(bufferA[0]);
#endif
}


/* macht das selbe wie WaitIO, bricht aber bei CTRL-C sofort ab! */
void WaitForPrinterOK(void)
{
  ULONG io_mask    = 1L<<printerPort->mp_SigBit;		/* 1<<request->iostd.io_Message.mn_ReplyPort->mp_SigBit; */
  ULONG sig_mask;
  BYTE error;

  do {

    PROFILE_OFF();
    sig_mask = Wait(SIGBREAKF_CTRL_C | io_mask | ((usegui) ? GUIsignals : 0L));
    PROFILE_ON();

    if (sig_mask & SIGBREAKF_CTRL_C) CXBRK();	/* mach Schluss Mann, ey */

    if (usegui && (sig_mask & GUIsignals)) MUIEvent();

  } while (!(sig_mask & io_mask));

  /* we must WaitIO() to remove the request from the port */
  PROFILE_OFF();
  WaitIO((struct IORequest *)request);
  PROFILE_ON();

  /* the signal bit is not cleared if the request was already finished */
  SetSignal(0L, io_mask);
  error = request->iostd.io_Error;
  is_printer_started = 1;
  if (error != 0) PrinterError(error);

}




#if 0 /* ARggggggggggggggggggggggggggggggggggggggggggg!!!!!!!!!!!!!!!!! */

/* macht das selbe wie WaitIO, bricht aber bei CTRL-C sofort ab! */
void WaitForPrinterOK(void)
{
/*  ULONG ctrlc_mask = SIGBREAKF_CTRL_C;*/
  ULONG io_mask    = 1L<<printerPort->mp_SigBit;
			/* 1<<request->iostd.io_Message.mn_ReplyPort->mp_SigBit; */
  ULONG sig_mask;
  BYTE error;

#if defined(HARDDEB)
  printf(">WFPOK(%d)\n",is_printer_started);
  if ((ULONG)(1L<<printerPort->mp_SigBit)&SetSignal(0L,0L))
    printf("Printer signal set\n");
#endif
#if defined(VERSUCH)
  if (CheckIO((struct IORequest *)request) == NULL) {	/* nicht fertig? */
    sig_mask = Wait(ctrlc_mask | io_mask);
    if (sig_mask & io_mask) {
#if defined(HARDDEB)
      printf("WaitIO\n");
#endif
      WaitIO((struct IORequest *)request);
      error = request->iostd.io_Error;
      is_printer_started = 1;
      if (error != 0) PrinterError(error);
    }
    if (sig_mask & ctrlc_mask) {
      CXBRK();	/* mach Schluss Mann, ey */
    }
  }
  else {
    /* hier muss auch noch auf ^C getestet werden, falls 	*/
    /* der Drucker zu schnell ist				*/
    Chk_Abort();
    /* nochmal WaitIO(), um den Auftrag vom Port zu entnehmen	*/
    WaitIO((struct IORequest *)request);
    /* We must clear the signal because the request was ready */
    SetSignal(0L, (ULONG)(1L<<printerPort->mp_SigBit));
    is_printer_started = 1;
  }
#else /*VERSUCH*/
#if 0
  if (CheckIO((struct IORequest *)request) == NULL) {	/* nicht fertig? */
    sig_mask = Wait(SIGBREAKF_CTRL_C | io_mask);
  }
#if defined(HARDDEB)
  else printf("request ready\n");
#endif
#else
  sig_mask = Wait(SIGBREAKF_CTRL_C | io_mask);
#endif
  if (sig_mask & SIGBREAKF_CTRL_C) {
      CXBRK();	/* mach Schluss Mann, ey */
#if defined(HARDDEB)
      printf("Rueckkehr aus CXBRK!\n");
#endif
  }
  /*Chk_Abort(); geht nicht richtig */
 /* we must WaitIO() to remove the request from the port */
#if defined(HARDDEB)
  printf("WaitIO\n");
#endif
  WaitIO((struct IORequest *)request);
  /* the signal bit is not cleared if the request was already finished */
  SetSignal(0L, io_mask);
  error = request->iostd.io_Error;
  is_printer_started = 1;
  if (error != 0) PrinterError(error);
#endif /* VERSUCH */
#if defined(HARDDEB)
  printf("<WFPOK\n");
#endif
}

#endif
#endif /* ARggggggggggggggggggggggggggggggggggggggggggg!!!!!!!!!!!!!!!!! */
