/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from GetOpt.c
*/
/*********************************************************************
 *                                                                   *
 *                                                                   *
 *  GetOpt.c         enthaelt die Routinen zum Auswerten der         *
 *                   Kommando-Zeile und der Environment-Variable.    *
 *                                                                   *
 *								     *
 *                   30-May-91  Georg Hessmann                       *
 *                                                                   *
 *                                                                   *
 *********************************************************************/

#include "defines.h"

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include <exec/types.h>
#include <dos/dos.h>
#include <workbench/workbench.h>
#include <workbench/startup.h>

#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/icon_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/icon_pragmas.h>

extern struct ExecBase		*SysBase;
extern struct DosLibrary	*DOSBase;
extern struct Library		*IconBase;

extern struct WBStartup		*WBenchMsg;



#include "globals.h"
#include "globals.i"


#define TEX		/* ShowDVI/DVIprint */

#include "GetOpt.h"
#include "GetOpt.i"




/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



/*
 * lokale Funktionen
 *
 */

static BOOL MyNameFromLock (BPTR lock, char *buffer, long len);

static void FillLocHlpTxt         (struct Options opt[]);

static void __stdargs GetOptError (int keynr, struct Options opt[], char *format,...);
static BOOL ExamineKeyword        (int keynr, char *option, BOOL *use_option, struct Options opt[]);
static BOOL ScanArgVektor         (int argc, char *argv[], struct Options opt[]);
static BOOL ScanString            (char *envcont, struct Options opt[]);
static BOOL ScanEnvString         (char *envname, struct Options opt[]);
static BOOL ScanWBArgs	          (struct Options opt[]);
static BOOL check_req_para        (struct Options opt[]);
static int  StrOptiCmp		  (char *option, char *para, char **arg);


#ifdef TEX

/* Tabelle der Seitengroessen */
struct PSizes psizes[] = {
  { "A0",   84.09/2.54, 118.92/2.54 },
  { "A1",   59.46/2.54,  84.09/2.54 },
  { "A2",   42.04/2.54,  59.46/2.54 },
  { "A3",   29.73/2.54,  42.04/2.54 },
  { "A4",   21.02/2.54,  29.73/2.54 },
  { "A5",   14.87/2.54,  21.02/2.54 },
  { "A6",   10.51/2.54,  14.87/2.54 },
  { "A7",    7.43/2.54,  10.51/2.54 },
  { "A0r", 118.92/2.54,  84.09/2.54 },
  { "A1r",  84.09/2.54,  59.46/2.54 },
  { "A2r",  59.46/2.54,  42.04/2.54 },
  { "A3r",  42.04/2.54,  29.73/2.54 },
  { "A4r",  29.73/2.54,  21.02/2.54 },
  { "A5r",  21.02/2.54,  14.87/2.54 },
  { "A6r",  14.87/2.54,  10.51/2.54 },
  { "A7r",  10.51/2.54,   7.43/2.54 },
  { NULL, 0, 0}
};


/*
 * dimen_to_inch() returns the dimension given in the first argument
 * in inches in the second argument. It returns 0, if all is ok, otherwise
 * a value != 0.
 */

struct unit_table { char *unit; float factor; };

static struct unit_table unittable[] = {
  {"pt", 72.27},	{"bp", 72.0},
  {"cm", 2.54},		{"mm", 25.4},
  {"in", 1.0},		{"mi", 1000.0},	/* "milli-inches" for TPIC */
  {"pc", 72.27/12},	{"sp", 72.27/65536},
  {"dd", 72.27/(1238/1157)},
  {"cc", 72.27/12/(1238/1157)},
  {NULL, 0.0}
};

int dimen_to_inch(char *str, float *inch_value, int *isTrue)
{ 
  register struct unit_table *d;
  float value;
  char  unitArr[8];	/* we need min. 2+1 characters for %2s  + 4 fuer 'true' !! */
  char * unit = unitArr;
  
  if (sscanf(str, "%f%6s", &value, unit) != 2) {
    return 1;
  }
  
  if (strnicmp(unit, "true", 4) == 0) {
    *isTrue = TRUE;
    unit  += 4;
  }
  else {
#ifdef TEX_TRUE_DIM
    *isTrue = FALSE;
#else
    *isTrue = TRUE;
#endif
  }

  for (d = unittable; d->unit != NULL; d++) {
    if (stricmp(d->unit, unit) == 0) {
	*inch_value = value / d->factor;
	return 0; // alles ok...lasse negative Werte wieder zu...wenn man die nicht will, so soll man sie wo anders ausschliessen!
	//return ((*inch_value) < 0.0);	// mag keine negativen Dimensionen
    }
  }
  return 1;
}

#endif /* TEX */



/*
 * MyNameFromLock()
 *
 * Macht was der Name verspricht...
 * Wenn der lock auf ein Directory zeigt wird zusaetzlich noch ein '/'
 * angehaengt.
 *
 */


static BOOL MyNameFromLock(BPTR lock, char *buffer, long len)
{
  BPTR lock1;
  char strh[108], *h;
  struct FileInfoBlock *fib;
  int l;

  if (lock == (BPTR)NULL) {
    if (len < 5) {
      return FALSE;
    }
    strcpy(buffer, "SYS:");
    return TRUE;
  }

  buffer[0]='\0';
  l = 1;	/* 1 wg. '\0' Byte */

  fib = (struct FileInfoBlock *)xmalloc((unsigned)sizeof(struct FileInfoBlock));

  if (Examine(lock,fib) == 0) {
    xfree(fib);
    return FALSE;
  }

  l += strlen(fib->fib_FileName);
  if (l < len) {
    strcpy(buffer, fib->fib_FileName);
  }

  if (fib->fib_DirEntryType > 0 ) {		/* Directory? */
     if (++l < len) {
       strcat(buffer,"/");
     }
  }

  lock1 = ParentDir(lock);
  /** UnLock((BPTR)lock); NEIN der uebergebene Lock wird NICHT freigegeben! */
  lock = lock1;

  while (lock!=(BPTR)NULL) {
    if (Examine(lock,fib)==0) {
      xfree(fib);
      return FALSE;
    }
    else {
       l += strlen(fib->fib_FileName) + 1;
       if (l < len) {
         strcpy(strh,fib->fib_FileName);
         strcat(strh,"/");
         strcat(strh,buffer);
         strcpy(buffer,strh);
       }
    }
    lock1 = ParentDir(lock);
    UnLock((BPTR)lock);
    lock = lock1;
   }
  h = strchr(buffer,'/');
  if (h != NULL) {
    h[0] = ':';
  }
  xfree((char *)fib);

  return (BOOL)(l < len);
}



/*
 * FillLocHlpTxt()
 *
 * Nimmt die msg_ Nummern und setzt die hlp_txt Felder in opt[].
 *
 */

static void FillLocHlpTxt(struct Options opt[])
{
  int k;
  
  for (k=0; opt[k].type != OPT_LAST_ENTRY; k++) {
    if (opt[k].msg_hlp_txt > 0) {
      opt[k].hlp_txt     = GetTeXString(opt[k].msg_hlp_txt);
      opt[k].msg_hlp_txt = 0;	// nur einmal GetTeXString() machen
    }
    if (opt[k].msg_hlp_txt2 > 0) {
      opt[k].hlp_txt2     = GetTeXString(opt[k].msg_hlp_txt2);
      opt[k].msg_hlp_txt2 = 0;	// nur einmal GetTeXString() machen
    }
  }
}



/*
 * GetOptError()
 *
 * keynr ist das aktuelle Keywort oder -1
 * format,... ist der Errorstring.
 *
 */

static void __stdargs GetOptError(int keynr, struct Options opt[], char *format,...)
{
  va_list argptr;
  char buffer[512];		/* stack! */
  int len;
  
  va_start(argptr, format);
  vsprintf(buffer, format, argptr);
  va_end(argptr);

  len = strlen(buffer);
  if (len >511) {
    Fatal(20,MSG_GETOPT_LINEBUF_OVERFLOW);
  }

  if (keynr == -1) {
    Warning(MSG_GETOPT_ERROR,buffer);
  }
  else {
    if (opt[keynr].name == NULL) {
      Warning(MSG_GETOPT_ERROR,opt[keynr].hlp_txt);
    }
    else {
      Warning(MSG_GETOPT_ERROR_KEY,opt[keynr].name, opt[keynr].hlp_txt);
    }
    WarningStr("\t   %s",buffer);
  }

}


/*
 * ExamineKeyword()
 *
 * Nimmt 'keynr' und einen Option String und updated das 'result' Feld.
 * use_option gibt an, ob 'option' gebraucht wurde.
 *
 */

static BOOL ExamineKeyword(int keynr, char *option, BOOL *use_option, struct Options opt[])
{
  void *res = opt[keynr].result;
  BOOL  error  = 0;
  float tmp;

  switch (opt[keynr].type) {
     case OPT_HELP:
         *(long *)res = TRUE;
         *use_option = FALSE;
         opt[keynr].is_given = TRUE;
         break;
     case OPT_BOOLEAN:
	 if (option == NULL) {
           *(long *)res = TRUE;		/* wenn nichts angegeben => TRUE */
           *use_option = FALSE;
	 }
	 else {
           if (stricmp(option, "on") == 0) {
             *(long *)res = TRUE;
             *use_option = TRUE;
           }
           else {
             if (stricmp(option, "off") == 0) {
               *(long *)res = FALSE;
               *use_option = TRUE;
             }
             else {
               *(long *)res = TRUE;	/* wenn nichts angegeben => TRUE */
               *use_option = FALSE;
             }
            }
         }
         opt[keynr].is_given = TRUE;
         break;
     case OPT_STRING:
         if (option == NULL) {
           error = 1;
           GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_NO_OPTION_STRING));
         }
         else {
           *(char **)res = option;
           *use_option = TRUE;
           opt[keynr].is_given = TRUE;
         }
         break;
     case OPT_LONG:
         if (option == NULL) {
           error = 1;
           GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_MISSING_NUM));
         }
         else {
           if (sscanf(option,"%ld", res) == 1) {
             *use_option = TRUE;
             opt[keynr].is_given = TRUE;
           }
           else {
             GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_NO_NUMBER),option);
             error = 1;
           }
         }
         break;
     case OPT_FLOAT:
         if (option == NULL) {
           error = 1;
           GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_MISSING_REAL));
         }
         else {
           if (sscanf(option,"%f", &tmp) == 1) {
             *use_option = TRUE;
             *(float *)res = tmp;
             opt[keynr].is_given = TRUE;
           }
           else {
             GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_NO_REAL), option);
             error = 1;
           }
         }
         break;
#ifdef TEX
     case OPT_TEX_DIM:
         if (option == NULL) {
           error = 1;
           GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_MISSING_TEX));
         }
         else {
           int isTrue;
           if (dimen_to_inch(option, &tmp, &isTrue)) {
             error = 1;
             GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_NO_TEX), option);
           }
           else {
             *use_option   = TRUE;
             *(float *)res = tmp;
             opt[keynr].special  = isTrue;
             opt[keynr].is_given = TRUE;
           }
         }
         break;
#endif
     default:
         GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_UNKNOWN_PARAM));
         break;
  }

  return error;
}


/*
 * ScanArgVetor()
 *
 * nimmt argc/argv, opt[] und updated das result Flag
 *
 * LIMITATION:
 *   Leider kann zu jedem Keyword nur eine Option ausgewertet werden!
 *
 */

static BOOL ScanArgVektor(int argc, char *argv[], struct Options opt[])
{
  int i, j;
  int  keynr;			/* Nummer des gefundenen Keywords (-1: kein Keyword) */
  char *para;			/* aktueller Parameter -- Keyword */
  char *option;			/* Option zum Keyword (falls gebraucht) */
  BOOL conc_opt;		/* zusammengesetzte Option */
  BOOL found;
  BOOL error=FALSE;		/* ist ein Fehler aufgetreten? */

  for (i=0; i<argc && !error; i++) {	/* Schleife ueber alle Argumente */

    para = argv[i];			/* aktueller Parameter */
    keynr = -1;				/* bisher kein Keyword */

    found = FALSE;			/* suche nach dem passenden Keyword */
    conc_opt = FALSE;

      for (j=0; opt[j].type != OPT_LAST_ENTRY; j++) {
      if (opt[j].name != NULL) {

        /* suche ob Keyword passt */
	char *rest = NULL;
	if (StrOptiCmp(opt[j].name, para, &rest) == 0) {
	  if (rest != NULL) {
	    conc_opt = TRUE;
	    option = rest;
	  }
	  else {
	    option = (i == argc-1) ? NULL : argv[i+1];
	  }
	  found = TRUE;
	}
	/* opt.abbrev is case sensitive for Unix like options */
	else if (opt[j].abbrev != NULL && strncmp(opt[j].abbrev, para, opt[j].alen) == 0) {
	  switch(para[opt[j].alen]) {
	    case '\0':
	      found = TRUE;
	      option = (i == argc-1) ? NULL : argv[i+1];
	      break;
	    case '=':
	      found = TRUE;
	      conc_opt = TRUE;
	      option = &para[opt[j].alen+1];
	      break;
	    /*default: not found */
	  }
	}
	if (found) {
	  keynr = j;
	  break;
	}
      }		/* name != NULL */
    }		/* for	i	*/

    if (found) {				/* Keyword gefunden? */
      BOOL use_option = FALSE;	/* wurde die Option fuer keynr gebraucht */
      error = ExamineKeyword(keynr, option, &use_option, opt);
      if (!error) {
        if (use_option) {
          if (!conc_opt) {
            i++;				/* ein Parameter als Option verbraucht */
          }
        }
        else {
          if (conc_opt) {
            if (opt[keynr].type == OPT_BOOLEAN) {
              GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_WRONG_ONOFF_PARAM),option);
            }
            else {
              /* der Fall kann *nie* auftreten, aber sicher ist sicher... */
              GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_NO_PARAM_EXPECTED),option);
            }
            error = TRUE;
          }
        }
      }
    }
    else {					/* kein Keyword */
      int k;
      /* hier neue Bedeutung fuer 'found'! */
      /* found = FALSE; */			/* Platz gefunden? */
      for (k=0; opt[k].type != OPT_LAST_ENTRY; k++) {
        if (opt[k].type == OPT_OPTIONSTRING && !opt[k].is_given) {
          /* noch freien Option-Platz gefunden */
          found = TRUE;
          *((char **)opt[k].result) = strdup(argv[i]);
          opt[k].is_given = TRUE;
	  break;
        }
      }
      
      if (!found) {
        GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_UNKNOWN_KEYWORD),para);
        error = 1;
      }

    }	/* found	*/
  }	/* for	i	*/
  
  return error;
}


/*
 * ScanString()
 *
 * Zerlegt die Ausgabe von getenv() in ein argc/argv Feld.
 *	(Thank's Dave!)
 */

static BOOL ScanString(char *envcont, struct Options opt[])
{
  register char *ptr;
  int argc = 0;   	/* Zähler für gefundene Argumente */
  char *argv[40]; 	/* 40 Zeiger auf Strings */
  char *begin;
  char c;
  BOOL somethingfound = FALSE;
  BOOL inanf;		/* in Anfuehrungszeichen?? */
  BOOL error = FALSE;
  
  ptr = envcont;

  while (isspace(*ptr)) ptr++;	/* Leerzeichen am Anfang ueberlesen */
  begin = ptr;			/* begin zeigt auf den Anfang des ersten Params */
  inanf = FALSE;

  while ((c = *ptr++) && argc < 40) {

    if (isspace(c)) {
      if (inanf) continue;			/* SPACE in Anf.: no action */
      else {
        *(ptr-1) = '\0';			/* String beenden */
        argv[argc++] = begin;			/* Anfang des String eintragen */
        while (isspace(*ptr)) ptr ++;		/* Leerzeichen am Anfang ueberlesen */
        begin = ptr;				/* begin zeigt auf den Anfang des ..*/
      }
    }
    else {
      if (c == '"') {
	if (*ptr == '"') {			/* Zwei " nacheinander sind ein " */
           register char *d=ptr,*s=ptr+1;
           while (*d++ = *s++);			/* String zusammenziehen */
						/* kein !! ptr++; denn das 2. " ist ueberkopiert */
        }
        else {
          inanf = !inanf;
        }
      }
      else {
        somethingfound = TRUE;
      }
    }
  }

  if (argc >= 40) {
    GetOptError(-1, opt, GetTeXString(MSG_GETOPT_TOO_MANY_ENV_ARGS));
    return 1;
  }

  if (somethingfound && begin != ptr) {
    argv[argc++] = begin;
  }

  if (argc != 0) {
    error = ScanArgVektor(argc, argv, opt);
  }
  
  return error;
}



/*
 * ScanEnvString()
 *
 * Liest den 'envname' String aus und ruft ScanString() auf.
 *
 */

static BOOL ScanEnvString(char *envname, struct Options opt[])
{
  char *envcont;		/* Inhalt der Env-Variablen */
  char *ptr;
  BOOL error = FALSE;
  
  if ((ptr = getenv(envname)) != NULL) {
    envcont = malloc(strlen(ptr)+1);
    /* envcont = strdup(ptr); */
    if (envcont == NULL) {
      GetOptError(-1, opt, GetTeXString(MSG_GETOPT_NO_MEM_FOR_ENV));
      error = TRUE;
    }
    else {
      strcpy(envcont, ptr);
      ScanString(envcont, opt);
    }
  }
  
  return error;
}



/*
 * ScanWBArgs()
 *
 * Liest die Workbench Argumente.
 *
 */



static BOOL ScanWBArgs(struct Options opt[])
{
  BPTR oldlock;
  struct WBArg *arg;
  struct DiskObject *diskobj;
  char *ptr, *option;
  int keynr, i;
  BOOL error, use_option, found, was_icon_base;
  
  error = FALSE;

  arg = WBenchMsg->sm_ArgList;            /* Programmname überspringen */

  if (IconBase != NULL) {
    /* ShowDVI macht die selber auf und braucht die auch weiterhin... */
    was_icon_base = TRUE;
  }
  else {
    IconBase = OpenLibrary("icon.library", 0);
    if (IconBase == NULL) {
      return TRUE;	/* Fehler! */
    }
    was_icon_base = FALSE;
  }

  for (i=0; i< WBenchMsg->sm_NumArgs; i++, arg++) {

    oldlock = CurrentDir(arg->wa_Lock);		/* Verzeichnis auswaehlen */
    diskobj = GetDiskObject(arg->wa_Name);

    if (diskobj != NULL) {
      keynr = 0;
      while (opt[keynr].type != OPT_LAST_ENTRY) {

        ptr = FindToolType(diskobj->do_ToolTypes, opt[keynr].name);
        if (ptr == NULL ) {
          ptr = FindToolType(diskobj->do_ToolTypes, opt[keynr].abbrev);
        }

        if (ptr != NULL) {
          if (*ptr != '\0') {
            option = strdup(ptr);			/* dupliziere String, wird laenger benoetigt */
          }
          else {
            option = ptr;				/* leerer String muss nicht dupliziert werden */
          }
          if (option != NULL) {
            if (*option == '\0') option = NULL;		/* leerer String == NULL String */
	    error = ExamineKeyword(keynr, option, &use_option, opt);
	    if (!error) {
	      if (!use_option && option != NULL) {
                if (opt[keynr].type == OPT_BOOLEAN) {
                  GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_WRONG_ONOFF_PARAM),option);
                }
                else {
                  /* der Fall kann *nie* auftreten, aber sicher ist sicher... */
                  GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_NO_PARAM_EXPECTED),option);
                }
                error = TRUE;
	      }
	    }
	  }
        }

        keynr++;
      }

      if (i > 0) {
        /* alle Filenamen, ausser dem Prognamen, werden als OPT_OPTIONSTING abgelegt */

        found = FALSE;				/* Platz gefunden? */
        keynr = 0;
        while (opt[keynr].type != OPT_LAST_ENTRY && !found) {
          if (opt[keynr].type == OPT_OPTIONSTRING && *((long *)opt[keynr].result) == 0L) {
            char buffer[150];
	    if (MyNameFromLock(arg->wa_Lock, buffer, 149)) { 
	      if (strlen(buffer) + strlen(arg->wa_Name) < 149) {
	        strcat(buffer, arg->wa_Name);
                found = TRUE;
                *((char **)opt[keynr].result) = strdup(buffer);
                opt[keynr].is_given = TRUE;
	      }
	    }
          }
          keynr++;
        }
        
        if (!found) {
          GetOptError(keynr, opt, GetTeXString(MSG_GETOPT_SUPER_FILE),arg->wa_Name);
          error = 1;
        }
      }

      FreeDiskObject(diskobj);
      CurrentDir(oldlock);           /* altes Verzeichnis wieder */
    }
    else {
      /* diskobj == NULL */
      GetOptError(-1, opt, GetTeXString(MSG_GETOPT_NO_INFO), arg->wa_Name);
      /* error = 1; nicht unbedingt ein Fehler (wg. WB 2.0) */
    }
  }

  if (!was_icon_base) {
    CloseLibrary(IconBase);
    IconBase = NULL;
  }
  
  return error;
}



static BOOL check_req_para(struct Options opt[])
{
  int k;

  for (k=0; opt[k].type != OPT_LAST_ENTRY; k++) {
    if (opt[k].required == OPT_REQUIRED && !opt[k].is_given  ) {
      GetOptError(k, opt, GetTeXString(MSG_GETOPT_PARAM_REQU));
      return TRUE;
    }
  }
  return FALSE;
}



/*
 * Funktionen nach aussen. ----------------------------------------------
 *
 */



  /**********************************************************************/
  /* GetOptShortHelp: Gibt eine kurze Hilfe aus.			*/
  /*                    helpline    Vorgegebener Zeilenanfang.		*/
  /*			linelength  Auf wieviel Zeichen pro Zeile soll	*/
  /*				    die Ausgabe formatiert werden.	*/
  /*			opt         Array der Parameterdefinitionen.	*/
  /*		      Der Text wird mit der Funktion Message ausgegeben */
  /**********************************************************************/

void GetOptShortHelp(char *helpline, int linelength, struct Options opt[])
{
  char tmp[104], line[104], *ptr;
  int k, len, used;

  FillLocHlpTxt(opt);

  if (linelength > 100) linelength = 100;

  strncpy(line, helpline, 100);
  len = strlen(line);
  used = FALSE;

  for (k=0; opt[k].type != OPT_LAST_ENTRY; k++) {
    ptr = NULL;
    tmp[0] = '\0';

    switch (opt[k].type) {
     case OPT_HELP:
         ptr = "";
         break;
     case OPT_BOOLEAN:
         ptr = " on|off";
         break;
     case OPT_STRING:
         ptr = " str";
         break;
     case OPT_LONG:
         ptr = " number";
         break;
     case OPT_FLOAT:
         ptr = " real";
         break;
#ifdef TEX
     case OPT_TEX_DIM:
         ptr = " TeX-dim";
         break;
#endif
     case OPT_OPTIONSTRING:
         sprintf(tmp, "%.50s", opt[k].hlp_txt);
         break;
    }
    if (ptr != NULL) {
      if (opt[k].name != NULL) {
        sprintf(tmp, "%.20s%s",opt[k].name, ptr);
      }
      /* else: gibt's nicht! opt[k].name == NULL <==> OPT_OPTIONSTRING */
    }

    if (!opt[k].hidden) {
      if (strlen(tmp)+len > linelength) {
        if (used) {
          MessageStr(line);
          strcpy(line,"\t");
          len = 8;
          //used = FALSE;
        }
        else {
          return;  /* ein Eintrag alleine ist schon laenger als die Zeile... */
        }
      }

      if (opt[k].required == OPT_NOT_REQUIRED) {
        strcat(line, "[");
        strcat(line, tmp);
        strcat(line, "]  ");
        len += 2;
      }
      else {
        strcat(line, tmp);
        strcat(line, "  ");
      }
      len += strlen(tmp) + 2;
      used = TRUE;
    }
  }
  if (used) MessageStr(line);
}



  /**********************************************************************/
  /* GetOptHelp:  Gibt fuer jede Option eine Zeile Hilfstext aus.	*/
  /*		  Mit Angabe der derzeitigen Belegung des result-Feldes	*/
  /*		  als Defaultangabe.					*/
  /*			opt	Array der Parameterdefinitionen.	*/
  /**********************************************************************/

void GetOptHelp(struct Options opt[])
{
  int k;
  void *res;
  char helpline[200], tmp[200], t2[100];
  
  FillLocHlpTxt(opt);

  for (k=0; opt[k].type != OPT_LAST_ENTRY; k++) {
    res = opt[k].result;
    
    helpline[0] = '\0';

    if (opt[k].name == NULL) {
      sprintf(tmp,GetTeXString(MSG_GETOPT_TAB_TAB_DEF), opt[k].hlp_txt);
    }
    else {
      if (opt[k].abbrev != NULL) {
        sprintf(t2, "%.20s|%.20s", opt[k].name, opt[k].abbrev);
      }
      else {
        strcpy(t2, opt[k].name);
      }
      if (strlen(t2) > 7) {
        strcat(t2,"\t");
      }
      else {
        strcat(t2,"\t\t");
      }
      if (opt[k].type == OPT_HELP) {
        sprintf(tmp,"\t%.50s%.50s", t2, opt[k].hlp_txt);
      }
      else {
        sprintf(tmp,GetTeXString(MSG_GETOPT_TAB_DEF), t2, opt[k].hlp_txt);
      }
    }

    /* Vorsicht vor Overflow! */
    if (strlen(tmp)+strlen(helpline) > 200-20) {
      continue;
    }

    strcat(helpline,tmp);

    switch (opt[k].type) {
     case OPT_HELP:
         /* HELP hat kein Default-Wert... */
         break;
     case OPT_BOOLEAN:
         if (*(long *)res) {
           strcat(helpline,"on");
         }
         else {
           strcat(helpline,"off");
         }
         break;
     case OPT_STRING:
         if (*(char **)res == NULL) {
           strcat(helpline,GetTeXString(MSG_GETOPT_NO_DEFAULT));
         }
         else {
           if (strlen(*(char **)res)+strlen(helpline) < 200) {
             strcat(helpline, *(char **)res);
           }
         }
         break;
     case OPT_LONG:
         sprintf(tmp,"%ld", *(long *)res);
         strcat(helpline, tmp);
         break;
     case OPT_FLOAT:
         sprintf(tmp, "%f", *(float *)res);
         strcat(helpline, tmp);
         break;
#ifdef TEX
     case OPT_TEX_DIM:
         if (fabs((double)*(float *)res+(double)13.13) > 0.01) {
           sprintf(tmp, "%.2fin", *(float *)res);
#ifdef TEX_TRUE_DIM
           if (opt[k].special) {
             sprintf(tmp, "%.2ftruein", *(float *)res);
           }
           else {
             sprintf(tmp, "%.2fin", *(float *)res);
           }
#endif
           strcat(helpline, tmp);
         }
         else {
           strcat(helpline,GetTeXString(MSG_GETOPT_NO_DEFAULT));
         }
         break;
#endif
     case OPT_OPTIONSTRING:
         if (*(char **)res == NULL) {
           strcat(helpline,GetTeXString(MSG_GETOPT_NO_DEFAULT));
         }
         else {
           if (strlen(*(char **)res)+strlen(helpline) < 200) {
             strcat(helpline, *(char **)res);
           }
         }
         break;
    }
    if (opt[k].type != OPT_HELP) {
      strcat(helpline,")");
    }
    if (!opt[k].hidden) {
      MessageStr(helpline);				/* !!! */
      if (opt[k].hlp_txt2 != NULL) {
        MessageStr("\t\t\t%s", opt[k].hlp_txt2);	/* !!! */
      }
    }
  }
}



  /**********************************************************************/
  /* CheckOpt_Given: Wurde Option angegeben ?				*/
  /*	Die Option wird anhand des 'result' Eintrags erkannt.		*/
  /*	Ergebnis: -1: nicht gefunden, 0: nicht angegeben, sonst 1.	*/
  /**********************************************************************/

int CheckOpt_Given(void *which, struct Options opt[])
{
  struct Options *o;

  FillLocHlpTxt(opt);

  for (o=opt; o->type != OPT_LAST_ENTRY; o++) {
    if (o->result == which) return (int)o->is_given;
  }
  return -1;
}




  /**********************************************************************/
  /* GetOneOpt: Liefert den struct der Option zurueck.			*/
  /**********************************************************************/
struct Options * GetOneOpt(void *which, struct Options opt[])
{
  struct Options *o;

  FillLocHlpTxt(opt);

  for (o=opt; o->type != OPT_LAST_ENTRY; o++) {
    if (o->result == which) return o;
  }
  return NULL;
}



  /**********************************************************************/
  /* GetOpt:	Parameter-Parse Funktion.				*/
  /*		Liest erst die Environmentvariable aus und wertet dann	*/
  /*		argc/argv aus.						*/
  /*			argc	Direkt aus main() zu uebernehmen.	*/
  /*			argv	Direkt aus main() zu uebernehmen.	*/
  /*			envname	Name der Environmentvariable.		*/
  /*			opt	Array der Parameterdefinitionen.	*/
  /**********************************************************************/


BOOL GetOpt(int argc, char *argv[], char *envname, int interaktiv, struct Options opt[])
{
  BOOL error;
  int k, helpfeld;
  int frmwb = FALSE;

  FillLocHlpTxt(opt);

  /* Initialisiere 'len' Feld */
  for (k=0; opt[k].type != OPT_LAST_ENTRY; k++) {
    /* auf 0 ist alles sowieso schon gesetzt */
    if (opt[k].name != NULL) {
      opt[k].len = strlen(opt[k].name);
    }
    if (opt[k].abbrev != NULL) {
      opt[k].alen = strlen(opt[k].abbrev);
    }
    if (opt[k].type == OPT_HELP) {
      helpfeld = k;
    }
  }

  error = ScanEnvString(envname, opt);
  if (!error) {
    if (argc == 0) {
      frmwb = TRUE;
      interaktiv = FALSE;
      error = ScanWBArgs(opt);
    }
    else {
      error = ScanArgVektor(argc-1, &(argv[1]), opt);
    }
  }
  
  if (!frmwb && opt[helpfeld].is_given) {
    char *buf, *ptr, *p, *str;

    if ((buf = malloc(255)) != NULL) {		// ausnahmsweise kein xmalloc()
      error = FALSE;
      GetOptShortHelp("", 73, opt);

      if (interaktiv) {
        fprintf(stdout,GetTeXString(MSG_GETOPT_PRESS_RET));	/*hes: printf ist ok, wenn schon fgets verwendet wird*/
        ptr = fgets(buf, 254, stdin);

        if (ptr) {
          p = strrchr(ptr, '\n');
          if (p != NULL) *p = '\0';
        }
        else {
          buf[0] = '\0';
        }

        if (buf[0] != '\0') {
          opt[helpfeld].is_given = FALSE;
          *((long *)opt[helpfeld].result) = FALSE;
          str = strdup(ptr);		/* der Speicher muss fest bleiben! */
          error = ScanString(str, opt);
        }
      }
      free(buf);				// *kein* xfree()
    }
  }

  if (!error) {
    error = check_req_para(opt);
  }

  if (opt[helpfeld].is_given) {
    error = FALSE;	/* Bei Hilfe wird alles verziehen! */
  }
  return error;
}


  /**********************************************************************/
  /* StrOptiCmp: Vergleicht Option mit Parameter, wobei mindestens	*/
  /*	soviele Buchstaben uebereinstimmen muessen, wie Grossbuchstaben	*/
  /*	im Optionsnamen stehen.						*/
  /*	Ergebnis: 0 fuer Ok, sonst -1					*/
  /* 'rest' wird nur bei Uebereinstimmung mit anschliessendem '='	*/
  /* gueltig und zeigt dann auf den Rest des Strings nach dem '='.	*/
  /**********************************************************************/
static int StrOptiCmp(char *option, char *para, char **arg)
{
   /*char *start = para;*/
   for (; *option  != '\0' && isupper(*option); option++, para++) {
     if (*para == '\0' || *option != toupper(*para)) return -1;
   }
   for (; *para; para++, option++) {
     if (*option == '\0' || toupper(*para) != toupper(*option))
       if (*para == '=') {
         *arg = para+1;
         return 0;
       }
       else {
         return -1;
       }
   }
   return 0;
}
