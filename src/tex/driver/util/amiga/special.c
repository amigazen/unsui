/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from special.c
*/
/* special.c */

#include "defines.h"

#include <sprof.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <exec/types.h>
#include <exec/exec.h>
#include <exec/ports.h>
#include <dos/dos.h>
#include <dos/dostags.h>
#include <intuition/intuition.h>

#include "globals.h"
#include "special.h"
#include "bitmap.h"

#include "globals.i"
#include "amscreen.i"

#include <clib/alib_protos.h>
#include <clib/exec_protos.h>
#include <clib/dos_protos.h>

extern struct ExecBase *SysBase;
extern struct DOSBase *DOSBase;
#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>



/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



extern long  hh;                        /* current h on device */
extern long  vv;                        /* current v on device */
extern struct bitmap map;
extern long upper_limit;
extern long lower_limit;
extern int  Pass, PassNo;


static struct MsgPort *special_port, *reply_port;
static struct special_msg message;
static struct driver_map dmap;



static int  open_port(void);
static void setup_dmap(struct driver_map *dmap);



struct special_map *send_special(char *sp_string)
{
  struct special_msg *reply_msg;
  BPTR lck;

  if (open_port()) {	/* Fehler? */
    return NULL;
  }

  setup_dmap(&dmap);

  message.msg.mn_Node.ln_Type	= NT_MESSAGE;
  message.msg.mn_ReplyPort	= reply_port;
  message.msg.mn_Length		= sizeof(message);
  message.action		= AC_SEND_SPECIAL;
  message.ret			= 0;
  message.special_string	= sp_string;
  message.hresolution		= hconvresolution;
  message.vresolution		= vconvresolution;
  message.bmap			= NULL;
  message.tpic			= NULL;
  message.dmap			= &dmap;
  
  lck = Lock(filename, ACCESS_READ);
  if (lck) {
    message.DVIdirLock = ParentDir(lck);
    UnLock(lck);
  }
  else message.DVIdirLock            = NULL;
  
  message.DVImagnification = mag;
  message.DVIfilename      = filename;
  message.DVIfiledate      = &dvidatestamp;
  message.DVIcurphypage    = current_page_phy;
  
  Message(MSG_SPECIAL_WAIT_FOR_PICT);

  PutMsg(special_port,&(message.msg));

  PROFILE_OFF();
  WaitPort(reply_port);
  PROFILE_ON();

  reply_msg = (struct special_msg *)GetMsg(reply_port);
  if (reply_msg->action != AC_REPLY_SPECIAL) {
    Warning(MSG_SPECIAL_EXPT_REPLY_SPECIAL,reply_msg->action);
    return NULL;
  }
  if (reply_msg->ret != 0) {
    Warning(MSG_SPECIAL_RET_FROM_SPECIAL,reply_msg->ret);
  }

  return reply_msg->bmap;
}


void send_tpic(struct tpic_msg *tp)
{
  struct special_msg *reply_msg;
  BPTR lck;

  if (open_port()) {	/* Fehler? */
    return;
  }

  setup_dmap(&dmap);

  message.msg.mn_Node.ln_Type	= NT_MESSAGE;
  message.msg.mn_ReplyPort	= reply_port;
  message.msg.mn_Length		= sizeof(message);
  message.action		= AC_SEND_TPIC;
  message.ret			= 0;
  message.special_string	= NULL;
  message.hresolution		= hconvresolution;
  message.vresolution		= vconvresolution;
  message.bmap			= NULL;
  message.tpic			= tp;
  message.dmap			= &dmap;

  lck = Lock(filename, ACCESS_READ);
  if (lck) {
    message.DVIdirLock = ParentDir(lck);
    UnLock(lck);
  }
  else message.DVIdirLock            = NULL;

  PutMsg(special_port,&(message.msg));
  
  PROFILE_OFF();
  WaitPort(reply_port);
  PROFILE_ON();

  reply_msg = (struct special_msg *)GetMsg(reply_port);
  if (reply_msg->action != AC_REPLY_TPIC) {
    Warning(MSG_SPECIAL_EXPT_REPLY_TPIC,reply_msg->action);
    return;
  }
  if (reply_msg->ret != 0) {
    Warning(MSG_SPECIAL_RET_FROM_SPECIAL,reply_msg->ret);
  }

  DeletePort(reply_port);
  
  special_port = NULL;
  reply_port   = NULL;
}


void special_ok(void)
{
  struct special_msg *reply_msg;

  if (special_port == NULL || reply_port == NULL) {
    special_port = NULL;
    reply_port = NULL;
    return;
  }

  setup_dmap(&dmap);

  message.msg.mn_Node.ln_Type	= NT_MESSAGE;
  message.msg.mn_ReplyPort	= reply_port;
  message.msg.mn_Length		= sizeof(message);
  message.action		= AC_OK_BITMAP;
  message.ret			= 0;
  message.tpic			= NULL;
  message.dmap			= &dmap;
  message.special_string	= NULL;
  message.hresolution		= hconvresolution;
  message.vresolution		= vconvresolution;

  PutMsg(special_port,&(message.msg));
  
  PROFILE_OFF();
  WaitPort(reply_port);
  PROFILE_ON();

  reply_msg = (struct special_msg *)GetMsg(reply_port);
  if (reply_msg->action != AC_REPLY_BITMAP) {
    Warning(MSG_SPECIAL_EXPT_REPLY_BITMAP,reply_msg->action);
  }
  else {
    if (reply_msg->ret != 0) {
      Warning(MSG_SPECIAL_RET_FROM_SPECIAL,reply_msg->ret);
    }
  }

  DeletePort(reply_port);

  special_port = NULL;
  reply_port   = NULL;
  
  if (message.DVIdirLock) UnLock(message.DVIdirLock);
  message.DVIdirLock = NULL;

  Message(MSG_SPECIAL_PICT_RECEIVED);
}



static int open_port(void)
{
  special_port = NULL;
  reply_port   = NULL;

  special_port = FindPort(SPECIAL_PORT);

  if (special_port == NULL && start_specialhost) {
    int error;
    int count = 0;
    BPTR fh;
    
    fh = Open("nil:", MODE_NEWFILE);
    
    error = SystemTags("SpecialHost", SYS_Input, fh, SYS_Output, NULL, SYS_Asynch, TRUE, SYS_UserShell, TRUE, TAG_DONE);

    if (error) {
      count = 6;
      Close(fh);
    }
    
    do {
      special_port = FindPort(SPECIAL_PORT);
      count++;
      if (!special_port && count < 6) Delay(10);
    } while (!special_port || count < 6);
  }

  if (special_port == NULL) {
    /* no special port */
    Warning(MSG_SPECIAL_FOUND_NO_SPECIAL);
    return TRUE;
  }

  reply_port = CreatePort(SPECIAL_REPLY,0L);
  if (reply_port == NULL) {
    /* no reply port */
    Warning(MSG_SPECIAL_CANT_CREATE_PORT);
    return TRUE;
  }
  return FALSE;		/* kein Fehler */
}


static void setup_dmap(struct driver_map *dmap)
{
#ifdef OLD_NO_OFFSET_VARS
  dmap->x		 = hh + (long)hoffset;
  dmap->y		 = vv + (long)voffset;
#else
  dmap->x		 = hh + OffsetBitmap_X;		// mit landscape usw.
  dmap->y		 = vv + OffsetBitmap_Y; 
#endif
  dmap->width		 = map.width;
  dmap->height		 = map.height;
  dmap->lower_limit	 = lower_limit;
  dmap->upper_limit	 = upper_limit;
  dmap->pixptr		 = map.pixptr;
  dmap->null_x		 = (long)hoffset;
  dmap->null_y		 = (long)voffset;
  dmap->page_width	 = paper_width;
  dmap->page_height	 = paper_height;
  dmap->pass		 = Pass;
  dmap->passes		 = PassNo;
}
