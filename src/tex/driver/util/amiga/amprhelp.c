/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from amprhelp.c
*/
/*************************************************************************/
/*                                                                       */
/*      amprhelp.c              Druckeransteuerung ueber Device.         */
/*                                                                       */
/*      InitPrinterDevice()     oeffnet das Printerdevice usw.           */
/*      ClosePrinterDevice()    schliesst das Printerdevice usw.         */
/*                                                                       */
/*      Georg Hessmann          06.07.88 / 16.06.89 / 11.04.91           */
/*                                                                       */
/*************************************************************************/

#include "defines.h"

#include <stdio.h>
#include <string.h>
#define min(a,b) __builtin_min(a,b)


#include <exec/types.h>
#include <exec/exec.h>
#include <graphics/view.h>
#include <exec/ports.h>
#include <devices/printer.h>

#ifdef ANSI
#  include <stdlib.h>
#endif

#ifdef AZTEC_C
#  include <functions.h>
   struct IORequest *CreateExtIO();
#endif


#include "globals.h"
#include "bitmap.h"
#include "amprint.h"
#include "prhelp.h"


#include "globals.i"
#include "amprint.i"
#include "amprhelp.i"
#include "prhelp.i"

extern struct ExecBase * SysBase;

#include <clib/graphics_protos.h>
#include <clib/alib_protos.h>
#include <clib/dos_protos.h>
#include <clib/exec_protos.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>


#ifndef DISPLAY
#  include <graphics/gfxbase.h>
#  include "iff.h"
   struct Library *IFFBase = NULL;
#  include <exec/types.h>
#  include <devices/printer.h>
#  include <devices/prtbase.h>
#  include <devices/prtgfx.h>
   static UBYTE  old_density = 0;	/* 0 == not used !!! */
   static USHORT old_PrintShade;
   static USHORT old_PrintImage;

   static struct BitMap   system_bm;
   static struct RastPort system_rp;

   struct GfxBase  *GfxBase = NULL;
#endif

static UWORD           bw_ctable[2] = { 0x0FFF, 0x0000 };
static struct ColorMap system_colormap = { 0, COLORMAP_TYPE_V1_2, 2, &(bw_ctable[0]) };




/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



#ifdef AZTEC_C
#define PDERR_NOERR		0L
#endif


/* Globale Variablen */
union printerIO *request = NULL;
struct MsgPort *printerPort = NULL;
/*static BYTE error;*/
int  is_printer_started = 0;	/* 0: nein, 1: init ok, 2: print gestartet   */
int  is_printing_aborted = 0;	/* 0: nein, 1: ja, also kein prnzero!	     */

/* (Externe) globale Variablen */
#ifndef DISPLAY
  extern long bufferz;
  extern long bufflen;
  extern char *bufferA, *bufferB;
  extern int  bufferZu_A, bufferZu_B;
  extern char *buffer;
  extern int  aktBufNr;

  extern struct GfxBase	*GfxBase;
#endif

/* lokale Variablen */

static char *getErrorString	Args((BYTE err));
static void AbortPrinter	Args((void));
#ifndef DISPLAY
static void restore_printer_preferences Args((void));
#endif


#ifdef AZTEC_C
#pragma regcall( /* d0 = */ OpenPrinter(a0))
#pragma regcall( ClosePrinter(a0))
/* #pragma regcall( a0 = getErrorString(d0)) */
#endif




/*****  InitPrinterDevice               ***************/
int InitPrinterDevice(void)
{
  struct MsgPort *testPort;
  int s_en_ab;
  int ret = 0;

#ifndef DISPLAY
  if (ToDo & DO_PBUFFERS) {
    if (bufflen == 0)  bufflen = Printer->pp_buffer_size
			? Printer->pp_buffer_size : BUFFLEN;
    /** if (bufflen == 0)  bufflen    = BUFFLEN; **/
    if (bufflen < 512) bufflen    = 512;
    bufferA    = xmalloc((unsigned)bufflen*sizeof(char));
    bufferB    = xmalloc((unsigned)bufflen*sizeof(char));
    aktBufNr   = BUF_A;
    buffer     = bufferA;
    bufferz    = 0L;
    bufferZu_A = BUF_LEER;
    bufferZu_B = BUF_LEER;
  }

  /* und nun der Teil fuer das wirkliche drucken ... */

  /* oeffnet das parallel.device im FAST mode, hoffe das geht... */
  if (turbo_mode) {
    struct MsgPort  *par_port;

    if ((par_port = CreatePort("dviprint-parallel",0L)) != NULL) {
      struct IOExtPar *par_requ;

      if ((par_requ = (struct IOExtPar *)CreateExtIO(par_port, sizeof(struct IOExtPar))) != NULL) {
        /* hier die Hauptsache! ... */
        par_requ->io_ParFlags |= PARF_FASTMODE;

        if (!OpenDevice("parallel.device", 0L, (struct IORequest *)par_requ, PARF_FASTMODE)) {
          /* so, nun ist das parallel.device im FAST-MODE geoeffnet... */
          CloseDevice((struct IORequest *)par_requ);
	  /*
	   * Jetzt koennte man ein Fatal() Meldung bringen, falls Device.Version
	   * < 36, d.h. kein WB 1.3.3 oder 2.0 Device, welches FASTMODE verstehen
	   * wuerde. Nach kurzem Blick ins RKM bin ich zu dem Schluss gekommen,
	   * dass aeltere Versionen diesen Wert ignorieren.
	   */
        }
        DeleteExtIO((struct IORequest *)par_requ);
      }
      DeletePort(par_port);
    }
  }

  if ((GfxBase = (struct GfxBase *)OpenLibrary(GRAPHICSNAME,0)) == NULL) {
    Fatal(10,MSG_CANT_OPEN,GRAPHICSNAME);
  }

#endif /* DISPLAY */

  if (ToDo & DO_PDEVICE) {

    char *portname = "dviprint";
    char *devname;
    
    s_en_ab = Enable_Abort;
    Enable_Abort = 0;		/* no CTRL-C */

    if (NULL != (testPort = FindPort(portname))) {
#  ifdef DISPLAY
      Warning(MSG_PORT_ALREADY_EXISTS,portname);
      ret = 255;
#  else
      Fatal(5,MSG_PORT_ALREADY_EXISTS,portname);
#  endif
    }
    else {
      if (NULL == (printerPort = (struct MsgPort *) CreatePort(portname,1L))) {
#  ifdef DISPLAY
        Warning(MSG_CANT_OPEN_PRINTER_PORT,portname);
        ret = 255;
#  else
        Fatal(5,MSG_CANT_OPEN_PRINTER_PORT,portname);
#  endif
      }
      else {
        if (NULL == (request = (union printerIO *)
		CreateExtIO(printerPort, sizeof(union printerIO)))) {
	  DeletePort(printerPort);
#  ifdef DISPLAY
	  Warning(MSG_CREATEEXTIO_FAILED);
	  ret = 255;
#  else
	  Fatal(5,MSG_CREATEEXTIO_FAILED);
#  endif
	}
	else {
#ifndef DISPLAY
	  devname = (turbo_mode && !os_2) ? "puffer.device" : "printer.device";
#else
	  devname = "printer.device";
#endif
	  if (OpenDevice(devname, 0L, (struct IORequest *)request, 0L)) {
	    DeleteExtIO((struct IORequest *)request);
	    DeletePort(printerPort);
	    request = NULL;
#  ifdef DISPLAY
	    Warning(MSG_CANT_OPEN,devname);
	    ret = 255;
#  else
	    Fatal(5,MSG_CANT_OPEN,devname);
#  endif
	  }
	  else {
	    /* is_printer_started = 1; */
	    ret = ((int)printerPort->mp_SigBit);
	  }
	}
      }
    }
    Enable_Abort = s_en_ab;	/* CTRL-C on */
  }

  return ret;
}


#ifndef DISPLAY

  /* Funktionen, die die Drucker-Preference auslesen und die Aufloesung	*/
  /* in Abhaengigkeit der DENSITY bestimmen.				*/

void setup_printer_preferences(UBYTE set_density)
{
  struct PrinterData *PD;
  
  PD = (struct PrinterData *)request->iostd.io_Device;
  
  /* set_density == 0 : verwende default density */

  if (set_density > 0 && set_density < 8) {
    old_density = PD->pd_Preferences.PrintDensity;
    PD->pd_Preferences.PrintDensity = set_density;
  }
  old_PrintShade = PD->pd_Preferences.PrintShade;
  old_PrintImage = PD->pd_Preferences.PrintImage;
  PD->pd_Preferences.PrintShade = SHADE_BW;
  PD->pd_Preferences.PrintImage = IMAGE_POSITIVE;

}

static void restore_printer_preferences(void)
{
  struct PrinterData *PD;
  
  if (request != NULL) {
    PD = (struct PrinterData *)request->iostd.io_Device;
    if (old_density != 0) {
      /* nur bei != 0 hat sich an der density auch etwas geaendert */
      PD->pd_Preferences.PrintDensity = old_density;
    }
    PD->pd_Preferences.PrintShade = old_PrintShade;
    PD->pd_Preferences.PrintImage = old_PrintImage;
  }
}

void get_printer_resolution(long *hres, long *vres, short *pwidth)
{
/*(JCH) Thank Darren@cbmvax who helped me make the generic driver work fine.*/

  long dummy;
  struct PrinterData *PD;
  struct PrinterExtendedData *PED;
  static BYTE error;

  InitBitMap(&system_bm, 1, 8, 1);
  system_bm.Planes[0] = (UBYTE *)&dummy;
  InitRastPort(&system_rp);
  system_rp.BitMap = &system_bm;

  request->iodrp.io_Command   = PRD_DUMPRPORT;
  request->iodrp.io_RastPort  = &system_rp;
  request->iodrp.io_ColorMap  = &system_colormap;
  request->iodrp.io_Modes     = 0;
  request->iodrp.io_SrcX      = 0;
  request->iodrp.io_SrcY      = 0;
  request->iodrp.io_SrcWidth  = 1;
  request->iodrp.io_SrcHeight = 1;
  request->iodrp.io_DestCols  = 1000;
  request->iodrp.io_DestRows  = 1000;
  request->iodrp.io_Special   = SPECIAL_MILCOLS | SPECIAL_MILROWS | SPECIAL_NOPRINT | SPECIAL_DENSITY1;

  error = DoIO((struct IORequest *)request);
  (void) SetSignal(0L, (ULONG)(1L<<printerPort->mp_SigBit)); /* we know the request has completed */
  if (error != 0) PrinterError(error);


  PD = (struct PrinterData *)request->iostd.io_Device;
  PED = &PD->pd_SegmentData->ps_PED;

  *hres = PED->ped_XDotsInch;
  *vres = PED->ped_YDotsInch;
  *pwidth = PED->ped_NumRows;
  pp_max_dots_line = PED->ped_MaxXDots;
  if (pp_max_dots_line == 0) pp_max_dots_line = 0xFFFF;	// irgendwein grosser Wert halt

  if (Stats) {
    Warning(MSG_YOU_PRINT_GENERIC);
    Logging(MSG_GENERIC_PRINT_NAME,
        PED->ped_PrinterName,
	(int)PD->pd_SegmentData->ps_Version,
        (int)PD->pd_SegmentData->ps_Revision);
    Warning(MSG_GENERIC_PRINT_RESO,
        (int)PED->ped_XDotsInch,
	(int)PED->ped_YDotsInch,
	(int)PD->pd_Preferences.PrintDensity);
    Logging(MSG_GENERIC_PRINT_MAXD,
           (int)PED->ped_MaxXDots, (int)PED->ped_MaxYDots);
    /*hes: auch auf Bildschirm ?	*/

#if defined(HARDDEB)
    /***** only for debugging */
    Warning("  PrinterClass = %u, ColorClass = %u.",
        (unsigned)PED->ped_PrinterClass, (unsigned)PED->ped_ColorClass);
    Warning("  MaxColumns = %lu, NumCharSets = %lu, NumRows = %hu.",
        PED->ped_MaxColumns, PED->ped_NumCharSets,
	(unsigned short)PED->ped_NumRows);
#endif
  }

  /* nun muesst eigentlich RastPort freigegeben werden (??????) */
}


#endif	/* Ende der Preference-Funktionen */


/*****  getErrorString                  ***************/
static char *getErrorString(BYTE err)
{
  char *ret;

  switch (err)
    {
	case PDERR_NOERR		: ret = GetTeXString(MSG_PRT_ERROR_NO_ERROR);
					  break;
        case PDERR_CANCEL       	: is_printing_aborted = 1;
					  ret = GetTeXString(MSG_PRT_ERROR_ABORT);
					  break;
        case PDERR_NOTGRAPHICS  	: ret = GetTeXString(MSG_PRT_ERROR_NO_GFX);
					  break;
        case PDERR_BADDIMENSION 	: ret = GetTeXString(MSG_PRT_ERROR_ILLDIM);
					  break;
        case PDERR_INTERNALMEMORY       : ret = GetTeXString(MSG_PRT_ERROR_NO_MEM_VARS);
					  break;
        case PDERR_BUFFERMEMORY 	: ret = GetTeXString(MSG_PRT_ERROR_NO_MEM_BUFF);
					  break;
        default				: ret = GetTeXString(MSG_PRT_ERROR_UNKNOWN_ERR);
					  break;
    }

  return ret;
}

/*****  PrinterError                    ***************/
void PrinterError(BYTE err)
{
  Fatal(5,MSG_PRT_ERR,getErrorString(err));
}

/*****  ClosePrinterDevice              ***************/
void ClosePrinterDevice(void)
{
#ifndef DISPLAY
  if (IFFBase != NULL) {
    CloseLibrary(IFFBase);
    IFFBase = NULL;
  }
  if (output_file_ptr) {
    fclose(output_file_ptr);
    output_file_ptr = NULL;
  }
#endif

  if (request!=NULL) {
#if defined(HARDDEB)
    puts(">ClosePReq");
#endif
    if (ToDo & DO_REALPRINT) AbortPrinter();
#ifndef DISPLAY
     if (ToDo & DO_PPREFS)
	restore_printer_preferences();
    /*EndHardcopies();*/
#endif
    CloseDevice((struct IORequest *)request);
    DeleteExtIO((struct IORequest *)request);
    if (printerPort != NULL) {
       DeletePort(printerPort);
       printerPort = NULL;
    }
    request = NULL;
  }

#ifndef DISPLAY
  if (GfxBase != NULL) {
    CloseLibrary((struct Library *)GfxBase);
    GfxBase = NULL;
  }
#if 0 /* in prhelp.c */
  if (PrnBuffer != NULL) {
    xfree(PrnBuffer);
  }
#endif
#endif
}



/*******	AbortPrinter		*********/
/* wird in ClosePrinterDevice() aufgerufen.	*/
static void AbortPrinter()
{
#if defined(HARDDEB)
  printf(">AbortP(%d)\n",is_printer_started);
#endif
  /* Test ob der Drucker ansprechbar ist: */
  if (request == NULL || printerPort == NULL
    /*|| is_printing_aborted*/
    || is_printer_started < 2	/* noch kein request unterwegs */
    ) return;

  if (is_printer_started > 1) {
    /*	Auch den Prefs Drucker muss man stoppen koennen			*/
    if (CheckIO((struct IORequest *)request) == 0L) {	/* nicht fertig */
#if defined(HARDDEB)
      printf("AbortIO\n");
#endif
      AbortIO((struct IORequest *)request);  /* soll ich's wagen ???? 23-feb-91 */
#if defined(HARDDEB)
      printf("WaitIO\n");
#endif
      WaitIO((struct IORequest *)request);
      is_printer_started = 1;
#if defined(HARDDEB)
      {
	BYTE error = request->iostd.io_Error;
        if (error != 0) 
          printf("Error nach AbortIO (error = %d = %s)!\n",error,getErrorString(error));
	  /* kein PrinterError, sonst Endlosschleife! */
      }
#endif
    }
  }
#if defined(HARDDEB)
  puts("<AbortP");
#endif
}


/*****  prnzero                        ***************/
/* wird in globals.c/CXBRK aufgerufen, soll bei einem Prog.abbruch den
   Drucker in initialisierten Zustand zuruecklassen. */
void prnzero(void)
{
#ifdef DISPLAY
  char *bufferA;
#endif
  long blen;
  int noetig = is_printer_started > 1;

#if 0 && !defined(DISPLAY)
  if (!(ToDo & DO_REALPRINT))	return;
#endif

  AbortPrinter();

  /* Test ob der Drucker ansprechbar ist: */
  if (ToDo & DO_NOZERO
    || request == NULL || printerPort == NULL
    || is_printing_aborted
    || !noetig
    ) return;

#ifndef DISPLAY
  if (Printer->pp_grouping)
    blen = Printer->pp_grouping * pp_max_dots_line;
  else blen = 8640;		/* worst case (360dpi*8inch*3group) */
  if (bufflen < blen) blen = bufflen;
#else
  blen = 8640;
#endif

#ifdef DISPLAY
  bufferA=malloc((unsigned)blen*sizeof(char));
#endif
  if (bufferA==NULL) return; /* Prefs Drucker hat auch keinen Puffer */

  Message(MSG_TRY_CLEAR_PRT);

  memset(&(bufferA[0]),0,sizeof(bufferA[0])*blen);

  request->iostd.io_Command = PRD_RAWWRITE;
  request->iostd.io_Length  = blen;
  request->iostd.io_Data = (APTR) &(bufferA[0]);
  DoIO((struct IORequest *)request);
  /* kein PrinterError, sonst Endlosschleife! */
  if (request->iostd.io_Error)
    Message(MSG_CLEAR_FAILED);
#ifdef DISPLAY
  xfree(bufferA);
#endif
}


#ifndef DISPLAY

#if 0
void FormFeedGeneric(void)
{
  char ff = FF;
  puts(">FFGEN");

  /* HardcopyGeneric() macht nun schon selber ein FF beim letzten Pass */
  if (is_printer_started > 1) WaitForPrinterOK();
  request->iostd.io_Command	= CMD_WRITE;
  request->iostd.io_Length	= 1L;
  request->iostd.io_Data	= (APTR) &ff;
  SendIO((struct IORequest *)request);
  is_printer_started = 3;
  puts("<FFGEN");
}
#endif


void HardcopyGeneric(struct bitmap *bmap, long lineno, int draft, int last_pass)
{
  long width, height;

  width = bmap->width;			/* in bits */
  height = min(bmap->height,lineno);	/* in bits */

  if (is_printer_started > 1) WaitForPrinterOK();

  InitBitMap(&system_bm, 1, width, height);
  system_bm.Planes[0] = (UBYTE *)bmap->pixptr;
  InitRastPort(&system_rp);
  system_rp.BitMap = &system_bm;

  request->iodrp.io_Command   = PRD_DUMPRPORT;
  request->iodrp.io_RastPort  = &system_rp;
  request->iodrp.io_ColorMap  = &system_colormap;
  request->iodrp.io_Modes     = 0;
  request->iodrp.io_SrcX      = 0;
  request->iodrp.io_SrcY      = 0;
  request->iodrp.io_SrcWidth  = request->iodrp.io_DestCols = 
			(width > pp_max_dots_line) ? pp_max_dots_line : width;
  request->iodrp.io_SrcHeight = request->iodrp.io_DestRows = height;
  
  request->iodrp.io_Special   = SPECIAL_TRUSTME;
  if (!last_pass) {
    request->iodrp.io_Special |= SPECIAL_NOFORMFEED;
  }
  
  request->iodrp.io_Special |= SPECIAL_NOPRINT;
  DoIO((struct IORequest *)request);

  request->iodrp.io_Special  &= ~SPECIAL_NOPRINT;
  
  /*
   *   Um keinerlei Verzerrungen zu bekommen, uebernehmen wir die 
   *   Angaben vom System, auch wenn dadurch etwas abgeschnitten wird.
   */
  if (request->iodrp.io_DestCols < request->iodrp.io_SrcWidth) {
    request->iodrp.io_SrcWidth  = request->iodrp.io_DestCols;
  }
  if (request->iodrp.io_DestRows < request->iodrp.io_SrcHeight) {
    request->iodrp.io_SrcHeight = request->iodrp.io_DestRows;
  }

  SendIO((struct IORequest *)request);

  is_printer_started = 3;	/* printer laeuft, es gibt auch Buffer! */
}


#else


/*****  PrintRastPort              ***************/
void PrintRastPort(struct RastPort *rp,
		   unsigned long modes,
		   unsigned short sizex, unsigned short sizey,
		   unsigned short in_x,  unsigned short in_y)
{
  request->iodrp.io_Command   = PRD_DUMPRPORT;
  request->iodrp.io_RastPort  = rp;
  request->iodrp.io_ColorMap  = &system_colormap;
  request->iodrp.io_Modes     = modes;
  request->iodrp.io_SrcX      = 0;
  request->iodrp.io_SrcY      = 0;
  request->iodrp.io_SrcWidth  = sizex;
  request->iodrp.io_SrcHeight = sizey;
  request->iodrp.io_DestCols  = in_x;
  request->iodrp.io_DestRows  = in_y;
  request->iodrp.io_Special   = SPECIAL_MILROWS | SPECIAL_MILCOLS;

/**
  printf("PrintRastPort: modes: %ld, SrcX: %d, SrcY: %d,\n\tSrcW: %d, SrcH: %d, DesC: %d, DesR: %d\n",
	request->iodrp.io_Modes    ,
	request->iodrp.io_SrcX     ,
	request->iodrp.io_SrcY     ,
	request->iodrp.io_SrcWidth ,
	request->iodrp.io_SrcHeight,
	request->iodrp.io_DestCols ,
	request->iodrp.io_DestRows );
**/

  SendIO((struct IORequest *)request);

  is_printer_started = 3;	/* printer laeuft, es gibt aber KEINE Buffer! */
}

void EndPrintRastPort(void)
{
  BYTE error;
  if (!CheckIO((struct IORequest *)request)) {
    WaitIO((struct IORequest *)request);
  }
  error = request->iostd.io_Error; /*hes: erst Fehler# laden! */
  if (error != 0) {
    if (error==PDERR_CANCEL) {
      is_printing_aborted = 1;
    }
    Warning(MSG_PRT_ERR,getErrorString(error));
  }
}
#endif
