/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from util/loadfont.c
*/
#include "defines.h"

#include <stdio.h>
#include <string.h>

#include "globals.h"
#include "textypes.h"
#include "pkcom.h"

#include "flmt.h"
#include "new_font.h"
#include "dvihand.h"

#include "globals.i"
#include "loadfont.i"
#include "new_font.i"


/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"




static FILE        *pkfile;
static struct Font *fnt;

static void      badpk	(int sn);
static shalfword __inline pkbyte(void);
static integer   __inline pkquad(void);
static integer   pktrio	(void);



/*---------------------------------------------------------------------------*/
#if 0
/*
 *   A chardesc describes an individual character.  Before the fonts are
 *   downloaded, the flags indicate that the character has already been used
 *   with the following meanings:
 */
typedef struct {
   integer TFMwidth ;
   shalfword pixelwidth ;
   quarterword *packptr ;
   quarterword flags ;
} chardesctype ;
#define EXISTS (1)
#define PREVPAGE (2)
#define THISPAGE (4)
#define TOOBIG (8) /* not used at the moment */
#define REPACKED (16)
#define BIGCHAR (32)
#define STATUSFLAGS (EXISTS|REPACKED|BIGCHAR)
/*
 *   A fontdesc describes a font.  The name, area, and scalename are located in
 *   the string pool. The nextsize pointer is used to link fonts that are used
 *   in included psfiles and differ only in scaledsize.  Such fonts also have
 *   a non-NULL scalename that gives the scaledsize as found in the included
 *   file.  The psflag indicates that the font has been used in an included
 *   psfile.  It can be 0, PREVPAGE, THISPAGE, or EXISTS.
 */
typedef struct tfd {
   integer checksum, scaledsize, designsize, thinspace ;
   halfword dpi, loadeddpi ;
   halfword alreadyscaled ;
   halfword psname ;
   halfword loaded ;
   halfword maxchars ;
   char *name, *area ;
   struct resfont *resfont ;
   struct tft *localfonts ;
   struct tfd *next ;
   struct tfd *nextsize;
   char *scalename;
   quarterword psflag;
   chardesctype chardesc[256] ;
} fontdesctype ;

/*  A fontmap associates a fontdesc with a font number.
 */
typedef struct tft {
   integer fontnum ;
   fontdesctype *desc ;
   struct tft *next ;
} fontmaptype ;
#endif
/*---------------------------------------------------------------------------*/





/*
 *   Now we have some routines to get stuff from the PK file.
 *   Subroutine pkbyte returns the next byte.
 */

static void badpk(int sn)
{
   char name[PATH_SIZE+PK_NAME_SIZE];
   char strbuf[50];
   
   strbuf[sizeof(strbuf)-1] = '\0';
   strncpy(strbuf, GetTeXString(sn), sizeof(strbuf)-1);

   get_full_name(name, fnt);
   (void)sprintf(m_string,GetTeXString(MSG_BAD_PK_FILE),name,strbuf) ;

   if (*strbuf == '!') {
     FatalStr(10,m_string);
   }
   else {
     WarningStr(m_string);
   }
}

static shalfword __inline pkbyte()
{
   register shalfword i ;

   if ((i=getc(pkfile))==EOF) badpk(MSG_UNEXPECTED_EOF_IN_PK);
   return(i);
}

#if 0
static integer __inline pkquad()
{
   register integer i ;

   i = pkbyte() ;
   if (i > 127)
      i -= 256 ;
   i = i * 256 + pkbyte() ;
   i = i * 256 + pkbyte() ;
   i = i * 256 + pkbyte() ;
   return(i) ;
}
#endif

static integer __inline pkquad()
{
  integer i;
  
  if (fread(&i, sizeof(i), 1, pkfile) != 1) badpk(MSG_UNEXPECTED_EOF_IN_PK);
  return i;
}

static integer pktrio()
{
   register integer i ;

   i = pkbyte() ;
   i = i * 256 + pkbyte() ;
   i = i * 256 + pkbyte() ;
   return(i) ;
}



/*
 *   Now our loadfont routine.  We return an integer indicating the
 *   highest character code in the font, so we know how much space
 *   to reserve for the character.  (It's returned in the font
 *   structure, along with everything else.)
 */
void loadfont(struct Font *curfnt, FILE *PKfile)
{
   shalfword i ;
   shalfword cmd ;
   integer k ;
   integer length = 0 ;
   shalfword cc = 0 ;
   quarterword *tempr ;
   long offset;		/* offset in the internal mem */
   struct Chars *cd_base, *cd;
   int maxcc = 0 ;


   pkfile = PKfile;
   fnt = curfnt;

/*
 *   We clear out some pointers:
 */

   cd = cd_base = curfnt->common->ch;

#if 0  /* dies wird nun schon in LoadFont() gemacht! */
   for (i=0; i<NPXLCHARS; i++) {
     cd->pixelwidth  = 0;
     cd->packed_data = -1;	/* NIL pointer in internal memory */
     cd->unpacked    = NULL;
     cd++;
   }
#endif
   
   curfnt->common->maxchars = NPXLCHARS; /* just in case we return before the end */

   if (pkbyte() != PK_PRE) badpk(MSG_EXPECTED_PRE_IN_PK);
   if (pkbyte() != 89)     badpk(MSG_WRONG_ID_IN_PK);

   for(i=pkbyte(); i>0; i--) (void)pkbyte();	/* skip comment */

#if 0
   k = (integer)(alpha * (real)pkquad()) ;	/* design size */
   if (k > curfnt->designsize + fsizetol ||
       k < curfnt->designsize - fsizetol) {
      (void)sprintf(errbuf,"Design size mismatch in font %s", name) ;
      error(errbuf) ;
   }
#else
   (void)pkquad();				/* design size */
#endif

   k = pkquad() ;				/* checksum */
   if (k && curfnt->chksum)
      if (k!=curfnt->chksum) {
         badpk(MSG_CHECKSUM_MISS_IN_PK);
       }

   /* hppp: horizontal pixel per point, vppp: ... */
   (void) pkquad() ; /* assume that hppp is correct in the PK file */
   (void) pkquad() ; /* assume that vppp is correct in the PK file */

/*
 *   Now we get down to the serious business of reading character definitions.
 */
   while ((cmd=pkbyte())!= PK_POST) {
     if (cmd < 240) {
       switch (cmd & 7) {					/* flag */
	 case 0:
	 case 1:
	 case 2:
	 case 3:				/***************** short form **/
            length = (cmd & 7) * 256 + pkbyte() - 3 ;		/* pl */
            cc = pkbyte() ;					/* cc */
            cd = cd_base+cc ;
#if 0
            if (nosmallchars || curfnt->dpi != curfnt->loadeddpi)
               cd->flags |= BIGCHAR ;
#endif
            /* cd->TFMwidth = scalewidth(pktrio(), scaledsize) ; */	/* tfm */
            curfnt->common->fnt_group->tfmw[cc] = pktrio();	/* tfm */
            cd->pixelwidth = pkbyte() ;				/* dm */
            break ;
	 case 4:
	 case 5:
	 case 6:				/***************** extendet short form **/
            length = (cmd & 3) * 65536 + pkbyte() * 256 ;
            length = length + pkbyte() - 4 ;			/* pl */
            cc = pkbyte() ;					/* cc */
            cd = cd_base+cc ;
            /* cd->TFMwidth = scalewidth(pktrio(), scaledsize) ; */	/* tfm */
            curfnt->common->fnt_group->tfmw[cc] = pktrio();	/* tfm */
#if 0
            cd->flags |= BIGCHAR ;
#endif
            i = pkbyte() ;
            cd->pixelwidth = i * 256 + pkbyte() ;		/* dm */
            break ;
	 case 7:				/***************** long form **/
            length = pkquad() - 11 ;
            cc = pkquad() ;					/* cc */
            if (cc<0 || cc>255) badpk(MSG_CHAR_CODE_OUT_OF_RANGE_IN_PK) ;
            cd = cd_base + cc ;
#if 0
            cd->flags |= BIGCHAR ;
#endif
            /* cd->TFMwidth = scalewidth(pkquad(), scaledsize) ; */	/* tfm */
            curfnt->common->fnt_group->tfmw[cc] = pkquad();	/* tfm */
            cd->pixelwidth = (pkquad() + 32768) >> 16 ;		/* dx */
            /* k = */ (void)pkquad() ;				/* dy */
       }	/* end switch */

       if (cc > maxcc) maxcc = cc ;
       if (length <= 0) badpk(MSG_PACKET_LENGTH_SMALL_IN_PK) ;

       /* save the pk part of one char into mem (with cmd/width/height/xoff/yoff) */

       offset = alloc_char(length*sizeof(char));
       if (offset == -1) Fatal (8, MSG_NO_MEM_FOR_CHAR,156);
       cd->packed_data = offset;

       tempr = (char *)(curfnt->common->ch_start_bm + offset);
       *tempr++ = cmd;
       /** for (length--; length>0; length--) *tempr++ = pkbyte() ; **/
       /**/
       if (fread(tempr,1,length-1,pkfile) != length-1) {
	 badpk(MSG_UNEXPECTED_EOF_IN_PK);
       }
       /**/
     }
     else {
         k = 0;
         switch (cmd) {
	   case PK_XXX4:
             k = pkbyte() ;
             if (k > 127) k -= 256;
	   case PK_XXX3:
             k = k * 256 + pkbyte() ;
	   case PK_XXX2:
             k = k * 256 + pkbyte() ;
	   case PK_XXX1:
             k = k * 256 + pkbyte() ;
             while (k-- > 0) /* i = */ (void)pkbyte() ;
             /* koennte man ein fread einsetzen */
             break ;
	   case PK_YYY:
             /* k = */ (void)pkquad();
             break;
	   case PK_NO_OP:
             break;
	   default:
             badpk(MSG_UNEXPECTED_COMM_IN_PK) ;
         }
      }
   }

   curfnt->common->maxchars = maxcc + 1 ;
}
