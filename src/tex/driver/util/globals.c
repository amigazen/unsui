/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from util/globals.c
*/
/*****************************************************************************/
/*    globals.c								     */
/*****************************************************************************/


#include "defines.h"

#include <stdio.h>
#include <time.h>
#include <ctype.h>

#include "globals.h"
#include "flmt.h"
#include "new_font.h"

#ifdef ANSI
#  include <string.h>
#  include <stdlib.h>
#  include <stdarg.h>
#endif


#ifdef AZTEC_C
#  include <functions.h>
#endif

#ifdef DEBUG
# ifdef ATARI
#  ifdef DISPLAY
#   include "bitmap.i"
#  endif
#  include <tos.h>
# endif
#endif

#include "ver_code.h"		/* codierte Strings */
#include "crypt.h"		/* Codierfunktionen */

#include "globals.i"
#include "new_font.i"
#include "dvihand.i"

extern int background;		/* def. in amscreen.c / amprint.c */
extern struct ExecBase		*SysBase;

#include <exec/exec.h>
#include <libraries/locale.h>
#include <clib/exec_protos.h>
#include <pragmas/exec_pragmas.h>

#ifdef DISPLAY
#  include "amscreen.i"
#  include "am_requ.i"
#else
#  include "muiprint.i"
#  ifndef FLIB
#    include <exec/types.h>
#    include <devices/printer.h>	/* wg. amprint.h */
#    include <exec/exec.h>
#    include "amprint.h"
#    include "amprhelp.i"
#    include "dviprint.i"
#  endif
#endif
#include <clib/alib_protos.h>
#include <clib/dos_protos.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/exec_pragmas.h>



#define MAXLINE		150	/* size of maxline buffer	*/



/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"





/* lokale Funktionen */
static void TimeString		Args((char *s));
static int  DoOut		Args((char *buf, char *fmt, va_list args, int log, int message));
static void DoMessage		Args((char *ptr));
static void DoLogging		Args((char *ptr));



#ifdef AMIGA
  extern int Enable_Abort;
#endif /* AMIGA */

extern long g_authors;	/* print author names? Defined in the main-progs */

static char *mo_arr[12] = {"January","February","March","April","May","June",
			"July","August","September",
			"October","November","December"};

static char maxline[MAXLINE];	/* für Message() Warning() Logging() Fatal() */
static int user_aborted;	/* Wurde wegen ^C abgebrochen ? */


#ifdef ATARI
void beep(void)
{
  return;
}
#endif




/*
 ************************************************************************
 *	alloc mem, if no mem available release chars			*
 ************************************************************************
 */

#undef MALLOC_DEBUG		// checke jedes malloc/free


#if defined(MALLOC_DEBUG)
  FILE * MallocDebFile = NULL;
  struct MemDebList {
    struct MemDebList * Next;
    void * Pointer;
  };
  struct MemDebList * MDLst = NULL;
#endif	// MALLOC_DEBUG


void * xmalloc(unsigned bytes)
{
  void * ret;
  int bytes_to_alloc;

#if defined(MALLOC_DEBUG)
  bytes_to_alloc = bytes + 4 + 2 * 16;
#else
  bytes_to_alloc = bytes;
#endif	// MALLOC_DEBUG
  
  ret = malloc(bytes_to_alloc);
  if (ret == NULL) {
    release_mem();
    ret = malloc(bytes_to_alloc);
    if (ret == NULL) {
      Fatal(10,MSG_NOT_ENOUGH_MEM_BYTES, bytes);		/* no memory */
    }
  }
  
  if (ret != NULL) {
    (void)memset(ret, 0, bytes_to_alloc);			/* clear the mem */
  }
  
#if defined(MALLOC_DEBUG)
  {
    long * tmp = (long *)ret;
    tmp[0] = bytes_to_alloc;
    tmp[1] = 0xA1B2C3D4;
    tmp[2] = 0xA1B2C3D4;
    tmp[3] = 0xA1B2C3D4;
    tmp[4] = 0xA1B2C3D4;
    
    tmp = (long *)(((char *)ret + 4 + 16) + bytes);
    tmp[0] = 0xA1B2C3D4;
    tmp[1] = 0xA1B2C3D4;
    tmp[2] = 0xA1B2C3D4;
    tmp[3] = 0xA1B2C3D4;
  }
  
  {
    struct MemDebList * new;
    new = malloc(sizeof(struct MemDebList));
    if (new) {
      new->Next = MDLst;
      new->Pointer = ret;
      MDLst = new;
    }
  }

  if (MallocDebFile == NULL) {
#if defined(DISPLAY)
    MallocDebFile = fopen("ram:ShowDVI.MDeb", "w");
#else
    MallocDebFile = fopen("ram:DVIprint.MDeb", "w");
#endif
  }
  if (MallocDebFile != NULL) {
    fprintf(MallocDebFile, "malloc %6ld bytes (%6ld) at 0x%x (0x%x)\n", 
		bytes, bytes_to_alloc, (void *)((char *)ret + 4 + 16), ret);
  }

  return (void *)((char *)ret + 4 + 16);
#else
  return ret;
#endif	// MALLOC_DEBUG
}



/*
 ************************************************************************
 *	free mem							*
 ************************************************************************
 */

#if defined(MALLOC_DEBUG)

/*
 * Wenn kein MALLOC_DEBUG definiert ist, dann wird in globals.h xfree
 * als Macro definiert.
 */

void xfree(void * poi)
{
  int i;
  long * tmp = (long *)poi - 5;		// size + 4 check
  struct MemDebList * s, *prev;

  if (MallocDebFile != NULL) {
    long * ttt = (long *)((char *)tmp + tmp[0]-16);

    s = MDLst;
    prev = NULL;
    while (s && s->Pointer != tmp) {
      prev = s;
      s = s->Next;
    }
    if (!s) {
      fprintf(MallocDebFile, "** error: Don't find entry in mem-list for 0x%x\n", tmp);
    }
    else {
      if (prev) {
        prev->Next = s->Next;
      }
      else {
        MDLst = s->Next;
      }

      fprintf(MallocDebFile, "free   %6ld bytes (%6ld) at 0x%x (0x%x)\n", 
		tmp[0]-4-2*16, tmp[0], poi, (char *)poi-4-16);
      for (i = 1; i<5; i++) {
        if (tmp[i] != 0xA1B2C3D4) {
          fprintf(MallocDebFile, "** error: Overwrite prev long #%ld with 0x%x\n", i, tmp[i]);
          fflush(MallocDebFile);
          fprintf(stderr, "** error: Overwrite prev long #%ld with 0x%x\n", i, tmp[i]);
        }
      }
      for (i = 0; i<4; i++) {
        if (ttt[i] != 0xA1B2C3D4) {
          fprintf(MallocDebFile, "** error: Overwrite last long #%ld with 0x%x\n", i+1, ttt[i]);
          fflush(MallocDebFile);
          fprintf(stderr, "** error: Overwrite last long #%ld with 0x%x\n", i+1, ttt[i]);
        }
      }
    }
  }

 (void)memset(tmp, 37, tmp[0]);			/* clear the freed mem */
  
  free(tmp);
}

void xfree_all()
{
  while (MDLst) {
    xfree((char *)MDLst->Pointer + 4 + 16);
  }
}
#endif


/*-->TimeString*/
/**********************************************************************/
/*************************  TimeString  *******************************/
/**********************************************************************/
static void TimeString(char *s)
{
  time_t clock = 0L;
  struct tm *tmptr;

  clock = time((long *)0L);
  tmptr = localtime(&clock);

  if (tmptr == NULL) {
    s[0] = '\0';
  }
  else {
    sprintf(s,"\t%2d:%02d, %2d %s %4d", tmptr->tm_hour, tmptr->tm_min,
		tmptr->tm_mday, 
		GetLocString(tmptr->tm_mon+MON_1, mo_arr[tmptr->tm_mon]), 
		tmptr->tm_year+1900);
  }
}


/* print additional copyright text */
#if defined(BETACOPYRIGHT)
void PrintBetaCopy(void)
{
  ENCODE2(COPYRIGHT, m_string);
  WarningStr(m_string);
}
#endif



/*-->GetCopy*/
/**********************************************************************/
/***************************  GetCopy  ********************************/
/**********************************************************************/
char *GetCopy(void)
{
  char s1[30], s2[30], s3[70], s4[30];

  ENCODE(PROGRAMTITLE,s1);
  ENCODE(VERSION,s2);
  ENCODE(PROGRAMKENNUNG,s3);
  ENCODE(VERSION_FORMAT_STRING,s4);

  /*	slight misuse of maxline...	*/

  sprintf(maxline,s4,s1,s2,COMPILER-CR_OFFSET,s3);

  return (maxline);
}


/*-->PrintAuthors*/
/**********************************************************************/
/***************************  PrintAuthors  ***************************/
/**********************************************************************/
void PrintAuthors(void)
{
#ifdef DISPLAY
  char s1[50], s4[20], s[30];
#else
  char s1[50], s3[40], s4[20], s[30];
#endif

  ENCODE(AUTHOR1,s1);
  //ENCODE(AUTHOR2,s2);
  ENCODE(AUTHOR_TITLE,s4);

#ifdef DISPLAY
  ENCODE(AUTHOR_S_FORMAT,s);
  LoggingStr(s,s4,s1);
#else
  ENCODE(AUTHOR3,s3);
  ENCODE(AUTHOR_D_FORMAT,s);
  LoggingStr(s,s4,s1,s3);
#endif

#if defined(BETACOPYRIGHT)
  PrintBetaCopy();
#endif
}



/*-->AbortRun*/
/**********************************************************************/
/***************************  AbortRun  *******************************/
/**********************************************************************/
void AbortRun(int code)
{
  static int InAbortRun = FALSE;

  // don't do a endless loop!
  if (InAbortRun) exit(code);
  InAbortRun = TRUE;
  
#ifndef DISPLAY
  if (do_accounting && is_printer_started > 0) {
    /* Speichere Accounting-File */
    FILE *fp;
    long t;
    char user[20], host[60];
    char *ptr;

    sprintf(m_string, "Account.%s", o_printer_name);
    fp = OpenConfigFile(m_string, MODE_APPEND);
    if (fp != NULL) {
      ptr = getenv("USERNAME");
      if (ptr != NULL) {
        strncpy(user, ptr, 19);
      }
      else {
        strcpy(user, "user");
      }
      ptr = getenv("HOSTNAME");
      if (ptr != NULL) {
        strncpy(host, ptr, 59);
      }
      else {
        strcpy(host, "host");
      }
      time(&t);
      sprintf(m_string, "%s : %s : %s", user, host, ctime(&t));
      m_string[strlen(m_string)-1] = '\0';	/* weg mit dem \n */
      sprintf(maxline, "%s : %d\n", m_string, nr_printed_pages);
      fputs(maxline, fp);
      fclose(fp);
    }
  }
#endif
#ifdef ATARI
   if ((code != -1) || is_gem_installed)
    {
     close_all();
    }
   else
    code = 1;
# ifdef DISPLAY
   if (!is_gem_installed)
    {
     fprintf(stderr,"\033E\033e");
     }
# endif
#else
#  ifdef AMIGA
       Enable_Abort = 0;	/* don't come in my way */
#    ifdef DISPLAY
       close_all_bild();
#    else 			/* DISPLAY */
	 /* prnzero(); wird schon in in BREAK Func gemacht   */
         ClosePrinterDevice();
         /* CloseARP(); */	/* wird nicht mehr benoetigt */
#    endif			/* DISPLAY */
#  endif			/* AMIGA */
#endif 				/* ATARI */

   DebugStats = 0L;	/* don't flush at every line anymore */

   if (g_authors == 1) {
      PrintAuthors();
   }


#ifdef DISPLAY
   if (code != 0) {
     Logging(MSG_PROGRAM_END_ERR, code);
   }
   else {
     if (Stats) write_font_def_file();
     Logging((user_aborted) ? MSG_USER_ABORT : MSG_PROGRAM_END_OK);
   }
#else
   if (code != 0) {
     Warning(MSG_PROGRAM_END_ERR, code);
   }
   else {
     if (Stats) write_font_def_file();
     Warning((user_aborted) ? MSG_USER_ABORT : MSG_DVIP_PRINT_FINISHED);
   }
#endif

#ifdef AMIGA
   if (task_priority != old_task_priority) {
     (void)SetTaskPri(FindTask(NULL), old_task_priority);
   }
#endif

#if defined(MALLOC_DEBUG)
   xfree_all();
#endif

#ifndef DISPLAY
  MUIfree();		/* Oberflaeche (IMMER!!) schliessen, direkt vor dem Prg.Ende */
#endif

   exit(code);		/* everything is closed and freed for us */
}



/*-->Fatal*/
/**********************************************************************/
/***************************  Fatal  **********************************/
/**********************************************************************/

void __stdargs Fatal(int ret, int msg, ...)
{
  va_list argptr;

  va_start(argptr, msg);
  /* sprintf() should return the number of chars output */
  vsprintf(&maxline[sprintf(maxline,GetTeXString(MSG_FATAL))], GetTeXString(msg), argptr);
  va_end(argptr);

  DoLogging(maxline);

#if defined(DISPLAY)
  FatalMessage(ret, &(maxline[0])+8);
#else
  if (usegui) MUIFatal(maxline);
  else DoMessage(maxline);
#endif

  if (g_logging == 1 && NULL != g_logfp) {
    Message(MSG_LOG_FILE_CREATED,g_Logname);
  }
  AbortRun(ret);
}

void __stdargs FatalStr(int ret, char *format,...)
{
  va_list argptr;

  va_start(argptr, format);
  /* sprintf() should return the number of chars output */
  vsprintf(&maxline[sprintf(maxline,GetTeXString(MSG_FATAL))], format, argptr);
  va_end(argptr);

  DoLogging(maxline);

#if defined(DISPLAY)
  FatalMessage(ret, &(maxline[0])+8);
#else
   if (usegui) MUIShowMessWin();
  DoMessage(maxline + strlen(GetTeXString(MSG_FATAL)));
#endif

  if (g_logging == 1 && NULL != g_logfp) {
    Message(MSG_LOG_FILE_CREATED,g_Logname);
  }
  AbortRun(ret);
}



/*-->Logging*/
/**********************************************************************/
/*****************************  Logging  ******************************/
/**********************************************************************/
/* nur ins Logfile */

void __stdargs Logging(int msg, ...)
{
  va_list argptr;

  va_start(argptr, msg);
  DoOut(maxline, GetTeXString(msg), argptr, TRUE, FALSE);
  va_end(argptr);
}

void __stdargs LoggingStr(char *fmt,...)		/* issue a message to the logfile */
{
  va_list argptr;

  va_start(argptr, fmt);
  DoOut(maxline, fmt, argptr, TRUE, FALSE);
  va_end(argptr);
}



/*-->Message*/
/**********************************************************************/
/*****************************  Message  ******************************/
/**********************************************************************/
/* nur auf den Bildschirm */

void __stdargs Message(int msg, ...)
{
  va_list argptr;

  va_start(argptr, msg);
  DoOut(maxline, GetTeXString(msg), argptr, FALSE, TRUE);
  va_end(argptr);
}

void __stdargs MessageStr(char *fmt,...)		  /* issue a message */
{
  va_list argptr;

  if (fmt) {   
    va_start(argptr, fmt);
    DoOut(maxline, fmt, argptr, FALSE, TRUE);
    va_end(argptr);
  }
  else {
    DoOut(maxline, GetCopy(), argptr, FALSE, TRUE);
  }
}



/*-->Warning*/
/**********************************************************************/
/*****************************  Warning  ******************************/
/**********************************************************************/
/* sowohl ins Logfile als auch an den Bildschirm */

void __stdargs Warning(int msg, ...)
{
  va_list argptr;

#if defined(AMIGA) && defined(DISPLAY)
  beep();
#endif

  va_start(argptr, msg);
  DoOut(maxline, GetTeXString(msg), argptr, TRUE, TRUE);
  va_end(argptr);
}

void __stdargs WarningStr(char *fmt,...)  	/* issue a warning */
{
  va_list argptr;

#if defined(DISPLAY)
  beep();
#else
   if (usegui) MUIShowMessWin();
#endif

  if (fmt) {
    va_start(argptr, fmt);
    DoOut(maxline, fmt, argptr, TRUE, TRUE);
    va_end(argptr);
  }
  else {
    DoOut(maxline, GetCopy(), argptr, TRUE, TRUE);
  }
}



/*************************************************************************/
/*******	Fatal, Warning, Logging, Message support functions	**/
/*************************************************************************/
static int DoOut(char *buf, char *fmt, va_list args, int log, int message)
{
  char *ptr;
  int length = 0;	/* we could check for overflows	*/

  if (fmt == NULL) {
    ptr = GetCopy();
    if (message) DoMessage(ptr);
    if (log) {
      char time[30];
      TimeString(time);
      strcat(ptr, time);
      strcat(ptr, "\n");
    }
  }
  else {
    ptr = buf;
    length = vsprintf(ptr, fmt, args);
    if (length >= MAXLINE) Fatal(20, MSG_LINE_BUFFER_OVERFLOW,length);
#if defined(AMIGA) && defined(DISPLAY)
    /* es wird etwas ungleich 'copyright' ausgegeben */
    if (message) AddTimeRequest();	/* aus amscreen.c */
#endif
    if (message) DoMessage(ptr);
  }
  if (log) DoLogging(ptr);
  return length;
}



static void DoLogging(char *ptr)
{
  if (g_logging == 0) {
    if (NULL == g_logfp) {
      g_logfp = fopen(g_Logname,"w");
    }
    g_logging = (NULL == g_logfp) ? -1 : 1 ;
  }

  if (g_logging == 1 && g_logfp) {

    fputs(ptr, g_logfp);
    fputs("\n",g_logfp);

#ifdef AMIGA
    if (DebugStats) {
      fclose(g_logfp);	/* Kampf dem 'empty' log (aber nur mit -S) */
      g_logfp = fopen(g_Logname,"a");
      if (g_logfp == NULL) {
        g_logging = -1;
      }
    }
#else
    fflush(g_logfp);
#endif
  }
}



static void DoMessage(char *ptr)
{
#ifdef DISPLAY

	/* die naechsten zwei Ausgaben auf stderr sollten die einzigen im */
	/* gesamten ShowDVI sein!!!	(und keine Ausgabe auf stdout)	  */

	if (!write_screen(ptr)) {		/* ShowDVI */
	  fprintf(stderr, "%s\n", ptr);
#if 0
	  if (!background) {
	    printf("%s\n",ptr);			/* nix screen */
	  }
#endif
	}

#else

    if (usegui) MUIMessage(ptr);
    else if (!background) printf("%s\n",ptr);			/* DVIprint */

#endif	/* DISPLAY */
}



/*========================================================================*/


#ifdef AMIGA


/*-->_abort*/
/**********************************************************************/
/***************************  _abort  *********************************/
/**********************************************************************/
void _abort(void)
{
  (void)CXBRK();
}


/*
 * Neue SAS/c 6.0 Break-Funktion
 */
int _CXBRK(void)
{
  return CXBRK();
}


/**********************************************************************/
/************************  free_resources  ****************************/
/**********************************************************************/
int CXBRK(void)		/* overwrite standard Lattice-function */
{
#ifdef DISPLAY
  if (Enable_Abort) {
    if (can_i_exit()) {	/* is a other window on the screen */
      Enable_Abort = 0;	/* no recursive break */
      Message(MSG_BREAK);
      user_aborted = 1;
      AbortRun(0);
      return -1;	/* not reached (exit) */
    }
    else {
      return 0;		/* no exit */
    }
  }
  else {
    return 0;		/* no exit */
  }
#else /* DISPLAY */
  if (Enable_Abort) {
    Enable_Abort = 0;	/* no recursive break */
    Message( is_printer_started	? MSG_BREAK_IO : MSG_BREAK);
    prnzero();
    user_aborted = 1;
    AbortRun(0);
    return -1;	/* not reached (exit) */
  }
  else {
    return 0;		/* no exit */
  }
#endif /* DISPLAY */
}



/********************************/
/*  ARexx Port to call Metafont */
/********************************/


static int PutRexxMsg(struct MsgPort *mp, long action, STRPTR arg0,
				struct RexxMsg *arg1, char *extension);


int call_mf(char *fntname, long fontmag, long hres, long vres,
		long driver_type, char *pkname, char *pkdir)
{
  char com[256], *tmp;
  int ret = FALSE, result = 20;

  tmp = getenv("CALLMF");

  if (tmp != NULL) {

#if defined(HARDDEB)
    printf("ENV:CALLMF len %d & last char %x.\n",strlen(tmp),tmp[strlen(tmp)-1]);
#endif
    /* Ein Aufruf:
       "callmf cmr10 120 100 100 show|print 100/cmr10.100pk tex:preview"
    */

    sprintf(com,"\'%s %s %ld %ld %ld %s %s %s\'", tmp, fntname, fontmag, hres, vres,
		(driver_type == 0) ? "show" : "print" , pkname, pkdir);
    Logging(MSG_CALL_MF, com);
    if (!call_rexx(com, &result)) {
#ifndef DISPLAY
      MessageStr("%s :",com);
#endif
      Warning(MSG_AREXX_COMM_START_FAILED);
    }
    else {
      if(!(ret = (result == 0))) {
        Warning(MSG_AREXX_COMM_FAILED, com, result);
      }
    }
  }

  return ret;
}

#include <exec/types.h>
#include <libraries/dos.h>
#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <string.h>
#include <dos.h>

#include <rexx/rxslib.h>
#include <rexx/errors.h>

STRPTR		CreateArgstring(STRPTR, long);
void		DeleteArgstring(STRPTR);
struct RexxMsg	*CreateRexxMsg(struct MsgPort *, STRPTR, STRPTR);
void		DeleteRexxMsg(struct RexxMsg *);

#pragma libcall RexxSysBase CreateArgstring 7e 0802
#pragma libcall RexxSysBase DeleteArgstring 84 801
#pragma libcall RexxSysBase CreateRexxMsg   90 09803
#pragma libcall RexxSysBase DeleteRexxMsg   96 801

#define PORTNAME	"Call-MF"
#define RXEXTENS	"rexx"

#ifndef DISPLAY
  struct RxsLib *RexxSysBase = NULL;
#else
  extern struct RxsLib *RexxSysBase;
#endif

static int PutRexxMsg(struct MsgPort *mp, long action, STRPTR arg0,
		struct RexxMsg *arg1, char *extension)
{
  struct RexxMsg *rm;
  struct MsgPort *rp;

  if ((rm = CreateRexxMsg(mp, extension, mp->mp_Node.ln_Name)) != NULL) {
    rm->rm_Action  = action;
    rm->rm_Args[0] = arg0;
    rm->rm_Args[1] = (STRPTR)arg1;
/*    rm->rm_Stdin   = Output(); */
/*    rm->rm_Stdout  = Output(); */
    Forbid();
    if ((rp = FindPort(RXSDIR)) != NULL) {
      PutMsg(rp, (struct Message *)rm);
    }
    Permit();
    if (rp == NULL) {
      DeleteRexxMsg(rm);
    }
  }
  return rm != NULL && rp != NULL;
}


int call_rexx(char *str, int *result)
{
  char *arg;
  struct MsgPort *mp;
  struct RexxMsg *rm, *rm2;
  int ret = FALSE;
  int pend;
  int base_open;
  char *portname, *extension;
  
  portname  = PORTNAME;
  extension = RXEXTENS;

  base_open = (RexxSysBase != NULL);

  if ((!base_open) &&
      (RexxSysBase = (struct RxsLib *)OpenLibrary(RXSNAME, 0 /*RXSVERS*/)) == NULL) {
    Fatal(10, MSG_CANT_OPEN, RXSNAME);
  }
  else {
    Forbid();
    if (FindPort(portname) == NULL) {
      mp = CreatePort(portname, 0);
      Permit();
      if (mp != NULL) {
        if ((arg = CreateArgstring(str, strlen(str))) != NULL) {
          if (PutRexxMsg(mp, RXCOMM | RXFF_STRING, arg, NULL, extension)) {

            for (pend = 1; pend != 0; ) {
              if (WaitPort(mp) != NULL) {
                while ((rm = (struct RexxMsg *)GetMsg(mp)) != NULL) {
                  if (rm->rm_Node.mn_Node.ln_Type == NT_REPLYMSG) {
                    ret = TRUE;
                    *result = rm->rm_Result1;
                    if ((rm2 = (struct RexxMsg *)rm->rm_Args[1]) != NULL) {
                      rm2->rm_Result1 = rm->rm_Result1;
                      rm2->rm_Result2 = 0;
                      ReplyMsg((struct Message *)rm2);
                    }
                    DeleteRexxMsg(rm);
                    pend--;
                  }
                  else {
                    rm->rm_Result2 = 0;
                    if (PutRexxMsg(mp, rm->rm_Action, rm->rm_Args[0], rm, extension)) {
                      pend++;
                    }
                    else {
                      rm->rm_Result1 = RC_FATAL;
                      ReplyMsg((struct Message *)rm);
                    }
                  }
                }
              }
            }		/* for */
          }
          DeleteArgstring(arg);
        }
        DeletePort(mp);
      }
    }			/* Find port */
    else {
      Permit();
    }
    if (!base_open) {
      CloseLibrary((struct Library *)RexxSysBase);
    }
  }
  return ret;
}

#endif /* AMIGA */
