/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from util/bitmap.c
*/
/** bitmap.c **/

#include "defines.h"
#include <stdio.h>

#include "globals.h"

#define NEW_SAVE_IFF_METHOD 1

#ifdef ANSI
#  include <stdlib.h>
#  include <string.h>
#  include <stddef.h>
#endif

#include "bitmap.h"

#include "globals.i"

#ifdef ATARI
#  include "dvihand.i"
#  include "atscreen.i"
#endif

#ifdef DISPLAY
#  ifdef AMIGA
#    include "amscreen.i"
#  endif
#  include "sbitmap.i"
#else
#  include "prhelp.h"
#  ifdef AMIGA
#    include <clib/exec_protos.h>
#    include <pragmas/exec_pragmas.h>
#    include <graphics/gfx.h>
#    include <graphics/view.h>
#    if !defined(NEW_SAVE_IFF_METHOD)
#     include "iff.h"
#    endif
#    include "amprint.i"
#  endif
#  include "newhard.i"
#  include "bitmap.i"
#  include "prhelp.i"
#endif

#define MAX(a,b)	(((a) > (b)) ? (a) : (b))
#define MIN(a,b)	(((a) < (b)) ? (a) : (b))



/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"




struct bitmap map;
int PassNo;
long upper_limit;
long lower_limit;
int word_width;
int Pass;		// gibt es in dviprint.c noch *lokal*. Global wird es in special.c gebraucht.
long map_length;

#ifdef AMIGA
#  ifdef DISPLAY
#    define NO_GETMEM
#  endif
#endif

/** #if !defined(AMIGA) | !defined(DISPLAY) **/

#ifndef NO_GETMEM

static void GetMemory		Args((int max_length,
      	         		      int max_width,
        	       		      long **mem_begin,
               			      int *mem_length,
            			      int *divisor));


#ifndef DISPLAY
  extern short print_width;	/* => DOTS * PASSPERLINE		*/
  extern short full_page_in_ram;	/* must the whole page-bitmap into ram?	*/
  extern long landscape;		/* print in landscape modus?		*/
  extern long iffprint;		/* print to iff-file			*/

  extern long CurrentPage;	/* the current page number		*/

  /* wird fuer das IFF-Speichern benoetigt: */
  static UWORD           bw_ctable[2] = { 0x0FFF, 0x0000 };
# if defined(NEW_SAVE_IFF_METHOD)
#  include "iff/ilbmapp.h"
   static struct ILBMInfo ilbm;
# endif
#endif


static void GetMemory (int max_length, int max_width, long **mem_begin, 
			int *mem_length, int *divisor)
{
#ifndef DISPLAY
  int h;
  unsigned long mem;
#endif

  *divisor = 1;

  *mem_length = max_length;
  *mem_begin = NULL;

#ifndef DISPLAY
  if (
#    ifdef ATARI
      ((Printer->pp_flags & PF_PRINTER) != SLM804) &&
#    endif
      !full_page_in_ram) {

    mem = (unsigned long)(*mem_length) * (unsigned long)max_width;	/* memory in bytes */

    if (maxbitmapsize != 0L && mem > maxbitmapsize)
     {
      *divisor = (int)((int)(mem / (unsigned long)maxbitmapsize)+1);
     }

    while ( *mem_begin == NULL && *mem_length != print_width )
     {
      h =  (max_length / (*divisor)++);
      *mem_length =  h - (h % print_width) + print_width;
      *mem_length = MAX(print_width, *mem_length) ;

#endif /* !DISPLAY */

      /* hier kein xmalloc, da NULL als Ret. moeglich sein muss! */
      *mem_begin = (long *)malloc((size_t)((size_t)(*mem_length) * (size_t)max_width));

#ifndef DISPLAY
     }

    (*divisor)--;
  }
  else {
    /* hier kein xmalloc, da NULL als Ret. moeglich sein muss! */
    *mem_begin = (long *)malloc((size_t)((size_t)(*mem_length) * (size_t)max_width));
  }
#endif

  if (*mem_begin == NULL)
   {
#ifndef DISPLAY
    if (full_page_in_ram)
     {
      Warning(MSG_DVIP_WHOLE_BITMAP_IN_RAM);
     }
#endif
    Fatal(9, MSG_CANT_ALLOC_BITMAP);	/* special Returncode!!!! */
   }

#ifdef DEBUG
  if (DeBug) {
    WarningStr("Allocated %ld bytes for bitmap", (unsigned long)(*mem_length) * (unsigned long)max_width);
  }
#endif
}

#endif  /* (NO_GETMEM) !defined(AMIGA) | !defined(DISPLAY) */


void ClearBitmap(void)
{
#ifdef AMIGA
# ifdef DISPLAY
   clear_bild();
# else
   memset((char *)map.pixptr,(int)0,(unsigned)(map.height*(map.width>>3)));
# endif
#else
  clrbm ((void *)map.pixptr, (int)map.width, (int)map.height);
#endif
}




int InitBitmap(int pix_length, int pix_width)
{
  int map_width;
  long *bitmap_ptr;
  int bitmap_length;
#ifdef ATARI
# ifdef DISPLAY
   int flag = 0;
# endif
#endif
#ifdef AMIGA
# ifdef DISPLAY
   AddXpixel = 0;	/* das wird sonst erst nach dem ersten Gebrauch von SAVETY_BITS_X gesetzt! */
# endif
#endif

  /* SAVETY_BITS: Sicherheitsrand gegen "Overfull hbox" */

  // Das ist etwas hacky, da SAVETY_BITS_X als (hconvresolution+AddXpixel) definiert ist!
  // Daher muss AddXpixel vorher unbedingt auf 0 gesetzt werden.
  // Danach entspricht SAVETY_BITS_X dem Sicherheitsabstand plus dem Rundungsfaktor!!

  word_width = (pix_width+SAVETY_BITS_X+31) / 32;		/* (hes) */
  pix_length += SAVETY_BITS_Y; 
  
#ifdef DISPLAY
  AddXpixel = word_width*32 - pix_width - SAVETY_BITS_X;
  /* wieviele Pixel kommen auf Alignment-Gruende hinzu... */
#endif

  map_width =  word_width * bytesperlong;
#ifdef ATARI
# ifdef DISPLAY
   if (map.pixptr != NULL) 
    {                    /* we are changing the dvi file */
     xfree(map.pixptr);
     flag = 1;
    }
# endif
   GetMemory (pix_length, map_width, &bitmap_ptr, &bitmap_length, &PassNo);
#endif		/* ATARI */
#ifdef AMIGA
# ifdef DISPLAY
   bitmap_ptr = Init_all (pix_length, map_width);
   bitmap_length = pix_length;
   PassNo = 1;
# else
   if (map.pixptr != NULL) 
    {                    /* we are changing the dvi file */
     xfree(map.pixptr);
     map.pixptr = NULL;
    }
   GetMemory (pix_length, map_width, &bitmap_ptr, &bitmap_length, &PassNo);
# endif
#endif

  map.pixptr = bitmap_ptr;
  map.width = map_width * 8;
  map.height = bitmap_length;

#ifdef ATARI
# ifdef DISPLAY
   if (flag != 1)
    {
     Init_all(&map);
    }
   else
    {
     Init_some(&map);
    }
# else
   Init_all(&map);
# endif
#endif

  upper_limit = 0L;
  lower_limit = (long) bitmap_length;
  ClearBitmap();
  Pass=1;
  map_length = (long)pix_length;

#ifdef DEBUG

  if (DeBug)
   {
    Warning("Passes: %d, Mem-Length: %d, Mem-Width: %d (in Bytes)",
            PassNo, bitmap_length, map_width);
   }

#endif

#ifndef DISPLAY
  if (Stats) {
    Logging(MSG_DVIP_PARTS,PassNo);
  }
#endif

  return(PassNo);
}

#ifdef ATARI

static int imgversion;
static int headlength;
static int nrplanes;
static int patlen;
static int pixelwidth;
static int pixelheight;
static int scpixwidth;
static int sclinenr;
static int scbytewidth;

static char *muster = NULL;

void ReadHeader(FILE *fp)
{
 int i;
 
 imgversion  = (int)NoSignExtend(fp, 2);
 headlength  = (int)NoSignExtend(fp, 2);
 nrplanes    = (int)NoSignExtend(fp, 2);
 patlen      = (int)NoSignExtend(fp, 2);
 pixelwidth  = (int)NoSignExtend(fp, 2);
 pixelheight = (int)NoSignExtend(fp, 2);
 scpixwidth  = (int)NoSignExtend(fp, 2);
 sclinenr    = (int)NoSignExtend(fp, 2);
 
 if (headlength >8)
  {
   Warning("Headlength (%d) too long",headlength);
   for (i=8; i<= headlength; i++)
    {
     fgetc(fp);
    }
  }
 scbytewidth = (scpixwidth+7)/8;
 if (muster != NULL)
  { 
   xfree(muster);
  }
 muster = (char *)xmalloc((size_t) (patlen+2));
 if (muster == NULL)
  {
   Fatal(10, "Not enough memory for pattern");
  }
}

#ifdef DEBUG
void PrintHeader(void)
{
 Warning("imgversion: %d",imgversion);
 Warning("headlength: %d",headlength);
 Warning("nrplanes: %d",nrplanes);
 Warning("patlen: %d",patlen);
 Warning("pixelwidth: %d",pixelwidth);
 Warning("pixelheight: %d",pixelheight);
 Warning("scpixwidth: %d",scpixwidth);
 Warning("sclinenr: %d",sclinenr);
 Warning("scbytewidth: %d",scbytewidth);
}
#endif

static int xmin, ymin;
static int xmax, ymax;
static char *imgptr;
static int bmwidth;

void PutByte(int px, int py, char cont)
{
 if ((px < xmax) && (py <= ymax))
  {
   *(imgptr+((long)bmwidth*((long)py)+(long)px)) = cont;
  }
}

char GetByte(int gx, int gy)
{
 if ((gx < xmax) && (gy <= ymax))
  { 
   return(*(imgptr+((long)bmwidth*((long)gy)+(long)gx)));
  }
 else
  {
   return(0);
  }
}

void readimg(FILE *imgfile)
{
 int value;
 int bytes;
 int nrlines;
 int rx, ry;
 int i, k;

 rx = xmin;
 ry = ymin;
 bytes = 0;
 nrlines=0;

 while ((ry <= sclinenr+ymin) && (ry<=ymax))
  {
   if (bytes >= scbytewidth)
    {
     ry++;
     rx = xmin;
     bytes = 0;
     if (nrlines>0)
      {
       for (i=1; i<= scbytewidth; i++)
        {
         PutByte(rx,ry, GetByte( rx, ry-1));
         rx++;
         bytes++;
        }
       nrlines--;
       continue;
      }
    }
         
   value = (int)NoSignExtend(imgfile, 1);
   switch (value)
    {
     case 0x00:
      value = (int)NoSignExtend(imgfile, 1);
      switch (value)
       {
        case 0x00:
         if ((int)NoSignExtend(imgfile, 1) == 0xff)
          {
           nrlines = NoSignExtend(imgfile, 1)-1;
          }
         rx = xmin;
         bytes = 0;
         break;
        default:
         bytes += value*patlen;
         for (i=1; i<=patlen; i++)
          {
           *(muster+i) = (char)NoSignExtend(imgfile,1);
          }
         for (k=1; k<= value; k++)
          {
           for (i=1; i<= patlen; i++)
            {
             PutByte(rx,ry, *(muster+i));
             rx++;
            }
          }
         break;
       }
      break;
     case 0x80:
      value = (int)NoSignExtend(imgfile, 1);
      bytes += value;
      for (i=1; i<= value; i++)
       {
        PutByte(rx,ry,(char)NoSignExtend(imgfile,1));
        rx++;
       }
      break;
     default:
      if (value & 128)
       {
        value -= 128;
        for (i=1; i<=value; i++)
         {
          PutByte(rx,ry, 255);
          rx++;
         }
        bytes += value;
       }
      else
       {
        for (i=1; i<=value; i++)
         {
          PutByte(rx,ry,0);
          rx++;
         }
         bytes += value;
       }
      break;
    }      
  }
} 
   
void PaintImage(char *pfilename, long xakt, long yakt, int maxwidth, int maxheight)
{
 FILE *imgfile;
 int i;
 char *pfn;

 pfn = pfilename;
 if (pfn != NULL)
  {
   while (*pfn)
    {
     switch (*pfn)
      {
       case '/':
        *pfn = '\\';
        break;
       case ';':
        *pfn = ':';
        break;
      }
     pfn++;
    }
  }
 Warning( "IMG filename: %s",pfilename);
 imgfile = fopen(pfilename,"rb");
 if (imgfile == NULL)
  {
   Warning( "Can't open IMG file");
   return;
  }
 ReadHeader(imgfile);
 imgptr = (char *)map.pixptr;
 bmwidth = ((int)map.width)/8;
 xmin = (MIN((int)xakt, (int)map.width))/8;
 if (maxwidth !=0)
  {
   xmax = MIN((xmin + maxwidth), ((int)map.width/8));
  }
 else
  {
   xmax = ((int)map.width)/8;
  }
 ymin = MIN((int)yakt, (int)map.height);
 if (maxheight !=0)
  {
   ymax = MIN((ymin + maxheight), (int)map.height);
  }
 else
  {
   ymax = (int)map.height;
  }

#ifdef DEBUG
 if (DeBug)
  {
   PrintHeader();

   Warning( "xmax: %d ymax: %d",xmax, ymax);
   Warning( "xmin: %d ymin: %d",xmin, ymin);
   Warning( "bmwidth: %d map.width: %ld",bmwidth,map.width);
   Warning( "map.pixptr: %ld map.height: %ld",map.pixptr, map.height);
   Warning( "imgptr: %ld",imgptr);
  }
#endif

 readimg(imgfile);
 if (muster != NULL)
  { 
   xfree(muster);
  }
 fclose(imgfile);
}
#endif

#ifdef SLOW
void CopyBitArray (long x, long y, int w, int h, unsigned short *p)
                       /* x,y upper left corner (pixels)           */
                       /* w,h height / width of character (pixels) */
                       /* p   pointer to bitmap */
{ 
#ifndef ATARI
  int words, sf, of, cmin, cmax, lmin, lmax;
  register int c;
  register int l;
  register long mask;
  register unsigned long item;
  long *addr, *itaddr;
#endif

#ifdef DEBUG
/*
  if (DeBug) 
   {
    Message ("CopyBitArray(%ld,%ld,%d,%d,%lX)",x,y,w,h,p);
    Message ("upper limit = %ld, lower limit = %ld",
             upper_limit, lower_limit);
   }
*/
#endif

  x += hoffset;
  y += voffset;

/*
  if (x+(long)w < 0L || x > map.width) 
*/

#if 0
  if (x < 0L || x+(long)w > map.width) 
   {
    return;
   }
#endif
  if (y >= lower_limit || y+(long)h < upper_limit) 
   {
    return;
   }

#ifdef ATARI

  AtCopyBitArray(x,y-upper_limit,w,h,p);

#else

  words = (w + bitsperlong - 1) / bitsperlong;
  sf = x % bitsperlong;
  of = x / bitsperlong;
  lmin = 0; lmax = h;
  cmin = 0; cmax = words;

  if (y - upper_limit < 0) 
   {
    lmin = upper_limit - y;
   }

  if (y+h >= lower_limit)
   {
    lmax = lower_limit - y;
   }

  for (l=lmin; l<lmax; l++)
   {
    addr = map.pixptr + (y - upper_limit + l) * word_width + of;
    itaddr = p + l * words;
    mask = 0;
    for (c=cmin; c<cmax; c++)
     {
      if (p == NULL)
       {
        item = -1;
        if (c == words-1 && w % bitsperlong)
         {
          item <<= (bitsperlong - w % bitsperlong);
         }
       }
      else
       {
        item = *(itaddr + c);
       }
      mask |= item >> sf;
      *(addr + c) |= mask;
      mask = item << (bitsperlong - sf);
     }
    *(addr + c) |= mask;
   }
#endif
}
#endif

#ifndef DISPLAY
int PrintPage(void)
{
 if (iffprint) {
   char *ptr;
   int clip = FALSE;
   struct BitMap bmap;
   char iffname[PATHLEN];

   if (output_file_name) { /* use the output_file_name as destination */
#if defined(NEW_SAVE_IFF_METHOD)
     clip = *output_file_name == 'C' && output_file_name[1] == 'L' 
		&& output_file_name[2] == 'I' && output_file_name[3] == 'P';
#endif
     if (clip) {
       strcpy(iffname, output_file_name);
     }
     else {
       strcpy(iffname, output_file_name);
       ptr = &iffname[strlen(iffname)];		/* append extension */
     }
   }
   else {
     strcpy(iffname, filename);
     ptr = strrchr(iffname, '.');	/* we know there's the .dvi */
   }

   if (!clip) sprintf(ptr,".p%d", CurrentPage);

   bmap.BytesPerRow = map.width / 8;
   bmap.Rows        = map.height;
   bmap.Flags       = 0;
   bmap.Depth       = 1;
   bmap.Planes[0]   = (PLANEPTR)map.pixptr;

   if (clip) {
     Message(MSG_DVIP_SAVE_CLIP, CurrentPage, filename, iffname);
   }
   else {
     Message(MSG_DVIP_SAVE_IFF, CurrentPage, filename, iffname);
   }

#if !defined(NEW_SAVE_IFF_METHOD)
   //if (IFFBase == NULL) FatalStr(20, "internal error: IFFBase == NULL!?!");

   if (!SaveBitMap(iffname,&bmap,&(bw_ctable[0]),1L)) {
     WarningStr( "Can't write page to iff-file \"%s\"!", iffname);
   }
#else

   /*
    * Nun neue IFF-Save Methode die ohne die iff.library auskommt.
    */
   memset(&ilbm, 0, sizeof(ilbm));
   ilbm.ParseInfo.iff = AllocIFF();
   if (!ilbm.ParseInfo.iff) {
     Fatal(10, MSG_NO_MEM);
   }
   if (saveilbm(&ilbm, &bmap, DEFAULT_MONITOR_ID|HIRESLACE_KEY, 
		map.width, map.height, map.width, map.height,
		bw_ctable, 2, 4, 0, 0, NULL, NULL, iffname)) {
     Warning( MSG_DVIP_CANT_SAVE_IFF, iffname);
   }
   FreeIFF(ilbm.ParseInfo.iff);
#endif
   ClearBitmap();
   return 1;
 }
 else {
   if (Pass==PassNo) {

     // Drucke Pass Nr. 'Pass'

     Hardcopy(&map, (long)(map_length-upper_limit), (Pass == 1), TRUE);		/* last pass */

     if (Printer->pp_special & SPECIAL_PREFS) {
       WaitForPrinterOK();	/* warte bis der Streifen fertig gedruckt ist     */
			        /* definiert in amprint.c, wartet auch auf CTRL-C */
     }

     ClearBitmap();

     Pass=1;
     upper_limit=0L;
     lower_limit=map.height;
     return(1);
   }
   else {

     // Drucke Pass Nr. 'Pass'

     Hardcopy(&map, map.height, (Pass == 1), FALSE);		/* FALSE : not last pass */

     if (Printer->pp_special & SPECIAL_PREFS) {
       WaitForPrinterOK();	/* warte bis der Streifen fertig gedruckt ist     */
			        /* definiert in amprint.c, wartet auch auf CTRL-C */
     }

     ClearBitmap();
     Pass++;
     upper_limit += (map.height);
     lower_limit += (map.height);
     return(0);
    }
  }
}
#endif

