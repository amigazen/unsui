/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from unpack.c
*/
/*
 *   Unpacks the raster data from the packed buffer.  This code was 
 *   translated from pktopx.web using an automatic translator, then
 *   converted for this purpose.  This little routine can be very useful
 *   in other drivers as well.
 */

#include "defines.h"

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>

#include "globals.h"
#include "textypes.h"
#include "flmt.h"
#include "new_font.h"

#include "globals.i"
#include "unpack.i"


/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



/*
 * external procedures
 */
/* ?? */

extern struct FontMan	*FontRoot;	/* root structure	*/


/*
 * internal procedures
 */
static shalfword getnyb		(void);
static Boolean   getbit		(void);
static long      pkpackednum	(void);
#if 0
static void      flip		(char *s, long howmany);
#endif
static long	 getlong	(unsigned char *a);
static void	 unpack		(quarterword *pack, halfword *raster,
				 halfword cwidth, halfword cheight,
				 halfword cmd);


/*
 *   Some statics for use here.
 */
static halfword bitweight ; 
static halfword dynf ;
static halfword gpower[17] = { 0 , 1 , 3 , 7 , 15 , 31 , 63 , 127 ,
     255 , 511 , 1023 , 2047 , 4095 , 8191 , 16383 , (halfword)32767 , (halfword)65535 } ; 
static long repeatcount ;
static quarterword *p ;

#if 0
static halfword bftest = 1 ;
#endif


/*
 *   We need procedures to get a nybble, bit, and packed word from the
 *   packed data structure.
 */

static shalfword __inline getnyb (void)
{
    if ( bitweight == 0 ) 
    { bitweight = 16 ; 
      return (shalfword)(*p++ & 15) ;
    } else {
      bitweight = 0 ;
      return (shalfword)(*p >> 4) ;
    }
} 

static Boolean __inline getbit (void)
{
    bitweight >>= 1 ; 
    if ( bitweight == 0 ) 
    { p++ ;
      bitweight = 128 ;
    } 
    return (Boolean)(*p & bitweight) ;
} 

static long pkpackednum (void)
{
    register halfword i;
    register long j ; 
    i = getnyb () ; 
    if ( i == 0 ) {
       do { j = (long)getnyb () ; 
          i++ ; 
          } while ( j == 0L ) ; 
       while ( i != 0 ) {
          j = j * 16L + ((long) getnyb ()) ; 
          i-- ; 
          } 
       return ( j - 15L + ( 13L - dynf ) * 16L + dynf ) ; 
    }
    else if ( i <= dynf ) return ( (long)i ) ; 
    else if ( i < 14 ) return ( ( (long)i - (long)dynf - 1L )*16L + (long)getnyb() + (long)dynf + 1L ) ; 
    else {
       if (repeatcount != 0)
          Fatal(10,MSG_UNPACK_RECURSIV);
       repeatcount = 1L ;
       if ( i == 14 ) repeatcount = pkpackednum () ; 
       return ( pkpackednum() ) ;
    } 
} 

#if 0
static void flip(char *s, long howmany)
{
   register char t ;

   while (howmany > 0) {
      t = *s ;
      *s = s[1] ;
      s[1] = t ;
      howmany-- ;
      s += 2 ;
   }
}
#endif


/*
 *   And now we have our main routine.
 */

static void unpack(quarterword *pack, halfword *raster,
			halfword cwidth, halfword cheight, halfword cmd)
{ 
  register integer i, j ; 
  shalfword wordwidth ; 
  register halfword word, wordweight ;
  shalfword rowsleft ; 
  Boolean turnon ; 
  shalfword hbit ; 
  long count ; 

#if 0
  halfword *oraster ;
  oraster = raster ;
#endif

  p = pack ;
  dynf = cmd / 16 ; 
  turnon = cmd & 8 ; 
  wordwidth = (cwidth + 15)/16 ;
  if ( dynf == 14 ) 
  { bitweight = 256 ; 
    for ( i = 1 ; i <= cheight ; i ++ ) 
      { word = 0 ; 
        wordweight = (halfword)32768 ; 
        for ( j = 1 ; j <= cwidth ; j ++ ) 
          { if ( getbit () ) word += wordweight ; 
            wordweight >>= 1 ;
            if ( wordweight == 0 ) 
            { *raster++ = word ; 
              word = 0 ;
              wordweight = (halfword)32768 ; 
              } 
            } 
          if ( wordweight != (halfword)32768 ) 
             *raster++ = word ; 
        } 
  } else {
    rowsleft = cheight ; 
    hbit = cwidth ; 
    repeatcount = 0 ; 
    wordweight = 16 ; 
    word = 0 ; 
    bitweight = 16 ;
    while ( rowsleft > 0 ) 
      { count = pkpackednum() ; 
        while ( count != 0 ) 
          { if ( ( count <= wordweight ) && ( count < hbit ) ) 
            { if ( turnon ) word += gpower [ wordweight ] - gpower 
              [ wordweight - count ] ; 
              hbit -= count ; 
              wordweight -= count ; 
              count = 0 ; 
              } 
            else if ( ( count >= hbit ) && ( hbit <= wordweight ) ) 
            { if ( turnon )
                 word += gpower[wordweight] - gpower[wordweight-hbit] ; 
              *raster++ = word ; 
              for ( i = 1 ; i <= repeatcount ; i ++ ) {
                for ( j = 1 ; j <= wordwidth ; j ++ ) {
                  *raster = *(raster - wordwidth) ;
                  raster++ ;
                }
              }
              rowsleft -= repeatcount + 1 ; 
              repeatcount = 0 ; 
              word = 0 ; 
              wordweight = 16 ; 
              count -= hbit ; 
              hbit = cwidth ; 
              } 
            else 
            { if ( turnon ) word += gpower [ wordweight ] ; 
              *raster++ = word ;
              word = 0 ; 
              count -= wordweight ; 
              hbit -= wordweight ; 
              wordweight = 16 ; 
              } 
            } 
          turnon = ! turnon ; 
        } 
      if ( ( rowsleft != 0 ) || ( hbit != cwidth ) ) 
	Fatal(10,MSG_UNPACK_MORE_BITS);
    } 
#if 0
    if (*(char *)&bftest) /* is the hardware LittleEndian? */
       flip((char *)oraster, ((cwidth + 15) >> 4) * (long)cheight) ;
#endif
   /** return(p-pack) ;  **/
}


static long getlong(quarterword *a)
{
  return ((((((a[0] << 8L) + a[1]) << 8L) + a[2]) << 8L) + a[3]) ;
}


/*
 *  unpack one character
 */
void unpack_char(struct Font *fnt, short cc)
{
   long i;
   halfword cheight, cwidth ;
   quarterword *p ;
   halfword cmd ;
   shalfword xoff, yoff ;
   halfword wwidth;
   struct Char *unpacked_char;
   halfword *bitmap;

   if (fnt->common->fnt_status != FNT_LOADED && 
       fnt->common->fnt_status != FNT_DEFINED_OLOADED &&
       fnt->common->fnt_status != FNT_OLD_LOADED) {
     return;	/* do nothing 	(should never occure) */
     /* der Fall tritt zur Zeit nicht auf, waere aber zu ueberlegen, ob man	*/
     /* nicht zulassen koennte, einen Font zu verwenden, dessen pk-data nicht	*/
     /*	geladen (weil removed) ist. Man muesste den Font nur dann laden, wenn	*/
     /*	ein Char gebraucht wird, der noch nicht ausgepackt ist!			*/
   }

   p = (quarterword *)(fnt->common->ch_start_bm + fnt->common->ch[cc].packed_data);

   cmd = *p++ ;
   if (cmd & 4) {
      if ((cmd & 7) == 7) {
         cwidth = getlong(p) ;
         cheight = getlong(p + 4) ;
         xoff = getlong(p + 8) ;
         yoff = getlong(p + 12) ;
         p += 16 ;
      } else {
         cwidth = p[0] * 256 + p[1] ;
         cheight = p[2] * 256 + p[3] ;
         xoff = p[4] * 256 + p[5] ; /* N.B.: xoff, yoff are signed halfwords */
         yoff = p[6] * 256 + p[7] ;
         p += 8 ;
      }
   } else {
      cwidth = *p++ ;
      cheight = *p++ ;
      xoff = *p++ ;
      yoff = *p++ ;
      if (xoff > 127)
         xoff -= 256 ;
      if (yoff > 127)
         yoff -= 256 ;
   }

   wwidth = (cwidth + 15) / 16 ;
   i = 2L * (long)cheight * (long)wwidth ;
   if (i <= 0) i = 2;

   unpacked_char = xmalloc(i + sizeof(struct Char)) ;
   bitmap = (halfword *)(unpacked_char + 1);	/* bitmap at the end of the structure */

   memset(bitmap, 0, i);	/* clear the buffer */
   unpack(p, (halfword *)bitmap, cwidth, cheight, cmd) ;

/*
   unpacked_char->bytes = i + sizeof(struct Char);
   FontRoot->unpacked_mem += unpacked_char->bytes;
*/
   FontRoot->unpacked_mem += i + sizeof(struct Char);

   if (cheight == 0 || cwidth == 0) {		/* noetig ?? */
      cwidth  = 1 ;
      cheight = 1 ;
      bitmap[0] = 0;
   }

   unpacked_char->width   = cwidth;
   unpacked_char->height  = cheight;
   unpacked_char->xOffset = xoff;
   unpacked_char->yOffset = yoff;

   fnt->common->ch[cc].unpacked = unpacked_char;
}
