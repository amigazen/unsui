% \iffalse meta-comment
%
% Copyright 1989-1995 Johannes L. Braams and any individual authors
% listed elsewhere in this file.  All rights reserved.
% 
% For further copyright information any other copyright notices in this
% file.
% 
% This file is part of the Babel system release 3.5.
% --------------------------------------------------
%   This system is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
% 
%   For error reports concerning UNCHANGED versions of this file no more
%   than one year old, see bugs.txt.
% 
%   Please do not request updates from me directly.  Primary
%   distribution is through the CTAN archives.
% 
% 
% IMPORTANT COPYRIGHT NOTICE:
% 
% You are NOT ALLOWED to distribute this file alone.
% 
% You are allowed to distribute this file under the condition that it is
% distributed together with all the files listed in manifest.txt.
% 
% If you receive only some of these files from someone, complain!
% 
% Permission is granted to copy this file to another file with a clearly
% different name and to customize the declarations in that copy to serve
% the needs of your installation, provided that you comply with
% the conditions in the file legal.txt from the LaTeX2e distribution.
% 
% However, NO PERMISSION is granted to produce or to distribute a
% modified version of this file under its original name.
%  
% You are NOT ALLOWED to change this file.
% 
% 
% \fi
% \CheckSum{2575}
%%%\iffalse
%%%  @LaTeX-file{
%%%     author          = "Johannes L. Braams",
%%%     version         = "3.5c",
%%%     date            = "21 june 1995",
%%%     time            = "23:55:00 MET",
%%%     filename        = "babel.dtx",
%%%     address         = "Kooienswater 62
%%%                        The Netherlands",
%%%     telephone       = "(70) 3432037",
%%%     FAX             = "(70) 3432395",
%%%     checksum        = "54332 2092 9869 81235",
%%%     email           = "JLBraams@cistron.nl (Internet)",
%%%     codetable       = "ISO/ASCII",
%%%     keywords        = "babel",
%%%     supported       = "yes",
%%%     docstring       = "This file, babel.dtx contains the core of
%%%                        the babel system as it was described in
%%%                        TuGboat Volume 12 no 2 and Volume 14 no 1.
%%%
%%%                        The checksum field above contains a CRC-16
%%%                        checksum as the first value, followed by the
%%%                        equivalent of the standard UNIX wc (word
%%%                        count) utility output of lines, words, and
%%%                        characters.  This is produced by Robert
%%%                        Solovay's checksum utility.",
%%%      }
%%% \fi
%%
% \def\filename{babel.dtx}
% \let\thisfilename\filename
%
%\iffalse
%<*dtx>
\ProvidesFile{babel.dtx}
%</dtx>
%
% Babel DOCUMENT-STYLE option for LaTeX version 2.09 or plain TeX;
% Babel package for LaTeX2e.
%
%% Copyright (C) 1989 -- 1995 by Johannes Braams,
%%                            TeXniek
%%                            all rights reserved.
%
%% Please report errors to: J.L. Braams
%%                          JLBraams@cistron.nl
%<*filedriver>
\documentclass{ltxdoc}
\font\manual=logo10 % font used for the METAFONT logo, etc.
\newcommand*\MF{{\manual META}\-{\manual FONT}}
\newcommand*\TeXhax{\TeX hax}
\newcommand*\babel{\textsf{babel}}
\newcommand*\m[1]{\mbox{$\langle$\it#1\/$\rangle$}}
\newcommand*\langvar{\m{lang}}
\newcommand*\note[1]{}
\newcommand*\bsl{\protect\bslash}
\newcommand*\Lopt[1]{\textsf{#1}}
\newcommand*\file[1]{\texttt{#1}}
\newcommand*\pkg[1]{\texttt{#1}}
\begin{document}
 \DocInput{babel.dtx}
\end{document}
%</filedriver>
%\fi
%
% \GetFileInfo{babel.dtx}
%
% \changes{babel~2.0a}{1990/04/02}{Added text about \file{german.sty}}
% \changes{babel~2.0b}{1990/04/18}{Changed order of code to prevent
%    plain \TeX from seeing all of it}
% \changes{babel~2.1}{1990/04/24}{Modified user interface,
%    \cs{langTeX} no longer necessary}
% \changes{babel~2.1a}{1990/05/01}{Incorporated Nico's comments}
% \changes{babel~2.1b}{1990/05/01}{rename \cs{language} to
%    \cs{current@language}}
% \changes{babel~2.1c}{1990/05/22}{abstract for report fixed, missing
%    \texttt{\}}, found by Nicolas Brouard BROUARD@FRINED51.BITNET}
% \changes{babel~2.1d}{1990/07/04}{Missing right brace in definition of
%    abstract environment, found by Werenfried Spit}
% \changes{babel~2.1e}{1990/07/16}{Incorporated more comments from
%    Nico}
% \changes{babel~2.2}{1990/07/17}{Renamed \cs{newlanguage} to
%    \cs{addlanguage}}
% \changes{babel~2.2a}{1990/08/27}{Modified the documentation
%    somewhat}
% \changes{babel~3.0}{1991/04/23}{Moved part of the code to hyphen.doc
%    in preparation for \TeX~3.0}
% \changes{babel~3.0a}{1991/05/21}{Updated comments in various places}
% \changes{babel~3.0b}{1991/05/25}{Removed some problems in change log}
% \changes{babel~3.0c}{1991/07/15}{Renamed \file{babel.sty} and
%    \file{latexhax.sty} to \file{.com}}
% \changes{babel~3.1}{1991/10/31}{Added the support for active
%    characters and for extending a macro}
% \changes{babel~3.1}{1991/11/05}{Removed the need for
%    \file{latexhax}}
% \changes{babel~3.2}{1991/11/10}{Some Changes by br}
% \changes{babel~3.2a}{1992/02/15}{Fixups of the code and
%    documentation}
% \changes{babel~3.3}{1993/07/06}{Included driver file, and prepared
%    for dsitribution}
% \changes{babel~3.4}{1994/01/30}{Updated for \LaTeXe}
% \changes{babel~3.4}{1994/02/28}{Added language definition file for
%    bahasa}
% \changes{babel~3.4b}{1994/05/18}{Added a small driver to be able to
%    process just this file}
% \changes{babel~3.5a}{1995/02/03}{Provided common code to handle the
%    active double quote}
% \changes{babel~3.5c}{1995/06/14}{corrected a few typos (PR1652)}
% \changes{babel~3.5d}{1995/07/02}{Merged glyphs.dtx into this file}
%
% \title {Babel, a multilingual package for use with \LaTeX's standard
%    document classes\thanks{During the development ideas from Nico
%    Poppelier, Piet van Oostrum and many others have been used.
%    Bernd Raichle has provided many helpful suggestions.}}
%
% \author{Johannes Braams\\
%         Kooienswater 62\\
%         2715 AJ Zoetermeer\\
%         The Netherlands\\
%         \texttt{J.L.Braams@cistron.nl}}
%
% \date{Printed \today}
%
% \maketitle
%
%  \begin{abstract}
%    The standard distribution of \LaTeX\ contains a number of
%    document classes that are meant to be used, but also serve as
%    examples for other users to create their own document classes.
%    These document classes have become very popular among \LaTeX\
%    users. But it should be kept in mind that they were designed for
%    American tastes and typography. At one time they contained a
%    number of hard-wired texts. This report describes \babel{}, a
%    package that makes use of the new capabilities of \TeX\ version 3
%    to provide an environment in which multilingual documents can be
%    written.
%  \end{abstract}
%
%  \begin{multicols}{2}
%    \tableofcontents
%  \end{multicols}
%
% \section{The user interface}\label{U-I}
%
%    The user interface of this package is quite simple. It basially
%    consists of only two commands. These commands can be used to
%    select another language or to find out what the current language
%    is.
%
% \DescribeEnv{language}
%    The environment \textsf{language} does basically the same as
%    |\selectlanguage|, except the language change is local to the
%    environment. For mixing left-to-right typesetting with
%    right-to-left typesetting the use of this environment is a
%    prerequisite.
%
% \DescribeMacro\foreignlanguage
%    The command |\foreignlanguage| takes two arguments, the second
%    argument is a phrase to be typeset according to the rules of the
%    language named in its first argument.
%
% \DescribeMacro\selectlanguage
%    When a user wants to switch from one language to another he can
%    do so using the macro |\selectlanguage|. This macro takes the
%    language, defined previously by a language definition file, as
%    its argument. It calls several macros that should be defined in
%    the language definition files to activate the special definitions
%    for the language chosen.
% 
% \DescribeMacro\languagename
%    The name of the current language is stored in the control
%    sequence |\languagename|.
%
% \DescribeMacro\iflanguage
%    If more than one language is used it might be necessary to know
%    which language is active at a specific time. This can be checked
%    by a call to |\iflanguage|. This macro takes three arguments.
%    The first argument is the name of a language, the second and
%    third arguments are the actions to take if the result of the test
%    is \texttt{true} or \texttt{false} respectively.
%
% \DescribeMacro\useshorthands
%     A command with one argument, the character to make active in
%     order to define personal shorthands.
%
% \DescribeMacro\defineshorthand
%     The command |\defineshorthand| takes two arguments, the first of
%     which is a one or two character sequence, the second argument is
%     the code the shorthand should expand to.
%
% \DescribeMacro\languageshorthands
%     The command |\languageshorthands| can be used to switch the
%     shorthands on the language level. It takes one argument, the
%     name of a language. Note that for this to work the language
%     should have been specified as an option when loading the \babel\
%     package. 
%
% \section{Changes for \LaTeXe}
%
%    With the advent of \LaTeXe\ the interface to \babel\ in the
%    preamble of the doument has changed. With \LaTeX2.09 one used to
%    call up the \babel\ system with a line such as:
%
%\begin{verbatim}
%\documentstyle[dutch,english]{article}
%\end{verbatim}
%
%    which would tell \LaTeX\ that the document would be written in
%    two languages, dutch and english and that english would be the
%    first language in use.
%
%    The \LaTeX2e\ way of providing the same information is:
%
%\begin{verbatim}
%\documentclass{article}
%\usepackage[dutch,english]{babel}
%\end{verbatim}
%
%    or, making \Lopt{dutch} and \Lopt{english} global options in
%    order to let other packages detect and use them:
%
%\begin{verbatim}
%\documentclass[dutch,english]{article}
%\usepackage{babel}
%\usepackage{varioref}
%\end{verbatim}
%
%    In this last example the package \texttt{varioref} will also see
%    the options and will be able to use them.
%
% \section{Changes in Babel version 3.5}
%
%    In Babel version 3.5 a lot of changes have been made when
%    compared with the previous release. Here is a list of the most
%    important ones:
%    \begin{itemize}
%    \item \babel\ now has a \textsf{language} environment and a new
%      command |\foreignlanguage|;
%    \item the way active characters are dealt with is completely
%      changed. They are called `shorthands'; one can have three
%      levels of shorthands: on the user level, the language level and
%      on `system level'. A consequence of the new way of handling
%      active characters is that they are now written to auxiliary
%      files `verbatim';
%    \item A language change now also writes information in the
%      \file{.aux} file as the change might also affect typesetting
%      the table of contents. The consequence is that an .aux file
%      generated by a LaTeX format with babel preloaded gives errors
%      when read with a LaTeX format without babel, but I think this
%      problaly doesn't occur;
%    \item \babel\ is now compatible with the \pkg{inputenc} and
%      \pkg{fontenc} packages;
%    \item the language definition files now have a new extension,
%      \file{ldf};
%    \item the syntax of the file \file{language.dat} is extended to
%      be compatible with the \pkg{french} package by Bernard Gaulle;
%    \item each language definition file looks for a configuration
%      file which has the same name, but the extension \file{.cfg}.
%    \end{itemize}
%
% \section{The interface between the core of \babel{} and the language
%    definition files}
%
%    In the core of the \babel{} system two macros are defined that
%    are to be used in language definition files. Their purpose is to
%    make a new language known.
%
%  \DescribeMacro\addlanguage
%    The macro |\addlanguage| is a non-outer version of the macro
%    |\newlanguage|, defined in \file{plain.tex} version~3.x. For
%    older versions of \file{plain.tex} and \file{lplain.tex} a
%    substitute definition is used.
%
%  \DescribeMacro\adddialect 
%    The macro |\adddialect| can be used in the case where two
%    languages can (or have to) use the same hyphenation
%    patterns. This can be useful when a user wants to use a language
%    for which no patterns are preloaded in the format. In such a case
%    the default behaviour of the \babel{} system is to define this
%    language as a `dialect' of the language for which the patterns
%    were loaded as |\language0|.
%
%    The language definition files have to conform to a number of
%    conventions. The reason for this is that these files have to fill
%    in the gaps left by the common code in \file{babel.def}, i.\,e.,
%    the definitions of the macros that produce texts.  Also the
%    language-switching possibility which has been built into the
%    \babel{} system has its implications.
%
%    The following assumptions are made:
%   \begin{itemize}
%    \item Some of the language-specific definitions might be used by
%    plain \TeX\ users, so the files have to be coded such that they
%    can be read by \LaTeX\ as well as by plain \TeX. This can be
%    checked by looking at the value of the macro |\fmtname|.
%
%    \item The common part of the \babel{} system redefines a number
%    of macros and environments (defined previously in the document
%    style) to put in the names of macros that replace the previously
%    hard-wired texts.  These macros have to be defined in the
%    language definition files.
%
%    \item The language definition files define five macros, used to
%    activate and deactivate the language-specific definitions.  These
%    macros are |\|\langvar|hyphenmins|, |\captions|\langvar,
%    |\date|\langvar, |\extras|\langvar and |\noextras|\langvar. These
%    macros and their functions are discussed below.
%
%    \item When a language definition file is loaded, it can define
%    |\l@|\langvar to be a dialect of |\language0| when |\l@|\langvar
%    is undefined.
%
%    \item The languagedefinition files can be read in the preamble of
%    the document, but also in the middle of document processing. This
%    means that they have to function independently of the current
%    |\catcode| of the \texttt{@}~sign.
%   \end{itemize}
%
%
%  \DescribeMacro\langhyphenmin
%    The macro |\|\langvar|hyphenmins| is used to store the values of
%    the |\lefthyphenmin| and |\righthyphenmin|.
%
%  \DescribeMacro\captionslang
%    The macro |\captions|\langvar defines the macros that
%    hold the texts to replace the original hard-wired texts.
%
%  \DescribeMacro\datelang
%    The macro |\date|\langvar defines |\today| and
%
%  \DescribeMacro\extraslang
%    The macro |\extras|\langvar contains all the extra definitions
%    needed for a specific language.
%
%  \DescribeMacro\noextraslang
%    Because we want to offer the user the possibility to switch
%    between languages and we do not know in what state \TeX\ might be
%    after the execution of |\extras|\langvar, a macro that brings
%    \TeX\ into a predefined state is needed. It will be no surprise
%    that the name of this macro is |\noextras|\langvar.
%
%  \DescribeMacro\main@language
%    To postpone the activation of the definitions needed for a
%    language untill the beginning of a document, all language
%    definition files should use |\main@language| instead of
%    |\selectlanguage|. This will just store the name of the language
%    and the proper language will be activated at the start of the
%    document.
%
%  \DescribeMacro\loadlocalcfg
%    At the end of the processing of a language definition file
%    \LaTeX\ can be instructed to load a local configuration
%    file. This file can for instance be used to add strings to
%    |\captions|\langvar\ in order to support local document
%    classes. The user will be informed of the fact that this
%    configuration file is loaded.
%
% \subsection{Support for active characters}
%
%    In quite a few language definition files, active characters are
%    introduced. To facilitate this, some support macros are provided.
%
% \DescribeMacro{\initiate@active@char}
%    The internal macro |\initiate@active@char| is used in language
%    definition files to instruct \LaTeX\ to give a character the
%    category code `active'. When a character has been made active it
%    will remain that way untill the end of then document. Its
%    definition may vary.
%
% \DescribeMacro{\bbl@activate}
% \DescribeMacro{\bbl@deactivate}
%    The command |\bbl@activate| is used to change the way an active
%    character expands. |\bbl@activate| `switches on' the active
%    behaviour of the character. |\bbl@deactive| lets the active
%    character expand to its former (mostly) non-active self.
%
% \DescribeMacro{\declare@shorthand}
%    The macro |\declare@shorthand| is used to define the various
%    shorthands. It takes three arguments, the name for the collection
%    of shorthands this definition belongs to; the character
%    (sequence) that makes up the shorthand i.i.\ |~| or |"a| and the
%    code to be executed when the shorthand is encountered.
%
% \DescribeMacro{\bbl@add@special}
% \DescribeMacro{\bbl@remove@special}
%    ``Plain \TeX\ includes a macro called |\dospecials| that is
%    essentially a set macro, representing the set of all characters
%    that have a special category code.'' \cite[p.~380]{DEK} It is
%    used to set text `verbatim'.  To make this work if more
%    characters get a special category code, you have to add this
%    character to the macro |\dospecial|.  \LaTeX\ adds another macro
%    called |\@sanitize| representing the same character set, but
%    without the curly braces.  The macros
%    |\bbl@add@special|\meta{char} and
%    |\bbl@remove@special|\meta{char} add and remove the character 
%    \meta{char} to these two sets.
%
% \subsection{Support for saving macro definitions}
%
%    Language definition files may want to \emph{re}define macros that
%    already exist. Therefore a mechanism for saving (and restoring)
%    the original definition of those macros is provided. We provide
%    two macros for this\footnote{This mechanism was introduced by
%    Bernd Raichle.}.
%
% \DescribeMacro{\babel@save} To save the current meaning of any
%    control sequence the macro |\babel@save| is provided. It takes
%    one argument, \meta{csname}, the control sequence for which the
%    meaning has to be saved.
%
% \DescribeMacro{\babel@savevariable} A second macro is provided to
%    save the current value of a variable.  In this context anything
%    that is allowed after the |\the| primitive is considered to be a
%    variable. The macro takes one argument, the \meta{variable}.
%
%    The effect of the aforementioned macros is that a piece of code
%    is appended to the current definition of |\originalTeX|. When
%    |\originalTeX| is expanded this code restores the previous
%    definition of the control sequence or the previous value of the
%    variable.
%
% \subsection{Support for extending macros}
%
% \DescribeMacro{\addto}
%    The macro |\addto{|\meta{control sequence}|}{|\meta{\TeX\
%    code}|}| can be used to extend the definition of a macro. The
%    macro need not be defined. This macro can, for instance, be used
%    in adding instructions to a macro like |\extrasenglish|.
%
% \subsection{Macros common to a number of languages}
%
% \DescribeMacro{\allowhyphens}
%    In a couple of european languages compound words are used. This
%    means that when \TeX\ has to hyphenate such a compound word it
%    only does that at the `\texttt{-}' that is used in such words. To
%    allow hyphenation in the rest of such a compound word the macro
%    |\allowhyphens| can be used.
%
% \DescribeMacro{\set@low@box}
%    For some languages quotes need to be lowered to the baseline. For
%    this purpose the macro |\set@low@box| is available. It takes one
%    argument and puts that argument in an |\hbox|, at the
%    baseline. The result is available in |\box0| for further
%    processing.
%
% \DescribeMacro{\save@sf@q}
%    Sometimes it is necessary to preserve the |\spacefactor|.  For
%    this purpose the macro |\save@sf@q| is available. It takes one
%    argument, saves the current spacefactor, executes the argument
%    and restores the spacefactor.
%
% \DescribeMacro{\bbl@frenchspacing}
% \DescribeMacro{\bbl@nonfrenchspacing}
%    The commands |\bbl@frenchspacing| and |\bbl@nonfrenchspacing| can
%    be used to properly switch french spacing on and off.
%
% \section{Compatibility with \file{german.sty}}\label{l-h}
%
%    As has been discussed before, the file \file{german.sty} has been
%    one of the sources of inspiration for the \babel{}
%    system. Because of this I wanted to include \file{german.sty} in
%    the \babel{} system.  To be able to do that I had to allow for
%    one incompatibility: in the definition of the macro
%    |\selectlanguage| in \file{german.sty} the argument is used as the
%    {$\langle \it number \rangle$} for an |\ifcase|. So in this case
%    a call to |\selectlanguage| might look like
%    |\selectlanguage{\german}|.
%
%    In the definition of the macro |\selectlanguage| in
%    \file{babel.def} the argument is used as a part of other
%    macronames, so a call to |\selectlanguage| now looks like
%    |\selectlanguage{german}|.  Notice the absence of the escape
%    character.  As of version~3.1a of \babel{} both syntaxes are
%    allowed.
%
%    All other features of the original \file{german.sty} have been
%    copied into a new file, called \file{germanb.sty}\footnote{The
%    `b' is added to the name to distinguish the file from Partls'
%    file.}.
%
%    Although the \babel{} system was developed to be used with
%    \LaTeX, some of the features implemented in the language
%    definition files might be needed by plain \TeX\ users. Care has
%    been taken that all files in the system can be processed by plain
%    \TeX.
%
%
%\StopEventually{%
% \clearpage
% \let\filename\thisfilename
% \section{Conclusion}
%
%    A system of document options has been presented that enable the
%    user of \LaTeX\ to adapt the standard document classes of \LaTeX\
%    to the language he or she prefers to use. These options offer the
%    possibility to switch between languages in one document. The
%    basic interface consists of using ones option, which is the same
%    for \emph{all} standard document classes.
%
%    In some cases the language definition files provide macros that
%    can be of use to plain \TeX\ users as well as to \LaTeX\ users.
%    The \babel{} system has been implemented in such a way that it
%    can be used by both groups of users.
%
% \section{Acknowledgements}
%
%    I would like to thank all who volunteered as $\beta$-testers for
%    their time. I would like to mention Julio Sanchez who supplied
%    the option file for the Spanish language and Maurizio Codogno who
%    supplied the option file for the Italian language. Werenfried
%    Spit supplied the files for the Russian language. Michel Goossens
%    supplied contributions for most of the other languages.  Nico
%    Poppelier helped polishing the text of the documentation and
%    supplied parts of the macros for the Dutch language.  Paul
%    Wackers and Werenfried Spit helped finding and repairing bugs.
%
%    During the further development of the babel system I received
%    much help from Bernd Raichle, for which I am grateful.
%
%  \begin{thebibliography}{9}
%  \bibitem{DEK} Donald E. Knuth,
%    \emph{The \TeX book}, Addison-Wesley, 1986.
%  \bibitem{LLbook} Leslie Lamport,
%    \emph{\LaTeX, A document preparation System}, Addison-Wesley, 1986.
%   \bibitem{treebus} K.F. Treebus.
%   \emph{Tekstwijzer, een gids voor het grafisch verwerken van tekst.}
%   SDU Uitgeverij ('s-Gravenhage, 1988). A Dutch book on layout
%   design and typography.
%  \bibitem{HP} Hubert Partl,
%    \emph{German \TeX}, \emph{TUGboat} 9 (1988) \#1, p.~70--72.
%  \bibitem{LLth} Leslie Lamport,
%    in: \TeXhax\ Digest, Volume 89, \#13, 17 februari 1989.
%  \bibitem{BEP} Johannes Braams, Victor Eijkhout and Nico Poppelier,
%   \emph{The development of national \LaTeX\ styles},
%   \emph{TUGboat} 10 (1989) \#3, p.~401--406.
%  \bibitem{ilatex} Joachim Schrod,
%   \emph{International \LaTeX\ is ready to use},
%   \emph{TUGboat} 11 (1990) \#1, p.~87--90.
%  \end{thebibliography}
% }
%
% \section{Identification}
%
%    The file \file{babel.sty}\footnote{The file described in this
%    section is called \texttt{\filename}, has version
%    number~\fileversion\ and was last revised on~\filedate.} is meant
%    for \LaTeXe, therefore we make sure that the format file used is
%    the right one.
%
%    \begin{macrocode}
%<+package>\NeedsTeXFormat{LaTeX2e}
%    \end{macrocode}
%
%    The identification code for each file is something that was
%    introduced in \LaTeXe. When the command |\ProvidesFile| does not
%    exist, a dummy definition is provided.
% \changes{babel~3.4e}{1994/06/24}{Redid the identification code,
%    provided dummy definition of \cs{ProvidesFile} for plain \TeX}
%    \begin{macrocode}
%<*!package>
\ifx\ProvidesFile\undefined
  \def\ProvidesFile#1[#2 #3 #4]{\wlog{#4 #3 <#2>}}\fi
%</!package>
%    \end{macrocode}
%    Identify each file that is produced from this source file.
% \changes{babel~3.4c}{1995/04/28}{lhyphen.cfg has become
%    lthyphen.cfg}
% \changes{babel~3.5b}{1995/01/25}{lthyphen.cfg has become hyphen.cfg}
%    \begin{macrocode}
%<+package>\ProvidesPackage{babel}
%<+core>\ProvidesFile{babel.def}
%<+kernel&patterns>\ProvidesFile{hyphen.cfg}
%<+kernel&!patterns>\ProvidesFile{switch.def}
%<+driver&!user>\ProvidesFile{babel.drv}
%<+driver&user>\ProvidesFile{user.drv}
                [1995/07/11 v3.5e 
%<+package>     The Babel package]
%<+core>         Babel common definitions]
%<+kernel>      Babel language switching mechanism]
%<+driver>]
%    \end{macrocode}
%
% \section{The Package File}
%
%    In order to make use of the new features of \LaTeXe, a new file
%    is introdued to the \babel\ system, \file{babel.sty}. This file
%    is loaded by the |\usepackage| command and defines all the
%    language options known in the \babel system.
%
%    For all the languages supported we need to declare an option.
%
%    `American' is a version of `English' which can have its own
%    hyphenation patterns. The default english patterns are in fact
%    for  american english. We allow or the patterns to be loaded as
%    `english' `american' or `USenglish'.
% \changes{babel~3.5a}{1995/03/14}{Changed extension of language
%    definition files to \texttt{ldf}}
% \changes{babel~3.5d}{1995/07/02}{Load language definition files
%    \emph{after} the check for the hyphenation patterns}
%    \begin{macrocode}
%<*package>
\DeclareOption{american}{%
  \ifx\l@USenglish\undefined
  \else
    \let\l@american\l@USenglish
  \fi
  \input{english.ldf}%
  \main@language{american}}
%    \end{macrocode}
%    Austrian is really a dialect of German.
%    \begin{macrocode}
\DeclareOption{austrian}{%
  \input{germanb.ldf}%
  \main@language{austrian}}
\DeclareOption{bahasa}{\input{bahasa.ldf}}
\DeclareOption{brazil}{\input{portuges.ldf}\main@language{brazil}}
%    \end{macrocode}
% \changes{babel~3.5b}{1995/05/25}{Added brazilian as alternative for
%    brazil}
%    \begin{macrocode}
\DeclareOption{brazilian}{%
  \input{portuges.ldf}%
  \let\captionsbrazilian\captionsbrazil
  \let\datebrazilian\datebrazil
  \let\extrasbrazilian\extrasbrazil
  \let\noextrasbrazilian\noextrasbrazil
  \let\brazilianhyphenmins\brazilhyphenmins
  \main@language{brazilian}}
\DeclareOption{breton}{\input{breton.ldf}}
%    \end{macrocode}
% \changes{babel~3.5d}{1995/07/02}{Added british as an alternative for
%    `english' with a preference for british hyphenation}
%    \begin{macrocode}
\DeclareOption{british}{%
  \ifx\l@british\undefined
    \ifx\l@UKenglish\undefined
    \else
      \let\l@english\l@UKenglish
    \fi
  \else
    \let\l@english\l@british
  \fi
  \input{english.ldf}%
  \ifx\l@british\undefined
    \let\l@british\l@english
  \fi
  \let\captionsbritish\captionsenglish
  \let\datebritish\dateenglish
  \let\extrasbritish\extrasenglish
  \let\britishhyphenmins\englishhyphenmins
  \main@language{british}
  }
\DeclareOption{catalan}{\input{catalan.ldf}}
\DeclareOption{croatian}{\input{croatian.ldf}}
\DeclareOption{czech}{\input{czech.ldf}}
\DeclareOption{danish}{\input{danish.ldf}}
\DeclareOption{dutch}{\input{dutch.ldf}}
%    \end{macrocode}
%    We allow for the british english patterns to be loaded as either
%    `english' or `UKenglish'
%    \begin{macrocode}
\DeclareOption{english}{%
  \ifx\l@UKenglish\undefined
  \else
    \let\l@english\l@UKenglish
  \fi
  \input{english.ldf}%
  }
\DeclareOption{esperanto}{\input{esperant.ldf}}
%    \end{macrocode}
% \changes{babel~3.5b}{1995/06/06}{Added estonian option}
%    \begin{macrocode}
\DeclareOption{estonian}{\input{estonian.ldf}}
\DeclareOption{finnish}{\input{finnish.ldf}}
%    \end{macrocode}
%    The \babel\ support or French is stored in \file{francais.ldf};
%    therefore the \LaTeX2.09 option used to be \Lopt{francais}.
%    The hyphenation patterns may be loaded as either `french' or as
%    `francais'.
%    \begin{macrocode}
\DeclareOption{francais}{%
  \ifx\l@francais\undefined
    \let\l@francais\l@french
  \fi
  \input{francais.ldf}%
  }
%    \end{macrocode}
%    With \LaTeXe\ we can now also use the option \Lopt{french} and
%    still call the file \file{francais.ldf}.
% \changes{babel~3.5d}{1995/07/02}{Load \file{french.ldf} when it is
%    found instead of \file{francais.ldf}}
%    \begin{macrocode}
\DeclareOption{french}{%
  \ifx\l@french\undefined
    \let\l@french\l@francais
  \fi
  \IfFileExists{french.ldf}{%
    \input{french.ldf}}{%
    \input{francais.ldf}}%
  \let\captionsfrench\captionsfrancais
  \let\datefrench\datefrancais
  \let\extrasfrench\extrasfrancais
  \let\noextrasfrench\noextrasfrancais
  \let\frenchhyphenmins\francaishyphenmins
  }
\DeclareOption{galician}{\input{galician.ldf}}
\DeclareOption{german}{\input{germanb.ldf}}
\DeclareOption{germanb}{\input{germanb.ldf}}
%    \end{macrocode}
%    \Lopt{hungarian} is just a synonym for \Lopt{magyar}
%    \begin{macrocode}
\DeclareOption{hungarian}{\input{magyar.ldf}%
  \let\captionshungarian\captionsmagyar
  \let\datehungarian\datemagyar
  \let\extrashungarian\extrasmagyar
  \let\noextrashungarian\noextrasmagyar
  \let\hugarianhyphenmins\magyarhyphenmins
  }
\DeclareOption{irish}{\input{irish.ldf}}
\DeclareOption{italian}{\input{italian.ldf}}
\DeclareOption{lowersorbian}{\input{lsorbian.ldf}}
\DeclareOption{magyar}{\input{magyar.ldf}}
\DeclareOption{norsk}{\input{norsk.ldf}}
%    \end{macrocode}
%    For Norwegian two spelling variants are provided.
%    \begin{macrocode}
\DeclareOption{nynorsk}{%
  \input{norsk.ldf}%
  \main@language{nynorsk}}
\DeclareOption{polish}{\input{polish.ldf}}
\DeclareOption{portuges}{\input{portuges.ldf}}
\DeclareOption{portuguese}{\input{portuges.ldf}%
  \let\captionsportuguese\captionsportuges
  \let\dateportuguese\dateportuges
  \let\extrasportuguese\extrasportuges
  \let\noextrasportuguese\noextrasportuges
  \let\portuguesehyphenmins\portugeshyphenmins
}
\DeclareOption{romanian}{\input{romanian.ldf}}
%\DeclareOption{russian}{\input{russian.ldf}}
\DeclareOption{scottish}{\input{scottish.ldf}}
\DeclareOption{spanish}{\input{spanish.ldf}}
\DeclareOption{slovak}{\input{slovak.ldf}}
\DeclareOption{slovene}{\input{slovene.ldf}}
\DeclareOption{swedish}{\input{swedish.ldf}}
\DeclareOption{turkish}{\input{turkish.ldf}}
\DeclareOption{uppersorbian}{\input{usorbian.ldf}}
%    \end{macrocode}
%
%    Apart from all the language options we also have a few options
%    that influence the behaviour of language definition files.
%
%    The following options don't do anything themselves, they are just
%    defined in order to make it possible for language definition
%    files to check if one of them was specified by the user.
% \changes{babel~3.5d}{1995/07/04}{Added options to influence
%    behaviour of active acute and grave accents}
%    \begin{macrocode}
\DeclareOption{activeacute}{}
\DeclareOption{activegrave}{}
%    \end{macrocode}
%
%    The options have to be processed in the order in which the user
%    specified them:
%    \begin{macrocode}
\ProcessOptions*
%</package>
%    \end{macrocode}
%
% \section{The Kernel of Babel}
%
%    The kernel of the \babel\ system is stored in either
%    \file{hyphen.cfg} or \file{switch.def} and \file{babel.def}. The
%    file \file{hyphen.cfg} is a file that can be loaded into the
%    format, which is necessary when you want to be able to switch
%    hyphenation patterns. The file \file{babel.def} contains some
%    \TeX\ code that can be read in at run time. When \file{babel.def}
%    is loaded it checks if \file{hyphen.cfg} is in the format; if
%    not the file \file{switch.def} is loaded.
%
%    Because plain \TeX\ users might want to use some of the features
%    of the \babel{} system too, care has to be taken that plain \TeX\
%    can process the files. For this reason the current format will
%    have to be checked in a number of places. Some of the code below
%    is common to plain \TeX\ and \LaTeX, some of it is for the
%    \LaTeX\ case only.
%
%    When the command |\AtBeginDocument| doesn't exist we assume that
%    we are dealing with a plain-based format. In that case the file
%    \file{plain.def} is needed.
%
%    \begin{macrocode}
\ifx\AtBeginDocument\undefined
  \input plain.def\relax
\fi
%    \end{macrocode}
%
%    Check the presence of the command |\iflanguage|, if it is
%    undefined read the file \file{switch.def}.
% \changes{babel~3.0d}{1991/10/29}{Removed use of \cs{@ifundefined}}
%    \begin{macrocode}
%<*core>
\ifx\undefined\iflanguage
  \input switch.def\relax
\fi
%    \end{macrocode}
%
%    To communicate to the language definition files that the core of
%    the \babel{} system has been loaded, the following control
%    sequence is just |\let| equal to |\relax|.
%    \begin{macrocode}
\let\babel@core@loaded\relax
%</core>
%    \end{macrocode}
%
% \subsection{Multiple languages}
%
%    With \TeX\ version~3.0 it has become possible to load hyphenation
%    patterns for more than one language. This means that some extra
%    administration has to be taken care of.  The user has to know for
%    which languages patterns have been loaded, and what values of
%    |\language| have been used.
%
%    Some discussion has been going on in the \TeX\ world about how to
%    use |\language|. Some have suggested to set a fixed standard,
%    i.\,e., patterns for each language should \emph{always} be loaded
%    in the same location. It has also been suggested to use the
%    \textsc{iso} list for this purpose. Others have pointed out that
%    the \textsc{iso} list contains more than 256~languages, which
%    have \emph{not} been numbered consecutively.
%
%    I think the best way to use |\language|, is to use it
%    dynamically.  This code implements an algorithm to do so. It uses
%    an external file in which the person who maintains a \TeX\
%    environment has to record for which languages he has hyphenation
%    patterns \emph{and} in which files these are stored\footnote{This
%    is because different operating systems sometimes use \emph{very}
%    different filenaming conventions.}. When hyphenation exceptions
%    are stored in a separate file this can be indicated by naming
%    that file \emph{after} the file with the hyphenation patterns.
%
%    This ``configuration file'' can contain empty lines and comments,
%    as well as lines which start with an equals (\texttt{=})
%    sign. Such a line will instruct \LaTeX\ that the hyphenation
%    patterns just processed have to be known under an alternative
%    name. Here is an example:
%  \begin{verbatim}
%    % File    : language.dat
%    % Purpose : tell iniTeX what files with patterns to load.
%    english    english.hyphenations
%    =british
%
%    dutch      hyphen.dutch exceptions.dutch % Nederlands
%    german hyphen.ger
%  \end{verbatim}
%
%    As the file \file{switch.def} needs to be read only once, we
%    check whether it was read before.  If it was, the command
%    |\iflanguage| is already defined, so we can stop processing.
%    \begin{macrocode}
%<*kernel>
%<*!patterns>
\expandafter\ifx\csname iflanguage\endcsname\relax \else
\expandafter\endinput
\fi
%</!patterns>
%    \end{macrocode}
%
%  \begin{macro}{\language}
%    Plain \TeX\ version~3.0 provides the primitive |\language| that
%    is used to store the current language. When used with a pre-3.0
%    version this function has to be implemented by allocating a
%    counter. 
%    \begin{macrocode}
\ifx\language\undefined
  \csname newcount\endcsname\language
\fi
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\last@language}
%    Another counter is used to store the last language defined.  For
%    pre-3.0 formats an extra counter has to be allocated,
%    \begin{macrocode}
\ifx\newlanguage\undefined
  \csname newcount\endcsname\last@language
%    \end{macrocode}
%    plain \TeX\ version 3.0 uses |\count 19| for this purpose.
%    \begin{macrocode}
\else
  \countdef\last@language=19
\fi
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\addlanguage}
%
%    To add languages to \TeX's memory plain \TeX\ version~3.0
%    supplies |\newlanguage|, in a pre-3.0 environment a similar macro
%    has to be provided. For both cases a new macro is defined here,
%    because the original |\newlanguage| was defined to be |\outer|.
%
%    For a format based on plain version~2.x, the definition of
%    |\newlanguage| can not be copied because |\count 19| is used for
%    other purposes in these formats. Therefore |\addlanguage| is
%    defined using a definition based on the macros used to define
%    |\newlanguage| in plain \TeX\ version~3.0.
% \changes{hyphen-1.1a}{1991/11/11}{Added a \texttt{\%}, removed
%    \texttt{by}}
%    \begin{macrocode}
\ifx\newlanguage\undefined
  \def\addlanguage#1{%
    \global\advance\last@language \@ne
    \ifnum\last@language<\@cclvi
    \else
        \errmessage{No room for a new \string\language!}%
    \fi
    \global\chardef#1\last@language
    \wlog{\string#1 = \string\language\the\last@language}}
%    \end{macrocode}
%
%    For formats based on plain version~3.0 the definition of
%    |\newlanguage| can be simply copied, removing |\outer|.
%
%    \begin{macrocode}
\else
  \def\addlanguage{\alloc@9\language\chardef\@cclvi}
\fi
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\adddialect}
%    The macro |\adddialect| can be used to add the name of a dialect
%    or variant language, for which an already defined hyphenation
%    table can be used.
% \changes{hyphen-1.1a}{1991/11/11}{Added \cs{relax}}
%    \begin{macrocode}
\def\adddialect#1#2{%
    \global\chardef#1#2\relax
    \wlog{\string#1 = a dialect from \string\language#2}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\iflanguage}
%    Users might want to test (in a private package for instance)
%    which language is currently active. For this we provide a test
%    macro, |\iflanguage|, that has three arguments.  It checks
%    whether the first argument is a known language. If so, it
%    compares the first argument with the value of |\language|. Then,
%    depending on the result of the comparison, it executes either the
%    second or the third argument.
% \changes{hyphen-1.0b}{1991/05/29}{Added \cs{@bsphack} and
%    \cs{@esphack}}
% \changes{hyphen-1.0d}{1991/07/21}{Added comment character after
%    \texttt{\#2}}
% \changes{hyphen-1.0e}{1991/08/08}{Removed superfluous
%    \cs{expandafter}}
% \changes{hyphen-1.0h}{1991/10/07}{Removed space hacks and use of
%    \cs{@ifundefined}}
% \changes{hyphen-1.1a}{1991/11/11}{Refrased \cs{ifnum} test}
%    \begin{macrocode}
\def\iflanguage#1#2#3{%
  \expandafter\ifx\csname l@#1\endcsname\relax
    \@nolanerr{#1}%
  \else
    \ifnum\csname l@#1\endcsname=\language #2%
    \else#3\fi
  \fi}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\selectlanguage}
%    The macro |\selectlanguage| checks whether the language is
%    already defined before it performs its actual task, which is to
%    update |\language| and activate language-specific definitions.
%
%    To allow the call of |\selectlanguage| either with a control
%    sequence name or with a simple string as argument, we have to use
%    a trick to delete the optional escape character.
%
%    To convert a control sequence to a string, we use the |\string|
%    primitive.  Next we have to look at the first character of this
%    string and compare it with the escape character.  Because this
%    escape character can be changed by setting the internal integer
%    |\escapechar| to a character number, we have to compare this
%    number with the character of the string.  To do this we have to
%    use \TeX's backquote notation to specify the character as a
%    number.
%
%    If the first character of the |\string|'ed argument is the
%    current escape character, the comparison has stripped this
%    character and the rest in the `then' part consists of the rest of
%    the control sequence name.  Otherwise we know that either the
%    argument is not a control sequence or |\escapechar| is set to a
%    value outside of the character range~$0$--$255$.
%
%    If the user gives an empty argument, we provide a default
%    argument for |\string|.  This argument should expand to nothing.

% \changes{hyphen-1.0c}{1991/06/06}{Made \cs{selectlanguage}
%    robust}
% \changes{hyphen-1.1a}{1991/11/11}{Modified to allow arguments that
%    start with an escape character}
% \changes{hyphen-1.1b}{1991/11/17}{Simplified the modification to
%    allow the use in a \cs{write} command}
% \changes{babel~3.5b}{1995/05/13}{Store the name of the current
%    language in a control sequence instead of passing the whole macro
%    construct to strip the escape character in the argument of
%    \cs{selectlanguage }.}
%    \begin{macrocode}
\def\selectlanguage#1{%
  \edef\languagename{%
    \ifnum\escapechar=\expandafter`\string#1\empty
     \else \string#1\empty\fi}
  \expandafter\protect\csname selectlanguage \expandafter\endcsname
  \expandafter{\languagename}}
%    \end{macrocode}
%    Because the command |\selectlanguage| could be used in a moving
%    argument it expands to \verb*=\protect\selectlanguage =.
%    Therefore, we have to make sure that a macro |\protect| exists.
%    If it doesn't it is |\let| to |\relax|.
%    \begin{macrocode}
\ifx\undefined\protect\let\protect\relax\fi
%    \end{macrocode}
%
%    {\small Remark: If the |\selectlanguage| command is written to a
%    file, a possible control sequence argument gets totally expanded
%    to the string without the leading escape character.  In the
%    normal case we have to deal with the fact that the argument of
%    |\selectlanguage | is totally unexpanded at the moment.  There
%    is only one disadvantage in the current implementation:
%    |\originalTeX| contains this unexpanded argument and therefore
%    needs more memory for its macro definition.  \par}
%
% \changes{babel~3.5b}{1995/03/04}{Changed the name of the internal
%    macro to \cs{selectlanguage }.}
% \changes{babel~3.5b}{1995/03/05}{Added an extra level of expansion to
%    separate the switching mechanism from writing to aux files}
%    \begin{macrocode}
\expandafter\def\csname selectlanguage \endcsname#1{%
  \select@language{#1}%
%    \end{macrocode}
%    We also write a command to change the current language the
%    auxiliary files.
% \changes{babel~3.5a}{1995/02/17}{write the language change to the
%    auxiliary files}
%    \begin{macrocode}
  \if@filesw
    \protected@write\@auxout{}{\string\select@language{#1}}%
    \addtocontents{toc}{\string\select@language{#1}}%
    \addtocontents{lof}{\string\select@language{#1}}%
    \addtocontents{lot}{\string\select@language{#1}}%
  \fi}
%    \end{macrocode}
%    
%    First, check if the user asks for a known language. If so,
%    update the value of |\language| and call |\originalTeX|
%    to bring \TeX\ in a certain pre-defined state.
% \changes{hyphen-1.0b}{1991/05/29}{Added \cs{@bsphack} and
%    \cs{@esphack}}
% \changes{hyphen-1.0e}{1991/08/08}{Removed superfluous
%    \cs{expandafter}}
% \changes{hyphen-1.0h}{1991/10/07}{Removed space hacks and use of
%    \cs{@ifundefined}}
% \changes{hyphen-1.1b}{1991/11/17}{Added \cs{relax} as first command
%    to stop an expansion if \cs{protect} is empty}
%    \begin{macrocode}
\def\select@language#1{%
  \expandafter\ifx\csname l@#1\endcsname\relax
    \@nolanerr{#1}%
  \else
    \language=\csname l@#1\endcsname\relax
    \originalTeX
%    \end{macrocode}
%    The name of the language is stored in the control sequence
%    |\languagename|. The contents of this control sequence could be
%    tested in the following way:
%  \begin{verbatim}
%    \edef\tmp{\string english}
%    \ifx\languagename\tmp
%        ...
%    \else
%        ...
%    \fi
%  \end{verbatim}
%    The construction with |\string| is necessary because
%    |\languagename| returns the name with characters of category code
%    \texttt{12} (other).  Then we have to \emph{re}define
%    |\originalTeX| to compensate for the things that have been
%    activated.  To save memory space for the macro definition of
%    |\originalTeX|, we construct the control sequence name for the
%    |\noextras|\langvar command at definition time by expanding the
%    |\csname| primitive.
% \changes{hyphen-1.0c}{1991/06/06}{Replaced \cs{gdef} with \cs{def}}
% \changes{hyphen-1.1}{1991/10/31}{\cs{originalTeX} should only be
%    executed once}
% \changes{hyphen-1.1b}{1991/11/17}{Added three \cs{expandafter}s
%    to save macro space for \cs{originalTeX}}
% \changes{hyphen-1.1c}{1991/11/20}{Moved definition of
%    \cs{originalTeX} before \cs{extras\langvar}}
% \changes{hyphen-1.1d}{1991/11/24}{Set \cs{originalTeX} to
%    \cs{empty}, because it should be expandable.}
%    \begin{macrocode}
    \expandafter\def\expandafter\originalTeX
        \expandafter{\csname noextras#1\endcsname
                     \let\originalTeX\empty}%
    \babel@beginsave
%    \end{macrocode}
%    Now activate the language-specific definitions. This is done by
%    constructing the names of three macros by concatenating three
%    words with the argument of |\selectlanguage|, and calling these
%    macros.
% \changes{babel~3.5b}{1995/05/13}{Seperated the setting of the
% hyphenmin values}
%    \begin{macrocode}
    \csname captions#1\endcsname
    \csname date#1\endcsname
    \csname extras#1\endcsname\relax
%    \end{macrocode}
%    The switching of the values of |\lefthyphenmin| and
%    |\righthyphenmin| is somewhart different. First we save their
%    current values, then we check if |\|\langvar|hyphenmins| is
%    defined. If it is not we set default values (2 and 3), otherwise
%    the values in |\|\langvar|hyphenmins| will be used.
% \changes{babel~3.5b}{1995/06/05}{Addedd default setting of hyphenmin
%    parameters}
%    \begin{macrocode}
    \babel@savevariable\lefthyphenmin
    \babel@savevariable\righthyphenmin
    \expandafter\ifx\csname #1hyphenmins\endcsname\relax
      \lefthyphenmin\tw@\righthyphenmin\thr@@
    \else
      \expandafter\expandafter\expandafter\set@hyphenmins
        \csname #1hyphenmins\endcsname
    \fi
  \fi}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{environment}{otherlanguage}
%    The \textsf{otherlanguage} environment can be used as an
%    alternative to using the |\selectlanguage| declarative
%    command. When you are typesetting a document with mixes
%    left-to-right and right-to-left typesetting you have to use this
%    environment in order to let things work as you expect them to.
%
%    The first thing this environment does is store the name of the
%    language in |\languagename|; it then calls
%    \verb*=\selectlanguage = to switch on everything that is needed for
%    this language The |\ignorespaces| command is necessary to hide
%    the environment when it is entered in horizontal mode.
% \changes{babel~3.5d}{1995/06/22}{environment added}
% \changes{babel~3.5e}{1995/07/07}{changed name}
%    \begin{macrocode}
\long\def\otherlanguage#1{%
  \def\languagename{#1}%
  \csname selectlanguage \endcsname{#1}%
  \ignorespaces
  }
%    \end{macrocode}
%    The |\endotherlanguage| part of the environment calls
%    |\originalTeX| to restore (most of) the settings and tries to
%    hide itself when it is called in horizontal mode.
%    \begin{macrocode}
\long\def\endotherlanguage{%
  \originalTeX
  \global\@ignoretrue\ignorespaces
  }
%    \end{macrocode}
%  \end{environment}
%
%  \begin{macro}{\foreignlanguage}
%    The |\foreignlanguage| command is another substitute for the
%    |\selectlanguage| command. This command takes two arguments, the
%    first argument is the name of the language to use for typesetting
%    the text specified in the second argument. 
%
%    Unlike |\selectlanguage| this command doesn't switch
%    \emph{everything}, it only switches the hyphenation rules and the
%    extra definitions for the language specified. It does this within
%    a group and assumes the |\extras|\langvar\ command doesn't make
%    any |\global| changes. The coding is very similar to part of
%    |\selectlanguage|.
% \changes{babel~3.5d}{1995/06/22}{Macro added}
%    \begin{macrocode}
\def\foreignlanguage#1#2{%
  \begingroup
    \def\languagename{#1}%
    \expandafter\ifx\csname l@#1\endcsname\relax
      \@nolanerr{#1}%
    \else
      \language=\csname l@#1\endcsname\relax
      \csname extras#1\endcsname
%    \end{macrocode}
% \changes{babel~3.5e}{1995/07/06}{Use \cs{relax} instead of
%    \cs{undefined}}
%    \begin{macrocode}
      \expandafter\ifx\csname #1hyphenmins\endcsname\relax
        \lefthyphenmin\tw@\righthyphenmin\thr@@
      \else
        \expandafter\expandafter\expandafter\set@hyphenmins
          \csname #1hyphenmins\endcsname
      \fi
    \fi
    #2
    \csname noextras#1\endcsname
    \endgroup
  }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\set@hyphenmins}
%    This macro sets the values of |\lefthyphenmin| and
%    |\righthyphenmin|. It expects two values as its argument.
%    \begin{macrocode}
\def\set@hyphenmins#1#2{\lefthyphenmin#1\righthyphenmin#2}
%</kernel>
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\main@language}
% \changes{babel~3.5a}{1995/02/17}{Macro added}
%  \begin{macro}{\bbl@main@language}
% \changes{babel~3.5a}{1995/02/17}{Macro added}
%    This command should be used in the various language definition
%    files. It stores its argument in |\bbl@main@language|; to be used
%    to switch to the correct language ath the beginning of the
%    document. 
%    \begin{macrocode}
%<*core>
\def\main@language#1{\def\bbl@main@language{#1}}
%    \end{macrocode}
%    The default is to use English as the main language.
%    \begin{macrocode}
\main@language{english}
%    \end{macrocode}
%    We also have to make sure that some code gets executed at the
%    beginning of the document.
%    \begin{macrocode}
\AtBeginDocument{%
  \expandafter\selectlanguage\expandafter{\bbl@main@language}}
%</core>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%    The macro|\originalTeX| should be known to \TeX\ at this moment.
%    As it has to be expandable we |\let| it to |\empty| instead of
%    |\relax|.
% \changes{hyphen-1.1d}{1991/11/24}{Set \cs{originalTeX} to
%    \cs{empty}, because it should be expandable.}
%    \begin{macrocode}
%<*kernel>
\ifx\undefined\originalTeX\let\originalTeX\empty\fi
%    \end{macrocode}
%    Because this part of the code can be included in a format, we
%    make sure that the macro which initialises the save mechanism,
%    |\babel@beginsave|, is not considered to be undefined.
%    \begin{macrocode}
\ifx\undefined\babel@beginsave\let\babel@beginsave\relax\fi
%    \end{macrocode}
%
%  \begin{macro}{\@nolanerr}
% \changes{babel~3.4e}{1994/06/25}{Use \cs{PackageError} in \LaTeXe\
%    mode}
%  \begin{macro}{\@nopatterns}
% \changes{babel~3.4e}{1994/06/25}{Macro added}
%    The \babel\ package will signal an error when a documents tries
%    to select a language that hasn't been defined earlier. When a
%    user selects a language for which no hyphenation patterns were
%    loaded into the format he will be given a warning about that
%    fact. We revert to the patterns for |\language|=0 in that case.
%    In most formats that will be (US)english, but it might also be
%    empty.
%
%    When the format knows about |\PackageError| it must be \LaTeXe,
%    so we can safely use its error handling interface. Otherwise
%    we'll have to `keep it simple'.
% \changes{hyphen-1.0h}{1991/10/07}{Added a percent sign to remove
%    unwanted white space}
% \changes{babel~3.5a}{1995/02/15}{Added \cs{@activated} to log active
%    characters}
% \changes{babel~3.5c}{1995/06/19}{Added missing closing brace}
%    \begin{macrocode}
\ifx\PackageError\undefined
  \def\@nolanerr#1{%
    \errhelp{Your command will be ignored, type <return> to proceed}%
    \errmessage{You haven't defined the language #1\space yet}}
  \def\@nopatterns#1{%
    \message{No hyphenation patterns were loaded for}
    \message{the language `#1'}
    \message{I will use the patterns loaded for \string\language=0
          instead}}
  \def\@activated#1{%
    \wlog{Package babel Info: Making #1 an active character}}
\else
  \newcommand*{\@nolanerr}[1]{%
    \PackageError{babel}%
                 {You haven't defined the language #1\space yet}%
        {Your command will be ignored, type <return> to proceed}}
  \newcommand*{\@nopatterns}[1]{%
    \PackageWarningNoLine{babel}%
        {No hyphenation patterns were loaded for\MessageBreak
          the language `#1'\MessageBreak
          I will use the patterns loaded for \string\language=0
          instead}}
  \newcommand*{\@activated}[1]{%
    \PackageInfo{babel}{%
      Making #1 an active character}}
\fi
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%    The following code is meant to be read by ini\TeX\ because it
%    should instruct \TeX\ to read hyphenation patterns. To this end
%    the \texttt{docstrip} option \texttt{patterns} can be used to
%    include this code in the file \file{hyphen.cfg}.
%    \begin{macrocode}
%<*patterns>
%    \end{macrocode}
%
%  \begin{macro}{\patterns@loaded}
% \changes{hyphen-1.0i}{1991/10/27}{Added a token register for
%    collecting the names of patterns that are loaded by ini\TeX.}
%    It has been suggested to add a remark to \LaTeX's |\everyjob|
%    message, stating which hyphenation patterns have been loaded.
%    This can be done by first collecting (in a token register) the
%    names when processing the file \file{language.dat} and
%    afterwards adding a string to the |\everyjob| message. The token
%    register is initially empty.
%
%    \begin{macrocode}
\newtoks\patterns@loaded \global\patterns@loaded={}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\process@line}
% \changes{babel~3.5b}{1995/04/28}{added macro}
%    Each line in the file \file{language.dat} is processed by
%    |\process@line| after it is read. The first thing this macro does
%    is to check wether the line starts with \texttt{=}.
%  \begin{macro}{\bbl@eq@}
% \changes{babel~3.5b}{1995/04/28}{added macro}
%    To be able to do that we need an \texttt{=}, stored in a macro.
%    \begin{macrocode}
\def\bbl@eq@{=}
%    \end{macrocode}
%  \end{macro}
%    When the first token of a line is an \texttt{=}, the macro
%    |\process@synonym| is called; otherwise the macro
%    |\process@language| will continue.
%    \begin{macrocode}
\def\process@line#1#2/{%
  \def\bbl@tmp{#1}
  \ifx\bbl@tmp\bbl@eq@
    \process@synonym#2/
  \else
    \process@language#1#2/%
  \fi
  }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\process@synonym}
% \changes{babel~3.5b}{1995/04/28}{added macro}
%    This macro takes care of the lines which start with an
%    \texttt{=}.
%    \begin{macrocode}
\def\process@synonym#1 /{%
  \ifnum\last@language=\m@ne
%    \end{macrocode}
%    When no languages have been loaded yet the name following the
%    \texttt{=} will be a synonym for hyphenation register 0.
%    \begin{macrocode}
    \expandafter\global
    \expandafter\chardef\csname l@#1\endcsname0\relax
    \wlog{\string\l@#1=\string\language0}
  \else
%    \end{macrocode}
%    Otherwise the name will be a synonym for the language loaded last.
%    \begin{macrocode}
    \expandafter\global
    \expandafter\chardef\csname l@#1\endcsname\last@language
    \wlog{\string\l@#1=\string\language\the\last@language}
  \fi
  }
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\process@language}
%    The macro |\process@language| is used to process a non-empty line
%    from the `configuration file'. It has three arguments, each
%    delimited by white space. The third argument is optional,
%    therfore a |/| character is expected to delimit the last
%    argument.  The first argument is the `name' of a language, the
%    second is the name of the file that contains the patterns. The
%    optional third argument is the name of a file containing
%    hyphenation exceptions.
%
%    The first thing to do is call |\addlanguage| to allocate a
%    pattern register and to make that register `active'.
% \changes{hyphen-1.0e}{1991/08/08}{Removed superfluous
%    \cs{expandafter}}
% \changes{hyphen-1.0f}{1991/08/21}{Reinserted \cs{expandafter}}
% \changes{hyphen-1.0i}{1991/10/27}{Added the collection of pattern
%    names.}
%    \begin{macrocode}
\def\process@language#1 #2 #3/{%
    \expandafter\addlanguage\csname l@#1\endcsname
    \expandafter\language\csname l@#1\endcsname
%    \end{macrocode}
%    Then the `name' of the language that will be loaded now is
%    added to the token register |\patterns@loaded|. and finally
%    the pattern file is read.
%    \begin{macrocode}
    \global\patterns@loaded\expandafter{\the\patterns@loaded#1, }%
%    \end{macrocode}
%
% \changes{babel~3.4e}{1994/06/24}{Added code to detect assignments to
%    left- and righthyphenmin in the patternfile.}
%
%    Some pattern files contain assignments to |\lefthyphenmin| and
%    |\righthyphenmin|. \TeX\ does not keep track of these
%    assignments. Therefore we try to detect such assignments and
%    store them in the |\|\langvar|hyphenmins| macro. When no
%    assignments were made we provide a default setting.
%    \begin{macrocode}
    \lefthyphenmin\m@ne
    \input #2\relax
    \ifnum\lefthyphenmin=\m@ne
      \lefthyphenmin\tw@
      \righthyphenmin\thr@@
    \fi
%    \end{macrocode}
%    When the hyphenation patterns have been processed we need to see
%    if a file with hyphenation exceptions needs to be read. This is
%    the case when the third argument is not empty and when it does
%    not contain a space token.
% \changes{babel~3.5b}{1995/04/28}{Added optional reading of file with
%    hyphenation exceptions}
%    \begin{macrocode}
    \def\bbl@tmp{#3}
    \ifx\bbl@tmp\@empty
    \else
      \ifx\bbl@tmp\space
      \else
        \input #3\relax
      \fi
    \fi
%    \end{macrocode}
%    Finally we store the settings of |\lefthyphenmin| and
%    |\righthyphenmin|.
%    \begin{macrocode}
    \expandafter\edef\csname #1hyphenmins\endcsname{%
      \the\lefthyphenmin\the\righthyphenmin}}
%    \end{macrocode}
%  \end{macro}
%
%    The configuration file can now be opened for reading.
%    \begin{macrocode}
\openin1 = language.dat
%    \end{macrocode}
%
%    See if the file exists, if not, use the default hyphenation file
%    \file{hyphen.tex}. The user will be informed about this.
%
%    \begin{macrocode}
\ifeof1
  \message{I couldn't find the file language.dat,\space
           I will try the file hyphen.tex}
  \input hyphen.tex\relax
\else
%    \end{macrocode}
%
%    Pattern registers are allocated using count register
%    |\last@language|. Its initial value is~0. The definition of the
%    macro |\newlanguage| is such that it first increments the count
%    register and then defines the language. In order to have the
%    first patterns loaded in pattern register number~0 we initialize
%    |\last@language| with the value~$-1$.
%
% \changes{hyphen-1.1}{1991/05/21}{Removed use of \cs{toks0}}
%    \begin{macrocode}
  \last@language\m@ne
%    \end{macrocode}
%
%    We now read lines from the file until the end is found
%
%    \begin{macrocode}
  \loop
%    \end{macrocode}
%
%    While reading from the input it is useful to switch off
%    recognition of the end-of-line character. This saves us stripping
%    off spaces from the contents of the controlsequence.
%
%    \begin{macrocode}
    \endlinechar\m@ne
    \read1 to \bbl@line
    \endlinechar`\^^M
%    \end{macrocode}
%
%    Empty lines are skipped.
%    \begin{macrocode}
    \ifx\bbl@line\empty
    \else
%    \end{macrocode}
%
%    Now we add a space and a |/| character to the end of
%    |\bbl@line|. This is needed to be able to recognize the third,
%    optional, argument of |\process@language| later on.
% \changes{babel~3.5b}{1995/04/28}{Now add a \cs{space} and a /
%    character}
%    \begin{macrocode}
      \edef\bbl@line{\bbl@line\space/}
      \expandafter\process@line\bbl@line
    \fi
%    \end{macrocode}
%
%    Check for the end of the file.  To avoid a new \texttt{if}
%    control sequence we create the necessary |\iftrue| or |\iffalse|
%    with the help of |\csname|.  But there is one complication with
%    this approach: when skipping the \texttt{loop...repeat} \TeX\ has
%    to read |\if|/|\fi| pairs.  So we have to insert a `dummy'
%    |\iftrue|.
% \changes{hyphen-1.1}{1991/10/31}{Removed the extra \texttt{if}
%    control sequence}
%    \begin{macrocode}
    \iftrue \csname fi\endcsname
    \csname if\ifeof1 false\else true\fi\endcsname
  \repeat
%    \end{macrocode}
%
%    Reactivate the default patterns,
%    \begin{macrocode}
  \language=0
\fi
%    \end{macrocode}
%    and close the configuration file.
% \changes{hyphen-1.1c}{1991/11/20}{Free macro space for
%    \cs{process@language}}
%    \begin{macrocode}
\closein1
%    \end{macrocode}
%    Also remove some macros from memory
%    \begin{macrocode}
\let\process@language\undefined
\let\process@synonym\undefined
\let\process@line\undefined
\let\bbl@tmp\undefined
\let\bbl@eq@\undefined
\let\bbl@line\undefined
%    \end{macrocode}
%
% \changes{hyphen-1.1}{1991/10/31}{Added redefinition of \cs{dump} to
%    add a message to \cs{everyjob}}
%    We want to add a message to the message \LaTeX\ puts in the
%    |\everyjob| register. This could be done by the following code:
%    \begin{verbatim}
%    \let\orgeveryjob\everyjob
%    \def\everyjob#1{%
%      \orgeveryjob{#1}%
%      \orgeveryjob\expandafter{\the\orgeveryjob\immediate\write16{%
%          hyphenation patterns for \the\loaded@patterns loaded.}}%
%      \let\everyjob\orgeveryjob\let\orgeveryjob\undefined}
%    \end{verbatim}
%    The code above redefines the control sequence \cs{everyjob}
%    in order to be able to add something to the current contents of
%    the register. This is necessary because the processing of
%    hyphenation patterns happens long before \LaTeX\ fills the
%    register.\\
%    There are some problems with this approach though.
%  \begin{itemize}
%    \item When someone wants to use several hyphenation patterns with
%    \SliTeX\ the above scheme won't work. The reason is that \SliTeX\
%    overwrites the contents of the |\everyjob| register with its own
%    message.
%    \item Plain \TeX\ does not use the |\everyjob| register so the
%    message would not be displayed.
%  \end{itemize}
%    To circumvent this a `dirty trick' can be used. As this code is
%    only processed when creating a new format file there is one
%    command that is sure to be used, |\dump|. Therefore the orginal
%    |\dump| is saved in |\org@dump| and a new definition is supplied.
%    \begin{macrocode}
\let\orig@dump=\dump
\def\dump{%
%    \end{macrocode}
%    This new definition starts by adding an instruction to write a
%    message on the terminal and in the transcript file to inform the
%    user of the preloaded hyphenation patterns.
%    \begin{macrocode}
  \everyjob\expandafter{\the\everyjob%
    \immediate\write16{Hyphenation patterns for \the\patterns@loaded
      loaded.}}%
%    \end{macrocode}
%    Then everything is restored to the old situation and the format
%    is dumped.
%    \begin{macrocode}
  \let\dump\orig@dump\let\orig@dump\undefined\dump}
%    \end{macrocode}
%
%    Here the code for ini\TeX\ ends.
%    \begin{macrocode}
%</patterns>
%</kernel>
%    \end{macrocode}
%
% \subsection{Support for active characters}
%
%  \begin{macro}{\bbl@add@special}
% \changes{babel~3.2}{1991/11/10}{Added macro}
%    The macro |\bbl@add@special| is used to add a new character (or
%    single character control sequence) to the macro |\dospecials|
%    (and |\@sanitize| if \LaTeX\ is used).
%
%    To keep all changes local, we begin a new group.  Then we
%    redefine the macros |\do| and |\@makeother| to add themselves and
%    the given character without expansion.
%    \begin{macrocode}
%<*core|shorthands>
\def\bbl@add@special#1{\begingroup
    \def\do{\noexpand\do\noexpand}%
    \def\@makeother{\noexpand\@makeother\noexpand}%
%    \end{macrocode}
%    To add the character to the macros, we expand the original macros
%    with the additional character inside the redefinition of the
%    macros.  Because |\@sanitize| can be undefined, we put the
%    definition inside a conditional.
%    \begin{macrocode}
    \edef\x{\endgroup
      \def\noexpand\dospecials{\dospecials\do#1}%
      \expandafter\ifx\csname @sanitize\endcsname\relax \else
        \def\noexpand\@sanitize{\@sanitize\@makeother#1}%
      \fi}%
%    \end{macrocode}
%    The macro |\x| contains at this moment the following:\\
%    |\endgroup\def\dospecials{|\textit{old contents}%
%    |\do|\meta{char}|}|.\\
%    If |\@sanitize| is defined, it contains an additional definition
%    of this macro.  The last thing we have to do, is the expansion of
%    |\x|.  Then |\endgroup| is executed, which restores the old
%    meaning of |\x|, |\do| and |\@makeother|.  After the group is
%    closed, the new definition of |\dospecials| (and |\@sanitize|) is
%    assigned.
%    \begin{macrocode}
  \x}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\bbl@remove@special}
% \changes{babel~3.2}{1991/11/10}{Added macro}
%    The companion of the former macro is |\bbl@remove@special|.  It
%    is used to remove a character from the set macros |\dospecials|
%    and |\@sanitize|.
%
%    To keep all changes local, we begin a new group.  Then we define
%    a help macro |\x|, which expands to empty if the characters
%    match, otherwise it expands to its nonexpandable input.  Because
%    \TeX\ inserts a |\relax|, if the corresponding |\else| or |\fi|
%    is scanned before the comparison is evaluated, we provide a `stop
%    sign' which should expand to nothing.
%    \begin{macrocode}
\def\bbl@remove@special#1{\begingroup
    \def\x##1##2{\ifnum`#1=`##2\noexpand\empty
                 \else\noexpand##1\noexpand##2\fi}%
%    \end{macrocode}
%    With the help of this macro we define |\do| and |\make@other|.
%    \begin{macrocode}
    \def\do{\x\do}%
    \def\@makeother{\x\@makeother}%
%    \end{macrocode}
%    The rest of the work is similar to |\bbl@add@special|.
%    \begin{macrocode}
    \edef\x{\endgroup
      \def\noexpand\dospecials{\dospecials}%
      \expandafter\ifx\csname @sanitize\endcsname\relax \else
        \def\noexpand\@sanitize{\@sanitize}%
      \fi}%
  \x}
%    \end{macrocode}
%  \end{macro}
%
%  \subsection{Support for active characters}
%
%  \begin{macro}{\initiate@active@char}
% \changes{babel~3.5a}{1995/02/11}{Added macro}
% \changes{babel~3.5b}{1995/03/03}{Renamed macro}
%    A language definition file can call this macro to make a
%    character active. This macro takes one argument, the character
%    that is to be made active. When the character was already active
%    this macro does nothing. Otherwise, this macro defines the
%    control sequence |\normal@char|\m{char} to expand to the
%    character in its `normal state' and it defines the active
%    character to expand to |\normal@char|\m{char} by default
%    (\m{char} being the character to be made active). Later its
%    definition can be be changed to expand to |\active@char|\m{char}
%    by calling |\bbl@activate{|\m{char}|}|.
%
%    For example, to make the double quote character active one could
%    have the following line in a language definition file:
%  \begin{verbatim}
%    \initiate@active@char{"}
%  \end{verbatim}
%
%  \begin{macro}{\bbl@afterelse}
%  \begin{macro}{\bbl@afterfi}
%    Because the code that is used in the handling of active
%    characters may need to look ahead, we take extra care to `throw'
%    it over the |\else| and |\fi| parts of an
%    |\if|-statement\footnote{This code is based on code presented in
%    TUGboat vol. 12, no2, June 1991 in ``An expansion Power Lemma''
%    by Sonja Maus.}.
%    \begin{macrocode}
\def\bbl@afterelse#1\else#2\fi{\fi#1}
\def\bbl@afterfi#1\fi{\fi#1}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%    Note that the definition of |\initiate@active@char| needs an
%    active character, for this the |~| is used. Some of the changes
%    we need do not have to become available later on, so we do it
%    inside a group. 
%    \begin{macrocode}
\begingroup
  \catcode`\~\active
  \def\x{\endgroup
    \def\initiate@active@char##1{%
%    \end{macrocode}
%    If the character is already active we don't do anything.
%    \begin{macrocode}
      \ifcat\noexpand##1\noexpand~\relax
      \else
%    \end{macrocode}
%    Otherwise we write a message in the transcript file,
%    \begin{macrocode}
        \@activated{##1}%
%    \end{macrocode}
%    and define |\normal@char|\m{char} to expand to the character in
%    its default state.
%    \begin{macrocode}
        \@namedef{normal@char\string##1}{##1}%
%    \end{macrocode}
%    If we are making the right quote active we need to change
%    |\pr@m@s| as well.
% \changes{babel-3.5a}{1995/03/10}{Added a check for right quote and
%    adapt \cs{pr@m@s} if necessary}
%    \begin{macrocode}
        \ifx##1'%
          \let\pr@m@s\bbl@pr@m@s
        \fi
%    \end{macrocode}
%    Now we set the lowercase code of the |~| equal to that of the
%    character to be made active and execute the rest of the code
%    inside a |\lowercase| `environment'.
%    \begin{macrocode}
        \lccode`~=`##1%
        \lowercase{%
%    \end{macrocode}
%    Make the character active and add it to |\dospecials| and
%    |\@sanitize|. 
%    \begin{macrocode}
          \catcode`~\active
          \expandafter\bbl@add@special
            \csname \string##1\endcsname
%    \end{macrocode}
%    Define the character to expand to 
%    \begin{center}
%    |\active@prefix| \m{char} |\active@char|\m{char}
%    \end{center}
%    (where |\active@char|\m{char} is \emph{one} control sequence!).
%    \begin{macrocode}
          \expandafter\gdef
            \expandafter~%
            \expandafter{%
            \expandafter\active@prefix\expandafter##1%
            \csname normal@char\string##1\endcsname}}%
%    \end{macrocode}
%    We define the first level expansion of |\active@char|\m{char} to
%    check the status of the |@safe@actives| flag. If it is set to
%    true we expand to the `normal' version of this character,
%    otherwise we call |\@active@char|\m{char}. 
%    \begin{macrocode}
        \@namedef{active@char\string##1}{%
          \if@safe@actives
            \bbl@afterelse\csname normal@char\string##1\endcsname
          \else
            \bbl@afterfi\csname user@active\string##1\endcsname
          \fi}%
%    \end{macrocode}
%    The next level of the code checks whether a user has defined a
%    shorthand for himself with this character. First we check for a
%    single character shorthand. If that doesn't exist we check for a
%    shorthand with an argument.
% \changes{babel~3.5d}{1995/07/02}{Skip the user-level active char
%    with argument if no shorthands with arguments were defined}
%    \begin{macrocode}
        \@namedef{user@active\string##1}{%
          \expandafter\ifx
          \csname \user@group @sh@\string##1@\endcsname
          \relax
            \bbl@afterelse\csname @sh@\string##1@sel\endcsname
              {user@active@arg\string##1}{language@active\string##1}%
          \else
            \bbl@afterfi\csname \user@group @sh@\string##1@\endcsname
          \fi}%
%    \end{macrocode}
%    When there is also no user-level shorthand with an argument we
%    will check whether there is a language defined shorthand for
%    this active character.
%    \begin{macrocode}
        \long\@namedef{user@active@arg\string##1}####1{%
          \expandafter\ifx
          \csname \user@group @sh@\string##1\string####1@\endcsname
          \relax
            \bbl@afterelse
            \csname language@active\string##1\endcsname####1%
          \else
            \bbl@afterfi
            \csname \user@group @sh@\string##1\string####1@%
            \endcsname
          \fi}%
%    \end{macrocode}
%    Like the shorthands that can be defined by the user, a language
%    definition file can also define shorthands with and without an
%    argument, so we need two more macros to check if they exist.
% \changes{babel~3.5d}{1995/07/02}{Skip the language-level active char
%    with argument if no shorthands with arguments were defined}
%    \begin{macrocode}
        \@namedef{language@active\string##1}{%
          \expandafter\ifx
          \csname \language@group @sh@\string##1@\endcsname
          \relax
            \bbl@afterelse\csname @sh@\string##1@sel\endcsname
              {language@active@arg\string##1}{system@active\string##1}%
          \else
            \bbl@afterfi
            \csname \language@group @sh@\string##1@\endcsname
          \fi}%
        \long\@namedef{language@active@arg\string##1}####1{%
          \expandafter\ifx
          \csname \language@group @sh@\string##1\string####1@\endcsname
          \relax
            \bbl@afterelse
            \csname system@active\string##1\endcsname####1%
          \else
            \bbl@afterfi
            \csname \language@group @sh@\string##1\string####1@%
            \endcsname
          \fi}%
%    \end{macrocode}
%    And the same goes for the system level.
%    \begin{macrocode}
        \@namedef{system@active\string##1}{%
          \expandafter\ifx
          \csname \system@group @sh@\string##1@\endcsname
          \relax
            \bbl@afterelse\csname @sh@\string##1@sel\endcsname
              {system@active@arg\string##1}{normal@char\string##1}%
          \else
            \bbl@afterfi\csname \system@group @sh@\string##1@\endcsname
          \fi}%
%    \end{macrocode}
%    When no shorthands were found the `normal' version of the active
%    character is inserted.
%    \begin{macrocode}
        \long\@namedef{system@active@arg\string##1}####1{%
          \expandafter\ifx
          \csname \system@group @sh@\string##1\string####1@\endcsname
          \relax
            \bbl@afterelse\csname normal@char\string##1\endcsname####1%
          \else
            \bbl@afterfi
            \csname \system@group @sh@\string##1\string####1@\endcsname
          \fi}%
        \fi}%
    }\x
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\active@prefix}
%    The comand |\active@prefix| which is used in the expansion of
%    active characters has a function similar to |\OT1-cmd| in that it
%    |\protect|s the active character whenever |\protect| is
%    \emph{not} |\@typeset@protect|.
% \changes{babel~3.5d}{1995/07/02}{\cs{@protected@cmd} has vanished
%    from \file{ltoutenc.dtx}}
%    \begin{macrocode}
\def\active@prefix#1{%
  \ifx\protect\@typeset@protect
  \else
    \bbl@afterfi\protect#1\@gobble
  \fi}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\if@safe@actives}
%    In some circumstances it is necessary to be able to change the
%    expansion of an active character on the fly. For this purpose the
%    switch |@safe@actives| is available. This setting of this switch
%    should be checked in the first level expansion of
%    |\active@char|\m{char}. 
%    \begin{macrocode}
\newif\if@safe@actives
\@safe@activesfalse
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\bbl@activate}
% \changes{babel~3.5a}{1995/02/11}{Added macro}
%
%    This macro takes one argument, like |\initiate@active@char|. The
%    macro is used to change the definition of an active character to
%    expand to |\active@char|\m{char} instead of
%    |\normal@char|\m{char}.
%    \begin{macrocode}
\def\bbl@activate#1{%
  \expandafter\def
  \expandafter#1\expandafter{%
    \expandafter\active@prefix
    \expandafter#1\csname active@char\string#1\endcsname}%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\bbl@deactivate}
% \changes{babel~3.5a}{1995/02/11}{Added macro}
%    This macro takes one argument, like |\Activate|. The macro
%    doesn't really make a character non-active; it changes its
%    definition to expand to |\normal@char|\m{char}.
%    \begin{macrocode}
\def\bbl@deactivate#1{%
  \expandafter\def
  \expandafter#1\expandafter{%
    \expandafter\active@prefix
    \expandafter#1\csname normal@char\string#1\endcsname}%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\bbl@firstcs}
%  \begin{macro}{\bbl@scndcs}
%    These macros have two arguments. They use one of their arguments
%    to build a control sequence from.
%    \begin{macrocode}
\def\bbl@firstcs#1#2{\csname#1\endcsname}
\def\bbl@scndcs#1#2{\csname#2\endcsname}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\declare@shorthand}
%    The command |\declare@shorthand| is used to declare a shorthand
%    on a certain level. It takes three arguments:
%    \begin{enumerate}
%    \item a name for the collection of shorthands, i.e. `system', or
%    `dutch';
%    \item the character (sequence) that makes up the shorthand,
%    i.e. |~| or |"a|;
%    \item the code to be executed when the shorthand is encountered.
%    \end{enumerate}
% \changes{babel~3.5d}{1995/07/02}{Make a `note' when a shorthand with
%    an argument is defined.}
%    \begin{macrocode}
\def\declare@shorthand#1#2{\@decl@short{#1}#2\@nil}
\def\@decl@short#1#2#3\@nil#4{%
  \def\tmp{#3}%
  \ifx\tmp\empty
    \expandafter\let\csname @sh@\string#2@sel\endcsname\bbl@scndcs
  \else
    \expandafter\let\csname @sh@\string#2@sel\endcsname\bbl@firstcs
  \fi
  \@namedef{#1@sh@\string#2\string#3@}{#4}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\textormath}
%    Some of the shorthands that will be declared by the language
%    definition files have to be useable in both text and mathmode. To
%    achieve this the helper macro |\textormath| is provided.
%    \begin{macrocode}
\def\textormath#1#2{%
  \ifmmode
    \bbl@afterelse#2%
  \else
    \bbl@afterfi#1%
  \fi}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\user@group}
%  \begin{macro}{\language@group}
%  \begin{macro}{\system@group}
%    The current concept of `shorthands' supports three levels or
%    groups of shorthands. For each level the name of the level or
%    group is stored in a macro. The default is to have no user group;
%    use language group `english' and have a system group called
%    `system'.
%    \begin{macrocode}
\def\user@group{}
\def\language@group{english}
\def\system@group{system}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\useshorthands}
%    This is the user level command to tell \LaTeX\ that user level
%    shorthands will be used in the document. It takes one argument,
%    the character that starts a shorthand.
%    \begin{macrocode}
\def\useshorthands#1{%
  \def\user@group{user}%
  \initiate@active@char{#1}%
  \bbl@activate{#1}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\defineshorthand}
%    Currently we only support one group of user level shorthands,
%    called `user'.
%    \begin{macrocode}
\def\defineshorthand{\declare@shorthand{user}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\languageshorthands}
%    A user level command to change the language from which shorthands
%    are used.
%    \begin{macrocode}
\def\languageshorthands#1{\def\language@group{#1}}
%    \end{macrocode}
%  \end{macro}
%
%    To prevent problems with constructs such as |\char"01A| when the
%    double quote is made active, we define a shorthand on
%    system level. 
% \changes{babel-3.5a}{1995/03/10}{Replaced 16 system shorthands to
%    deal with hex numbers by one}
%    \begin{macrocode}
\declare@shorthand{system}{"}{\csname normal@char\string"\endcsname}
%    \end{macrocode}
%
%    When the right quote is made active we need to take care of
%    handling it correctly in mathmode. Therefore we define a
%    shorthand at system level to make it expand to a non-active right
%    quote in textmode, but expand to its original definition in
%    mathmode. (Note that the right quote is `active' in mathmode
%    because of its mathcode.)
% \changes{babel-3.5a}{1995/03/10}{Added a system shorthand for the
%    right quote}
%    \begin{macrocode}
\declare@shorthand{system}{'}{%
  \textormath{\csname normal@char\string'\endcsname}%
             {\sp\bgroup\prim@s}}
%    \end{macrocode}
%
%  \begin{macro}{\bbl@pr@m@s}
% \changes{babel-3.5a}{1995/03/10}{Added macro}
%    One of the internal macros that are involved in substituting
%    |\prime| for each right quote in mathmode is |\pr@m@s|. This
%    checks if the next character is a right quote. When the right
%    quote is active, the definition of this macro needs to be adapted
%    to look for an active right quote.
%    \begin{macrocode}
\begingroup
  \catcode`\'\active\let'\relax
  \def\x{\endgroup
    \def\bbl@pr@m@s{%
      \ifx'\@let@token
        \expandafter\pr@@@s
      \else
        \ifx^\@let@token
          \expandafter\expandafter\expandafter\pr@@@t
        \else
          \egroup
        \fi
      \fi}%
    }
\x
%</core|shorthands>
%    \end{macrocode}
%  \end{macro}
%
%    Normally the |~| is active and expands to \verb*=\penalty\@M\ =.
%    When it is written to the \file{.aux} file is written
%    expanded. To prevent that and to be able to use the character |~|
%    as a start character for a shorthand, it is redefined here as a
%    one character shorthand on system level. To acheive that the
%    character |~| first needs to have character code 12 (other).
%    \begin{macrocode}
%<*core>
\catcode`~12\relax
\initiate@active@char{~}
\declare@shorthand{system}{~}{\penalty\@M\ }
\bbl@activate{~}
%    \end{macrocode}
%
%  \begin{macro}{\OT1dqpos}
%  \begin{macro}{\T1dqpos}
%    The position of the double quote character is different for the
%    OT1 and T1 encodings. It will later be selected using the
%    |\f@encoding| macro. Therefore we define two macros here to store
%    the position of the character in these encodings.
%    \begin{macrocode}
\expandafter\def\csname OT1dqpos\endcsname{127}
\expandafter\def\csname T1dqpos\endcsname{4}
%    \end{macrocode}
%    When the macor |\f@encoding| is undefined (as it is in plain
%    \TeX) we define it here to expand to \texttt{OT1}
%    \begin{macrocode}
\ifx\f@encoding\undefined
  \def\f@encoding{OT1}
\fi
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \subsection{Support for saving macro definitions}
%
%    To save the meaning of control sequences using |\babel@save|, we
%    use temporary control sequences.  To save hash table entries for
%    these control sequences, we don't use the name of the control
%    sequence to be saved to construct the temporary name.  Instead we
%    simply use the value of a counter, which is reset to zero each
%    time we begin to save new values.  This works well because we
%    release the saved meanings before we begin to save a new set of
%    control sequence meanings (see |\selectlanguage| and
%    |\originalTeX|).
%
%  \begin{macro}{\babel@savecnt}
% \changes{babel~3.2}{1991/11/10}{Added macro}
%  \begin{macro}{\babel@beginsave}
% \changes{babel~3.2}{1991/11/10}{Added macro}
%    The initialization of a new save cycle: reset the counter to
%    zero.
%    \begin{macrocode}
\def\babel@beginsave{\babel@savecnt\z@}
%    \end{macrocode}
%    Before it's forgotten, allocate the counter and initialize all.
%    \begin{macrocode}
\newcount\babel@savecnt
\babel@beginsave
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\babel@save}
% \changes{babel~3.2}{1991/11/10}{Added macro}
%    The macro |\babel@save|\meta{csname} saves the current meaning of
%    the control sequence \meta{csname} to
%    |\originalTeX|\footnote{\cs{originalTeX} has to be
%    expandable, i.\,e.\ you shouldn't let it to \cs{relax}.}.
%    To do this, we let the current meaning to a temporary control
%    sequence, the restore commands are appended to |\originalTeX| and
%    the counter is incremented.
% \changes{babel~3.2c}{1992/03/17}{missing backslash led to errors
%    when executing \cs{originalTeX}}
% \changes{babel~3.2d}{1992/07/02}{saving in \cs{babel@i} and
%    restoring from \cs{@babel@i} doesn't work very well...}
%    \begin{macrocode}
\def\babel@save#1{%
  \expandafter\let\csname babel@\number\babel@savecnt\endcsname #1\relax
  \begingroup
    \toks@\expandafter{\originalTeX \let#1=}%
    \edef\x{\endgroup
      \def\noexpand\originalTeX{\the\toks@ \expandafter\noexpand
         \csname babel@\number\babel@savecnt\endcsname\relax}}%
  \x
  \advance\babel@savecnt\@ne}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\babel@savevariable}
% \changes{babel~3.2}{1991/11/10}{Added macro}
%    The macro |\babel@savevariable|\meta{variable} saves the value of
%    the variable.  \meta{variable} can be anything allowed after the
%    |\the| primitive.
%    \begin{macrocode}
\def\babel@savevariable#1{\begingroup
    \toks@\expandafter{\originalTeX #1=}%
    \edef\x{\endgroup
      \def\noexpand\originalTeX{\the\toks@ \the#1\relax}}%
  \x}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\bbl@frenchspacing}
%  \begin{macro}{\bbl@nonfrenchspacing}
%    Some languages need to have |\frenchspacing| in effect. Others
%    don't want that. The command |\bbl@frenchspacing| switches it on
%    when it isn't already in effect and |\bbl@nonfrenchspacing|
%    switches it off if necessary.
%    \begin{macrocode}
\def\bbl@frenchspacing{%
  \ifnum\the\sfcode`\.=\@m
    \let\bbl@nonfrenchspacing\relax
  \else
    \frenchspacing
    \let\bbl@nonfrenchspacing\nonfrenchspacing
  \fi}
\let\bbl@nonfrenchspacing\nonfrenchspacing
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \subsection{Support for extending macros}
%
%  \begin{macro}{\addto}
%    For each language four control sequences have to be defined that
%    control the language-specific definitions. To be able to add
%    something to these macro once they have been defined the macro
%    |\addto| is introduced. It takes two arguments, a \meta{control
%    sequence} and \TeX-code to be added to the \meta{control
%    sequence}.
%
%    If the \meta{control sequence} has not been defined before it is
%    defined now.
% \changes{babel~3.1}{1991/11/05}{Added macro}
% \changes{babel~3.4}{1994/02/04}{Changed to use toks register}
%    \begin{macrocode}
\def\addto#1#2{%
  \ifx#1\undefined
    \def#1{#2}
  \else
%    \end{macrocode}
%    Otherwise the replacement text for the \meta{control sequence} is
%    expanded and stored in a token register, together with the
%    \TeX-code to be added.  Finally the \meta{control sequence} is
%    \emph{re}defined, using the contents of the token register.
%    \begin{macrocode}
  {\toks@\expandafter{#1#2}%
   \xdef#1{\the\toks@}}%
  \fi
}
%    \end{macrocode}
%  \end{macro}
%
% \subsection{Macros common to a number of languages}
%
%  \begin{macro}{\allowhyphens}
% \changes{babel~3.2b}{1992/02/16}{Moved macro from language
%    definition files}
%    This macro makes hyphenation possible. Basically its definition
%    is nothing more than |\nobreak| |\hskip| \texttt{0pt plus
%    0pt}\footnote{\TeX\ begins and ends a word for hyphenation at a
%    glue node. The penalty prevents a linebreak at this glue node.}.
%    \begin{macrocode}
\def\allowhyphens{\penalty\@M \hskip\z@skip}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\set@low@box}
% \changes{babel~3.2b}{1992/02/16}{Moved macro from language
%    definition files}
%    The following macro is used to lower quotes to the same level as
%    the comma.  It prepares its argument in box register~0.
%    \begin{macrocode}
\def\set@low@box#1{\setbox\tw@\hbox{,}\setbox\z@\hbox{#1}%
    \dimen\z@\ht\z@ \advance\dimen\z@ -\ht\tw@%
    \setbox\z@\hbox{\lower\dimen\z@ \box\z@}\ht\z@\ht\tw@ \dp\z@\dp\tw@}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\save@sf@q}
% \changes{babel~3.2b}{1992/02/16}{Moved macro from language
%    definition files}
%    The macro |\save@sf@q| is used to save and reset the current
%    space factor.
%    \begin{macrocode}
\def\save@sf@q#1{{\ifhmode
    \edef\@SF{\spacefactor\the\spacefactor}\else
    \let\@SF\empty \fi \leavevmode #1\@SF}}
%    \end{macrocode}
%  \end{macro}
%
% \changes{babel~3.5c}{1995/06/14}{Repaired a typo (itlaic, PR1652)}
%
%  \subsection{Making glyphs available}
%
%    The file \file{\filename}\footnote{The file described in this
%    section has version number \fileversion, and was last revised on
%    \filedate.} makes a number of glyphs available that either do not
%    exist in the \texttt{OT1} encoding and have to be `faked', or
%    that are not accessible through \file{T1enc.def}.
%
%  \subsection{Quotation marks}
%
%  \begin{macro}{\quotedblbase}
%    In the \texttt{T1} encoding the opening double quote at the
%    baseline is available as a separate character, accessible via
%    |\quotedblbase|. In the \texttt{OT1} encoding it is not
%    available, therefore we make it available by lowering the normal
%    open quote character to the baseline.
%    \begin{macrocode}
\ProvideTextCommand{\quotedblbase}{OT1}{%
  \save@sf@q{\set@low@box{\textquotedblright\/}%
    \box\z@\kern-.04em\allowhyphens}}
%    \end{macrocode}
%    Make sure that when an encoding other then \texttt{OT1} ot
%    \texttt{T1} is used this glyph can still be typeset.
%    \begin{macrocode}
\ProvideTextCommandDefault{\quotedblbase}{%
  \UseTextSymbol{OT1}{\quotedblbase}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\quotesinglbase}
%    We also need the single quote character at the baseline.
%    \begin{macrocode}
\ProvideTextCommand{\quotesinglbase}{OT1}{%
  \save@sf@q{\set@low@box{\textquoteright\/}%
    \box\z@\kern-.04em\allowhyphens}}
%    \end{macrocode}
%    Make sure that when an encoding other then \texttt{OT1} ot
%    \texttt{T1} is used this glyph can still be typeset.
%    \begin{macrocode}
\ProvideTextCommandDefault{\quotesinglbase}{%
  \UseTextSymbol{OT1}{\quotesinglbase}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\guillemotleft}
%  \begin{macro}{\guillemotright}
%    The guillemot characters are not available in \texttt{OT1}
%    encoding. They are faked.
%    \begin{macrocode}
\ProvideTextCommand{\guillemotleft}{OT1}{%
  \ifmmode
    \ll
  \else
    \save@sf@q{\penalty\@M
      \raise.2ex\hbox{$\scriptscriptstyle\ll$}\allowhyphens}%
  \fi}
\ProvideTextCommand{\guillemotright}{OT1}{%
  \ifmmode
    \gg
  \else
    \save@sf@q{\penalty\@M
      \raise.2ex\hbox{$\scriptscriptstyle\gg$}\allowhyphens}%
  \fi}
%    \end{macrocode}
%    Make sure that when an encoding other then \texttt{OT1} ot
%    \texttt{T1} is used these glyphs can still be typeset.
%    \begin{macrocode}
\ProvideTextCommandDefault{\guillemotleft}{%
  \UseTextSymbol{OT1}{\guillemotleft}}
\ProvideTextCommandDefault{\guillemotright}{%
  \UseTextSymbol{OT1}{\guillemotright}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\guilsinglleft}
%  \begin{macro}{\guilsinglright}
%    The single guillemots are not available in \texttt{OT1}
%    encoding. They are faked.
%    \begin{macrocode}
\ProvideTextCommand{\guilsinglleft}{OT1}{%
  \ifmmode
    <%
  \else
    \save@sf@q{\penalty\@M
      \raise.2ex\hbox{$\scriptscriptstyle<$}\allowhyphens}%
  \fi}
\ProvideTextCommand{\guilsinglright}{OT1}{%
  \ifmmode
    >%
  \else
    \save@sf@q{\penalty\@M
      \raise.2ex\hbox{$\scriptscriptstyle>$}\allowhyphens}%
  \fi}
%    \end{macrocode}
%    Make sure that when an encoding other then \texttt{OT1} ot
%    \texttt{T1} is used these glyphs can still be typeset.
%    \begin{macrocode}
\ProvideTextCommandDefault{\guilsinglleft}{%
  \UseTextSymbol{OT1}{\guilsinglleft}}
\ProvideTextCommandDefault{\guilsinglright}{%
  \UseTextSymbol{OT1}{\guilsinglright}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \subsection{Letters}
%
%  \begin{macro}{\ij}
%  \begin{macro}{\IJ}
%    The dutch language uses the letter `ij'. It is available in
%    \texttt{T1} encoded fonts, but not in the \texttt{OT1} encoded
%    fonts. Therefore we fake it for the \texttt{OT1} encoding.
% \changes{dutch-3.7a}{1995/02/04}{Changed the kerning in the faked ij
%    to match the dc-version of it}
%    \begin{macrocode}
\DeclareTextCommand{\ij}{OT1}{%
  \allowhyphens i\kern-0.02em j\allowhyphens}
\DeclareTextCommand{\IJ}{OT1}{%
  \allowhyphens I\kern-0.02em J\allowhyphens}
\DeclareTextCommand{\ij}{T1}{\char188}
\DeclareTextCommand{\IJ}{T1}{\char156}
%    \end{macrocode}
%    Make sure that when an encoding other then \texttt{OT1} or
%    \texttt{T1} is used these glyphs can still be typeset.
%    \begin{macrocode}
\ProvideTextCommandDefault{\ij}{%
  \UseTextSymbol{OT1}{\ij}}
\ProvideTextCommandDefault{\IJ}{%
  \UseTextSymbol{OT1}{\IJ}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\dj}
%  \begin{macro}{\DJ}
%    The croatian language needs the letters |\dj| and |\DJ|; they are
%    availabel in the \texttt{T1} encoding, but not in the
%    \texttt{OT1} encoding by default.
%
%    Some code to construct these glyphs for the \texttt{OT1} encoding
%    was made available to my by Stipcevic Mario,
%    (\texttt{stipcevic@olimp.irb.hr}).
%    \begin{macrocode}
\def\crrtic@{\hrule height0.1ex width0.3em}
\def\crttic@{\hrule height0.1ex width0.33em}
%
\def\dj@@#1#2#3{%
  \leavevmode\kern#1em\raise#2ex\vbox{\crrtic@}\kern#3em}
\def\dj@{%
  \ifcase\the\fam
  \dj@@{0.25}{1.28}{-0.50}\or %roman
  \dj@@{0.25}{1.28}{-0.50}\or %roman
  \dj@@{0.25}{1.28}{-0.50}\or %roman
  \dj@@{0.25}{1.28}{-0.50}\or %roman
  \dj@@{0.33}{1.29}{-0.63}\or %italic
  \dj@@{0.35}{1.30}{-0.65}\or %slanted
  \dj@@{0.25}{1.25}{-0.55}\or %bold
  \dj@@{0.25}{1.15}{-0.55}\or %tt
  \dj@@{-0.04}{0.72}{-0.26}\or%csc
  \dj@@{0.35}{1.30}{-0.65} %slanted
  \else\dj@@{0.25}{1.25}{-0.55}\fi}%bold
%
\def\DJ@@#1#2#3{%
  \leavevmode\kern#1em\raise#2ex\vbox{\crttic@}\kern#3em}
\def\DJ@{%
  \ifcase\the\fam
  \DJ@@{0.11}{0.92}{-0.36}\or
  \DJ@@{0.11}{0.92}{-0.36}\or
  \DJ@@{0.11}{0.92}{-0.36}\or
  \DJ@@{0.11}{0.92}{-0.36}\or
  \DJ@@{0.25}{0.92}{-0.50}\or
  \DJ@@{0.22}{0.92}{-0.47}\or
  \DJ@@{0.09}{0.90}{-0.34}\or
  \DJ@@{0.02}{0.85}{-0.27}\or
  \DJ@@{0.1}{0.86}{-0.35}\or
  \DJ@@{0.22}{0.92}{-0.47}\else
  \DJ@@{0.09}{0.90}{-0.34}\fi}
\DeclareTextCommand{\dj}{OT1}{\dj@ d}
\DeclareTextCommand{\DJ}{OT1}{\DJ@ D}
%    \end{macrocode}
%    Make sure that when an encoding other then \texttt{OT1} or
%    \texttt{T1} is used these glyphs can still be typeset.
%    \begin{macrocode}
\ProvideTextCommandDefault{\dj}{%
  \UseTextSymbol{OT1}{\dj}}
\ProvideTextCommandDefault{\DJ}{%
  \UseTextSymbol{OT1}{\DJ}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \subsection{Shorthands for quotation marks}
%
%    Shorthands are provided for a number of different quotation
%    marks, which make them useable both outside and inside mathmode.
%
%  \begin{macro}{\glq}
%  \begin{macro}{\grq}
%    The `german' single quotes.
%    \begin{macrocode}
\DeclareRobustCommand{\glq}{%
  \ifmmode\mbox{\quotesinglbase}\else\quotesinglbase\fi}
\DeclareRobustCommand{\grq}{%
  \ifmmode\mbox{\textquoteleft}\else\textquoteleft\fi}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\glqq}
%  \begin{macro}{\grqq}
%    The `german' double quotes.
%    \begin{macrocode}
\DeclareRobustCommand{\glqq}{%
  \ifmmode\mbox{\quotedblbase}\else\quotedblbase\fi}
\DeclareRobustCommand{\grqq}{%
  \ifmmode\mbox{\textquotedblleft}\else\textquotedblleft\fi}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\flq}
%  \begin{macro}{\frq}
%    The `french' single quillemets.
%    \begin{macrocode}
\DeclareRobustCommand{\flq}{%
  \ifmmode\mbox{\quilsinglleft}\else\quilsinglleft\fi}
\DeclareRobustCommand{\frq}{%
  \ifmmode\mbox{\quilsinglright}\else\quilsinglright\fi}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\flqq}
%  \begin{macro}{\frqq}
%    The `french' double quillemets.
%    \begin{macrocode}
\DeclareRobustCommand{\flqq}{%
  \ifmmode\mbox{\quillemotleft}\else\quillemotleft\fi}
\DeclareRobustCommand{\frqq}{%
  \ifmmode\mbox{\quillemotright}\else\quillemotright\fi}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \subsection{Umlauts and trema's}
%
%    The command |\"| needs to have a different effect for different
%    languages. For German for instance, the `umlaut' should be
%    positioned lower than the default position for placing it over
%    the letters a, o, u, A, O and U. When placed over an e, i, E or I
%    it can retain its normal position. For Dutch the same glyph is
%    always placed in the lower position.
%
%  \begin{macro}{\umlauthigh}
%  \begin{macro}{\umlautlow}
%    To be able to provide both positions of |\"| we provide two
%    commands to switch the positioning, the default will be
%    |\umlauthigh| (the normal positioning).
%    \begin{macrocode}
\def\umlauthigh{%
  \def\bbl@umlauta##1{{%
      \expandafter\accent\csname\f@encoding dqpos\endcsname
      ##1\allowhyphens}}%
  \let\bbl@umlaute\bbl@umlauta}
\def\umlautlow{%
  \def\bbl@umlauta{\protect\lower@umlaut}}
\def\umlautelow{%
  \def\bbl@umlaute{\protect\lower@umlaut}}
\umlauthigh
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\lower@umlaut}
%    The command |\lower@umlaut| is used to position the |\"| closer
%    the the letter.
%
%    We want the umlaut character lowered, nearer to the letter. To do
%    this we need an extra \meta{dimen} register.
%    \begin{macrocode}
\expandafter\ifx\csname U@D\endcsname\relax
  \csname newdimen\endcsname\U@D
\fi
%    \end{macrocode}
%    The following code fools \TeX's \texttt{make\_accent} procedure
%    about the current x-height of the font to force another placement
%    of the umlaut character.
%    \begin{macrocode}
\def\lower@umlaut#1{%
%    \end{macrocode}
%    First we have to save the current x-height of the font, because
%    we'll change this font dimension and this is always done
%    globally.
%    \begin{macrocode}
  {\U@D 1ex%
%    \end{macrocode}
%    Then we compute the new x-height in such a way that the umlaut
%    character is lowered to the base character.  The value of
%    \texttt{.45ex} depends on the \MF\ parameters with which the
%    fonts were built.  (Just try out, which value will look best.)
%    \begin{macrocode}
  {\setbox\z@\hbox{%
      \expandafter\char\csname\f@encoding dqpos\endcsname}%
    \dimen@ -.45ex\advance\dimen@\ht\z@
%    \end{macrocode}
%    If the new x-height is too low, it is not changed.
%    \begin{macrocode}
  \ifdim 1ex<\dimen@ \fontdimen5\font\dimen@ \fi}%
%    \end{macrocode}
%    Finally we call the |\accent| primitive, reset the old x-height
%    and insert the base character in the argument.
%    \begin{macrocode}
  \expandafter\accent\csname\f@encoding dqpos\endcsname
  \fontdimen5\font\U@D #1}}
%    \end{macrocode}
%  \end{macro}
%
%    For all vowels we declare |\"| to be a composite command which
%    uses |\bbl@umlauta| or|\bbl@umlaute| to position the umlaut
%    character. We need to be sure that these definitions override the
%    ones that are provided when the package \textsf{fontenc} with
%    option \textsf{OT1} is used. Therefore these declarations are
%    postponed until the beginning of the document.
%    \begin{macrocode}
\AtBeginDocument{%
  \DeclareTextCompositeCommand{\"}{OT1}{a}{\bbl@umlauta{a}}%
  \DeclareTextCompositeCommand{\"}{OT1}{e}{\bbl@umlaute{e}}%
  \DeclareTextCompositeCommand{\"}{OT1}{i}{\bbl@umlaute{\i}}%
  \DeclareTextCompositeCommand{\"}{OT1}{\i}{\bbl@umlaute{\i}}%
  \DeclareTextCompositeCommand{\"}{OT1}{o}{\bbl@umlauta{o}}%
  \DeclareTextCompositeCommand{\"}{OT1}{u}{\bbl@umlauta{u}}%
  \DeclareTextCompositeCommand{\"}{OT1}{A}{\bbl@umlauta{A}}%
  \DeclareTextCompositeCommand{\"}{OT1}{E}{\bbl@umlaute{E}}%
  \DeclareTextCompositeCommand{\"}{OT1}{I}{\bbl@umlaute{I}}%
  \DeclareTextCompositeCommand{\"}{OT1}{O}{\bbl@umlauta{O}}%
  \DeclareTextCompositeCommand{\"}{OT1}{U}{\bbl@umlauta{U}}%
}
%    \end{macrocode}
%
% \subsection{The redefinition of the style commands}
%
%    The rest of the code in this file can only be processed by
%    \LaTeX, so we check the current format. If it is plain \TeX,
%    processing should stop here. But, because of the need to limit
%    the scope of the definition of |\format|, a macro that is used
%    locally in the following |\if|~statement, this comparison is done
%    inside a group. To prevent \TeX\ from complaining about an
%    unclosed group, the processing of the command |\endinput| is
%    deferred until after the group is closed. This is accomplished by
%    the command |\aftergroup|.
%    \begin{macrocode}
{\def\format{lplain}
\ifx\fmtname\format
\else
  \def\format{LaTeX2e}
  \ifx\fmtname\format
  \else
    \aftergroup\endinput
  \fi
\fi}
%    \end{macrocode}
%
%    Now that we're sure that the code is seen by \LaTeX\ only, we
%    have to find out what the main (primary) document style is
%    because we want to redefine some macros.  This is only necessary
%    for releases of \LaTeX\ dated before december~1991. Therefore
%    this part of the code can optionally be included in
%    \file{babel.def} by specifying the \texttt{docstrip} option
%    \texttt{names}.
%    \begin{macrocode}
%<*names>
%    \end{macrocode}
%
%    The standard styles can be distinguished by checking whether some
%    macros are defined. In table~\ref{styles} an overview is given of
%    the macros that can be used for this purpose.
%  \begin{table}[htb]
%  \begin{center}
% \DeleteShortVerb{\|}
%  \begin{tabular}{|lcp{8cm}|}
%   \hline
%   article         & : & both the \verb+\chapter+ and \verb+\opening+
%                         macros are undefined\\
%   report and book & : & the \verb+\chapter+ macro is defined and
%                         the \verb+\opening+ is undefined\\
%   letter          & : & the \verb+\chapter+ macro is undefined and
%                         the \verb+\opening+ is defined\\
%   \hline
%  \end{tabular}
% \caption{How to determine the main document style}\label{styles}
% \MakeShortVerb{\|}
%  \end{center}
%  \end{table}
%
%    \noindent The macros that have to be redefined for the
%    \texttt{report} and \texttt{book} document styles happen to be
%    the same, so there is no need to distinguish between those two
%    styles.
%
%  \begin{macro}{\doc@style}
%    First a parameter |\doc@style| is defined to identify the current
%    document style. This parameter might have been defined by a
%    document style that already uses macros instead of hard-wired
%    texts, such as \file{artikel1.sty}~\cite{BEP}, so the existence of
%    |\doc@style| is checked. If this macro is undefined, i.\,e., if
%    the document style is unknown and could therefore contain
%    hard-wired texts, |\doc@style| is defined to the default
%    value~`0'.
% \changes{babel~3.0d}{1991/10/29}{Removed use of \cs{@ifundefined}}
%    \begin{macrocode}
\ifx\undefined\doc@style
  \def\doc@style{0}%
%    \end{macrocode}
%    This parameter is defined in the following \texttt{if}
%    construction (see table~\ref{styles}):
%
%    \begin{macrocode}
  \ifx\undefined\opening
    \ifx\undefined\chapter
      \def\doc@style{1}%
    \else
      \def\doc@style{2}%
    \fi
  \else
    \def\doc@style{3}%
  \fi%
\fi%
%    \end{macrocode}
%  \end{macro}
%
% \changes{babel~3.1}{1991/11/05}{Removed definition of
%    \cs{if@restonecol}}
%
%    \subsubsection{Redefinition of macros}
%
%    Now here comes the real work: we start to redefine things and
%    replace hard-wired texts by macros. These redefinitions should be
%    carried out conditionally, in case it has already been done.
%
%    For the \texttt{figure} and \texttt{table} environments we have
%    in all styles:
%    \begin{macrocode}
\@ifundefined{figurename}{\def\fnum@figure{\figurename{} \thefigure}}{}
\@ifundefined{tablename}{\def\fnum@table{\tablename{} \thetable}}{}
%    \end{macrocode}
%
%    The rest of the macros have to be treated differently for each
%    style.  When |\doc@style| still has its default value nothing
%    needs to be done.
%    \begin{macrocode}
\ifcase \doc@style\relax
\or
%    \end{macrocode}
%
%    This means that \file{babel.def} is read after the
%    \texttt{article} style, where no |\chapter| and |\opening|
%    commands are defined\footnote{A fact that was pointed out to me
%    by Nico Poppelier and was already used in Piet van Oostrum's
%    document style option~\texttt{nl}.}.
%
%    First we have the |\tableofcontents|,
%    |\listoffigures| and |\listoftables|:
%    \begin{macrocode}
\@ifundefined{contentsname}%
    {\def\tableofcontents{\section*{\contentsname\@mkboth
          {\uppercase{\contentsname}}{\uppercase{\contentsname}}}%
      \@starttoc{toc}}}{}

\@ifundefined{listfigurename}%
    {\def\listoffigures{\section*{\listfigurename\@mkboth
          {\uppercase{\listfigurename}}{\uppercase{\listfigurename}}}
     \@starttoc{lof}}}{}

\@ifundefined{listtablename}%
    {\def\listoftables{\section*{\listtablename\@mkboth
          {\uppercase{\listtablename}}{\uppercase{\listtablename}}}
      \@starttoc{lot}}}{}
%    \end{macrocode}
%
% Then the |\thebibliography| and |\theindex| environments.
%
%    \begin{macrocode}
\@ifundefined{refname}%
    {\def\thebibliography#1{\section*{\refname
      \@mkboth{\uppercase{\refname}}{\uppercase{\refname}}}%
      \list{[\arabic{enumi}]}{\settowidth\labelwidth{[#1]}%
        \leftmargin\labelwidth
        \advance\leftmargin\labelsep
        \usecounter{enumi}}%
        \def\newblock{\hskip.11em plus.33em minus.07em}%
        \sloppy\clubpenalty4000\widowpenalty\clubpenalty
        \sfcode`\.=1000\relax}}{}

\@ifundefined{indexname}%
    {\def\theindex{\@restonecoltrue\if@twocolumn\@restonecolfalse\fi
     \columnseprule \z@
     \columnsep 35pt\twocolumn[\section*{\indexname}]%
       \@mkboth{\uppercase{\indexname}}{\uppercase{\indexname}}%
       \thispagestyle{plain}%
       \parskip\z@ plus.3pt\parindent\z@\let\item\@idxitem}}{}
%    \end{macrocode}
%
% The |abstract| environment:
%
%    \begin{macrocode}
\@ifundefined{abstractname}%
    {\def\abstract{\if@twocolumn
    \section*{\abstractname}%
    \else \small
    \begin{center}%
    {\bf \abstractname\vspace{-.5em}\vspace{\z@}}%
    \end{center}%
    \quotation
    \fi}}{}
%    \end{macrocode}
%
% And last but not least, the macro |\part|:
%
%    \begin{macrocode}
\@ifundefined{partname}%
{\def\@part[#1]#2{\ifnum \c@secnumdepth >\m@ne
        \refstepcounter{part}%
        \addcontentsline{toc}{part}{\thepart
        \hspace{1em}#1}\else
      \addcontentsline{toc}{part}{#1}\fi
   {\parindent\z@ \raggedright
    \ifnum \c@secnumdepth >\m@ne
      \Large \bf \partname{} \thepart
      \par \nobreak
    \fi
    \huge \bf
    #2\markboth{}{}\par}%
    \nobreak
    \vskip 3ex\@afterheading}%
}{}
%    \end{macrocode}
%
%    This is all that needs to be done for the \texttt{article} style.
%
%    \begin{macrocode}
\or
%    \end{macrocode}
%
%    The next case is formed by the two styles \texttt{book} and
%    \texttt{report}.  Basically we have to do the same as for the
%    \texttt{article} style, except now we must also change the
%    |\chapter| command.
%
%    The tables of contents, figures and tables:
%    \begin{macrocode}
\@ifundefined{contentsname}%
    {\def\tableofcontents{\@restonecolfalse
      \if@twocolumn\@restonecoltrue\onecolumn
      \fi\chapter*{\contentsname\@mkboth
          {\uppercase{\contentsname}}{\uppercase{\contentsname}}}%
      \@starttoc{toc}%
      \csname if@restonecol\endcsname\twocolumn
      \csname fi\endcsname}}{}

\@ifundefined{listfigurename}
    {\def\listoffigures{\@restonecolfalse
      \if@twocolumn\@restonecoltrue\onecolumn
      \fi\chapter*{\listfigurename\@mkboth
          {\uppercase{\listfigurename}}{\uppercase{\listfigurename}}}%
      \@starttoc{lof}%
      \csname if@restonecol\endcsname\twocolumn
      \csname fi\endcsname}}{}

\@ifundefined{listtablename}
    {\def\listoftables{\@restonecolfalse
      \if@twocolumn\@restonecoltrue\onecolumn
      \fi\chapter*{\listtablename\@mkboth
          {\uppercase{\listtablename}}{\uppercase{\listtablename}}}%
      \@starttoc{lot}%
      \csname if@restonecol\endcsname\twocolumn
      \csname fi\endcsname}}{}
%    \end{macrocode}
%
%    Again, the |bibliography| and |index| environments; notice that
%    in this case we use |\bibname| instead of |\refname| as in the
%    definitions for the \texttt{article} style.  The reason for this
%    is that in the \texttt{article} document style the term
%    `References' is used in the definition of |\thebibliography|. In
%    the \texttt{report} and \texttt{book} document styles the term
%    `Bibliography' is used.
%    \begin{macrocode}
\@ifundefined{bibname}
    {\def\thebibliography#1{\chapter*{\bibname
     \@mkboth{\uppercase{\bibname}}{\uppercase{\bibname}}}%
     \list{[\arabic{enumi}]}{\settowidth\labelwidth{[#1]}%
     \leftmargin\labelwidth \advance\leftmargin\labelsep
     \usecounter{enumi}}%
     \def\newblock{\hskip.11em plus.33em minus.07em}%
     \sloppy\clubpenalty4000\widowpenalty\clubpenalty
     \sfcode`\.=1000\relax}}{}

\@ifundefined{indexname}
    {\def\theindex{\@restonecoltrue\if@twocolumn\@restonecolfalse\fi
    \columnseprule \z@
    \columnsep 35pt\twocolumn[\@makeschapterhead{\indexname}]%
      \@mkboth{\uppercase{\indexname}}{\uppercase{\indexname}}%
    \thispagestyle{plain}%
    \parskip\z@ plus.3pt\parindent\z@ \let\item\@idxitem}}{}
%    \end{macrocode}
%
% Here is the |abstract| environment:
%    \begin{macrocode}
\@ifundefined{abstractname}
    {\def\abstract{\titlepage
    \null\vfil
    \begin{center}%
    {\bf \abstractname}%
    \end{center}}}{}
%    \end{macrocode}
%
%     And last but not least the |\chapter|, |\appendix| and
%    |\part| macros.
%    \begin{macrocode}
\@ifundefined{chaptername}{\def\@chapapp{\chaptername}}{}
%
\@ifundefined{appendixname}
    {\def\appendix{\par
      \setcounter{chapter}{0}%
      \setcounter{section}{0}%
      \def\@chapapp{\appendixname}%
      \def\thechapter{\Alph{chapter}}}}{}
%
\@ifundefined{partname}
    {\def\@part[#1]#2{\ifnum \c@secnumdepth >-2\relax
            \refstepcounter{part}%
            \addcontentsline{toc}{part}{\thepart
            \hspace{1em}#1}\else
            \addcontentsline{toc}{part}{#1}\fi
       \markboth{}{}%
       {\centering
        \ifnum \c@secnumdepth >-2\relax
          \huge\bf \partname{} \thepart
        \par
        \vskip 20pt \fi
        \Huge \bf
        #1\par}\@endpart}}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
\or
%    \end{macrocode}
%
%    Now we address the case where \file{babel.def} is read after the
%    \texttt{letter} style. The \texttt{letter} document style
%    defines the macro |\opening| and some other macros that are
%    specific to \texttt{letter}. This means that we have to redefine
%    other macros, compared to the previous two cases.
%
%    First two macros for the material at the end of a letter, the
%    |\cc| and |\encl| macros.
%    \begin{macrocode}
\@ifundefined{ccname}%
    {\def\cc#1{\par\noindent
     \parbox[t]{\textwidth}%
     {\@hangfrom{\rm \ccname : }\ignorespaces #1\strut}\par}}{}

\@ifundefined{enclname}%
    {\def\encl#1{\par\noindent
     \parbox[t]{\textwidth}%
     {\@hangfrom{\rm \enclname : }\ignorespaces #1\strut}\par}}{}
%    \end{macrocode}
%
%    The last thing we have to do here is to redefine the
%    \texttt{headings} pagestyle:
% \changes{babel~3.3}{1993/07/11}{\cs{headpagename} should be
%    \cs{pagename}}
%    \begin{macrocode}
\@ifundefined{headtoname}
    {\def\ps@headings{%
        \def\@oddhead{\sl \headtoname{} \ignorespaces\toname \hfil
                      \@date \hfil \pagename{} \thepage}%
        \def\@oddfoot{}}}{}
%    \end{macrocode}
%
%    This was the last of the four standard document styles, so if
%    |\doc@style| has another value we do nothing and just close the
%    \texttt{if} construction.
%    \begin{macrocode}
\fi
%    \end{macrocode}
%    Here ends the code that can be optionally included when a version
%    of \LaTeX\ is in use that is dated \emph{before} december~1991.
%    \begin{macrocode}
%</names>
%</core>
%    \end{macrocode}
%
% \subsection{Cross referencing macros}
%
%    The \LaTeX\ book states:
%  \begin{quote}
%    The \emph{key} argument is any sequence of letters, digits, and
%    punctuation symbols; upper- and lowercase letters are regarded as
%    different.
%  \end{quote}
%    When the above quote should still be true when a document is
%    typeset in a language that has active characters, special care
%    has to be taken of the category codes of these characters when
%    they appear in an argument of the cross referencing macros.
%
%    When a cross referencing command processes its argument, all
%    tokens in this argument should be character tokens with category
%    `letter' or `other'.
%
%    The only way to accomplish this in most cases is to use the trick
%    described in the \TeX book~\cite{DEK} (Appendix~D, page~382).
%    The primitive |\meaning| applied to a token expands to the
%    current meaning of this token.  For example, `|\meaning\A|' with
%    |\A| defined as `|\def\A#1{\B}|' expands to the characters
%    `|macro:#1->\B|' with all category codes set to `other' or
%    `space'.
%
%  \begin{macro}{\babel@sanitize@arg}
%    To call a macro with a `sanitized' argument, instead of |\A{\B}|
%    one would write |\babel@sanitize@arg{\A}{\B}|.  (But be careful,
%    this macro is not fully expandable!)
%    \begin{macrocode}
%tmp%\long\def\babel@sanitize@arg#1#2{\bgroup\def\@tempa{#2}%
%tmp%  \expandafter\babel@strip@meaning\meaning\@tempa\relax{#1}}
%tmp%\def\babel@strip@meaning#1->#2\relax#3{\egroup #3{#2}}
%    \end{macrocode}
%  \end{macro}
%
%    To redefine a command, we save the old meaning of the macro.
%    Then we redefine it to call the original macro with the
%    `sanitized' argument.  The reason why we do it this way is that
%    we don't want to redefine the \LaTeX\ macros completely incase
%    their definitions change (they have changed in the past).
%
%  \begin{macro}{\label}
%    The |\label| macro is one of the cross referencing macros
%    affected. First we save its original definition.
%    \begin{macrocode}
%tmp%\let\LTX@label=\label
%    \end{macrocode}
%    Then the macro |label| is redefined.
%    \begin{macrocode}
%tmp%\def\label#1{\babel@sanitize@arg\LTX@label{#1}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\newlabel}
%    The macro |\label| writes a line with a |\newlabel| command
%    into the |.aux| file to define labels.
%    \begin{macrocode}
%<*core|shorthands>
\let\bbl@newlabel\newlabel
\def\newlabel#1#2{%
  \@safe@activestrue\bbl@newlabel{#1}{#2}\@safe@activesfalse}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@testdef}
%    An internal \LaTeX\ macro used to test if the labels that have
%    been written on the |.aux| file have changed.  It is called by
%    the |\enddocument| macro.
% \changes{babel~3.4g}{1994/08/30}{Moved the \cs{def} inside the
%    macrocode environment}
%    \begin{macrocode}
\let\bbl@@testdef\@testdef
\def\@testdef#1#2#3{%
  \@safe@activestrue\bbl@@testdef{#1}{#2}{#3}\@safe@activesfalse}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ref}
%  \begin{macro}{\pageref}
%    The same holds for the macro |\ref| that references a label
%    and |\pageref| to reference a page. While we change these macros,
%    we make them robust as well to prevent problems when they should
%    become expanded at the wrong moment.
% \changes{babel~3.5b}{1995/03/07}{Made \cs{ref} and \cs{pageref}
%    robust (PR1353)}
% \changes{babel~3.5d}{1995/07/04}{use a different control sequence
%    while making \cs{ref} and \cs{pageref} robust}
%    \begin{macrocode}
\let\bbl@ref\ref
\edef\ref{\noexpand\protect
  \expandafter\noexpand\csname bblref \endcsname}
\expandafter\def\csname bblref \endcsname#1{%
  \@safe@activestrue\bbl@ref{#1}\@safe@activesfalse}
%    \end{macrocode}
%    \begin{macrocode}
\let\bbl@pageref\pageref
\edef\pageref{\noexpand\protect
  \expandafter\noexpand\csname bblpageref \endcsname}
\expandafter\def\csname bblpageref \endcsname#1{%
  \@safe@activestrue\bbl@pageref{#1}\@safe@activesfalse}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\@citex}
%    The macro used to cite from a bibliography, |\cite| uses an
%    internal macro, |\@citex|.
%    It is this internal macro that picks up the argument,
%    so we redefine this internal macro and leave |\cite| alone.
%    \begin{macrocode}
%tmp%\let\bbl@@citex\@citex
%tmp%\def\@citex[#1]#2{\babel@sanitize@arg{\bbl@@citex[#1]}{#2}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\nocite}
%    The macro |\nocite| which is used to instruct BiB\TeX\ to
%    extract uncited references from the database.
%    \begin{macrocode}
%tmp%\let\bbl@nocite\nocite
%tmp%\def\nocite#1{\babel@sanitize@arg\bbl@nocite{#1}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\bibcite}
%    The macro that is used in the |.aux| file to define citation
%    labels.
%    \begin{macrocode}
%tmp%\let\bbl@bibcite\bibcite
%tmp%\def\bibcite#1#2{\babel@sanitize@arg\bbl@bibcite{#1}{#2}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@bibitem}
%    One of the two internal \LaTeX\ macros called by |\bibitem|
%    that write the citation label on the |.aux| file.
%    \begin{macrocode}
%tmp%\let\bbl@@bibitem\@bibitem
%tmp%\def\@bibitem#1{\babel@sanitize@arg\bbl@@bibitem{#1}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@lbibitem}
%    The other of the two internal \LaTeX\ macros called by |\bibitem|
%    that write the citation label on the |.aux| file.
%    \begin{macrocode}
%tmp%\let\bbl@@lbibitem\@lbibitem
%tmp%\def\@lbibitem[#1]#2{\babel@sanitize@arg{\bbl@@lbibitem[#1]}{#2}}
%    \end{macrocode}
%  \end{macro}
%
%    \begin{macrocode}
%</core|shorthands>
%    \end{macrocode}
%
% \section{Local Language Configuration}
%
%  \begin{macro}{\loadlocalcfg}
%    At some sites it may be necessary to add sitespecific actions to
%    a language definition file. This can be done by creating a file
%    with the same name as the language defintion file, but with the
%    extension \file{.cfg}. For instance the file \file{norsk.cfg}
%    will be loaded when the langauge definition file \file{norsk.ldf}
%    is loaded.
%
% \changes{babel~3.5d}{1995/06/22}{Added macro}
%    \begin{macrocode}
%<*core>
\def\loadlocalcfg#1{%
  \InputIfFileExists{#1.cfg}
           {\typeout{*************************************^^J%
                     * Local config file #1.cfg used^^J%
                     *}%
            }
           {}}
%</core>
%    \end{macrocode}
%  \end{macro}
%
%
% \clearpage
% \section{Driver files for the documented source code}
%
%    Since \babel\ version 3.4 all source files that are part of the
%    \babel\ system can be typeset separately. But in order to typeset
%    them all in one document the file \file{babel.drv} can be used.
%    If you only want the information on how to use the \babel\ system
%    and what goodies are provided by the language spcific files you
%    can run the file \file{user.drv} through \LaTeX\ to get a user
%    guide.
%
% \changes{babel~3.4b}{1994/05/18}{Use the ltxdoc class instead of
%    article}
%    \begin{macrocode}
%<*driver>
\documentclass{ltxdoc}
\DoNotIndex{\!,\',\,,\.,\-,\:,\;,\?,\/,\^,\`,\@M}
\DoNotIndex{\@,\@ne,\@m,\@afterheading,\@date,\@endpart}
\DoNotIndex{\@hangfrom,\@idxitem,\@makeschapterhead,\@mkboth}
\DoNotIndex{\@oddfoot,\@oddhead,\@restonecolfalse,\@restonecoltrue}
\DoNotIndex{\@starttoc,\@unused}
\DoNotIndex{\accent,\active}
\DoNotIndex{\addcontentsline,\advance,\Alph,\arabic}
\DoNotIndex{\baselineskip,\begin,\begingroup,\bf,\box,\c@secnumdepth}
\DoNotIndex{\catcode,\centering,\char,\chardef,\clubpenalty}
\DoNotIndex{\columnsep,\columnseprule,\crcr,\csname}
\DoNotIndex{\day,\def,\dimen,\discretionary,\divide,\dp,\do}
\DoNotIndex{\edef,\else,\empty,\end,\endgroup,\endcsname,\endinput}
\DoNotIndex{\errhelp,\errmessage,\expandafter,\fi,\filedate}
\DoNotIndex{\fileversion,\fmtname,\fnum@figure,\fnum@table,\fontdimen}
\DoNotIndex{\gdef,\global}
\DoNotIndex{\hbox,\hidewidth,\hfil,\hskip,\hspace,\ht,\Huge,\huge}
\DoNotIndex{\ialign,\if@twocolumn,\ifcase,\ifcat,\ifhmode,\ifmmode}
\DoNotIndex{\ifnum,\ifx,\immediate,\ignorespaces,\input,\item}
\DoNotIndex{\kern}
\DoNotIndex{\labelsep,\Large,\large,\labelwidth,\lccode,\leftmargin}
\DoNotIndex{\lineskip,\leavevmode,\let,\list,\ll,\long,\lower}
\DoNotIndex{\m@ne,\mathchar,\mathaccent,\markboth,\month,\multiply}
\DoNotIndex{\newblock,\newbox,\newcount,\newdimen,\newif,\newwrite}
\DoNotIndex{\nobreak,\noexpand,\noindent,\null,\number}
\DoNotIndex{\onecolumn,\or}
\DoNotIndex{\p@,par, \parbox,\parindent,\parskip,\penalty}
\DoNotIndex{\protect,\ps@headings}
\DoNotIndex{\quotation}
\DoNotIndex{\raggedright,\raise,\refstepcounter,\relax,\rm,\setbox}
\DoNotIndex{\section,\setcounter,\settowidth,\scriptscriptstyle}
\DoNotIndex{\sfcode,\sl,\sloppy,\small,\space,\spacefactor,\strut}
\DoNotIndex{\string}
\DoNotIndex{\textwidth,\the,\thechapter,\thefigure,\thepage,\thepart}
\DoNotIndex{\thetable,\thispagestyle,\titlepage,\tracingmacros}
\DoNotIndex{\tw@,\twocolumn,\typeout,\uppercase,\usecounter}
\DoNotIndex{\vbox,\vfil,\vskip,\vspace,\vss}
\DoNotIndex{\widowpenalty,\write,\xdef,\year,\z@,\z@skip}
%    \end{macrocode}
%
%     Here |\dlqq| is defined so that  an example of |"'| can be
%     given.
%    \begin{macrocode}
\makeatletter
\gdef\dlqq{{\setbox\tw@=\hbox{,}\setbox\z@=\hbox{''}%
  \dimen\z@=\ht\z@ \advance\dimen\z@-\ht\tw@
  \setbox\z@=\hbox{\lower\dimen\z@\box\z@}\ht\z@=\ht\tw@
  \dp\z@=\dp\tw@ \box\z@\kern-.04em}}
%    \end{macrocode}
%
%    The code lines are numbered within sections,
%    \begin{macrocode}
%<*!user>
\@addtoreset{CodelineNo}{section}
\renewcommand\theCodelineNo{%
  \reset@font\scriptsize\thesection.\arabic{CodelineNo}}
%    \end{macrocode}
%    which should also be visible in the index; hence this
%    redefinition of a macro from \file{doc.sty}.
%    \begin{macrocode}
\renewcommand\codeline@wrindex[1]{\if@filesw
        \immediate\write\@indexfile
            {\string\indexentry{#1}%
            {\number\c@section.\number\c@CodelineNo}}\fi}
%    \end{macrocode}
%
%    The glossary environment is used or the change log, but its
%    definition needs changing for this document.
%    \begin{macrocode}
\renewenvironment{theglossary}{%
    \glossary@prologue%
    \GlossaryParms \let\item\@idxitem \ignorespaces}%
   {}
%</!user>
\makeatother
%    \end{macrocode}
%
%    A few shorthands used in the documentation
%    \begin{macrocode}
\font\manual=logo10 % font used for the METAFONT logo, etc.
\newcommand*\MF{{\manual META}\-{\manual FONT}}
\newcommand*\TeXhax{\TeX hax}
\newcommand*\babel{\textsf{babel}}
\newcommand*\m[1]{\mbox{$\langle$\it#1\/$\rangle$}}
\newcommand*\langvar{\m{lang}}
%    \end{macrocode}
%
%     Some more definitions needed in the documentation.
%    \begin{macrocode}
\newcommand*\note[1]{\textbf{#1}}
%\newcommand*\note[1]{}
\newcommand*\bsl{\protect\bslash}
\newcommand*\Lopt[1]{\textsf{#1}}
\newcommand*\file[1]{\texttt{#1}}
\newcommand*\pkg[1]{\texttt{#1}}
\newcommand*\langdeffile[1]{%
%<-user>  \clearpage
  \DocInput{#1}}
%    \end{macrocode}
%
%    When a full index should be generated unomment the line with
%    |\EnableCrossres|. Beware, processing may take some time.
%    Use |\DisableCrossrefs| when the index is ready.
%    \begin{macrocode}
%  \EnableCrossrefs
\DisableCrossrefs
%    \end{macrocode}
%
%    Inlude the change log.
%    \begin{macrocode}
%<-user>\RecordChanges
%    \end{macrocode}
%    The index should use the linenumbers of the code.
%    \begin{macrocode}
%<-user>\CodelineIndex
%    \end{macrocode}
%
% Set everything in |\MacroFont| instead of |\AltMacroFont|
%    \begin{macrocode}
\setcounter{StandardModuleDepth}{1}
%    \end{macrocode}
%
%    For the user guide we only want the description parts of all the
%    files.
%    \begin{macrocode}
%<+user>\OnlyDescription
%    \end{macrocode}
%    Here starts the document
%    \begin{macrocode}
\begin{document}
\DocInput{babel.dtx}
%    \end{macrocode}
%
%    All the language definition files.
% \changes{babel~3.2e}{1992/07/07}{Added slovak}
% \changes{babel~3.3}{1993/07/11}{Added catalan and galician}
% \changes{babel~3.3}{1993/07/11}{Added turkish}
% \changes{babel~3.4}{1994/02/28}{Added bahasa}
% \changes{babel~3.5a}{1995/02/16}{Added breton, irish, scottish}
% \changes{babel~3.5b}{1995/05/19}{Added lsorbian, usorbian}
% \changes{babel~3.5c}{1995/06/14}{Changed the order of including the
%    language files somwhat (PR1652)}
%    \begin{macrocode}
%<+user>\clearpage
\langdeffile{esperant.dtx}
\langdeffile{dutch.dtx}
\langdeffile{english.dtx}
\langdeffile{germanb.dtx}
%
\langdeffile{breton.dtx}
\langdeffile{irish.dtx}
\langdeffile{scottish.dtx}
%
\langdeffile{francais.dtx}
\langdeffile{italian.dtx}
\langdeffile{portuges.dtx}
\langdeffile{spanish.dtx}
\langdeffile{catalan.dtx}
\langdeffile{galician.dtx}
\langdeffile{romanian.dtx}
%
\langdeffile{danish.dtx}
\langdeffile{norsk.dtx}
\langdeffile{swedish.dtx}
%
\langdeffile{finnish.dtx}
\langdeffile{magyar.dtx}
\langdeffile{estonian.dtx}
%
\langdeffile{croatian.dtx}
\langdeffile{czech.dtx}
\langdeffile{polish.dtx}
\langdeffile{slovak.dtx}
\langdeffile{slovene.dtx}
%\langdeffile{russian.dtx}
%
\langdeffile{lsorbian.dtx}
\langdeffile{usorbian.dtx}
\langdeffile{turkish.dtx}
%
\langdeffile{bahasa.dtx}
%    \end{macrocode}
%    Finally print the index and change log (not for the user guide).
%    \begin{macrocode}
%<*!user>
\clearpage
\def\filename{index}
\PrintIndex
\clearpage
\def\filename{changes}
\PrintChanges
%</!user>
\end{document}
%</driver>
%    \end{macrocode}
%
% \Finale
%
%%
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
\endinput
