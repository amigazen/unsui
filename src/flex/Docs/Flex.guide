@database Flex.guide

@Master Flex.texinfo

@Width 72


This is the AmigaGuide® file Flex.guide, produced by Makeinfo-1.55 from 
the input file Flex.texinfo.

START-INFO-DIR-ENTRY
* Flex: (flex).         A fast scanner generator.
END-INFO-DIR-ENTRY

   This file documents Flex.

   Copyright (c) 1990 The Regents of the University of California.  All
rights reserved.

   This code is derived from software contributed to Berkeley by Vern
Paxson.

   The United States Government has rights in this work pursuant to
contract no. DE-AC03-76SF00098 between the United States Department of
Energy and the University of California.

   Redistribution and use in source and binary forms are permitted
provided that: (1) source distributions retain this entire copyright
notice and comment, and (2) distributions including binaries display
the following acknowledgement:  "This product includes software
developed by the University of California, Berkeley and its
contributors" in the documentation or other materials provided with the
distribution and in all advertising materials mentioning features or
use of this software.  Neither the name of the University nor the names
of its contributors may be used to endorse or promote products derived
from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


@Node Main "Flex.guide"
@Next "Name"

flex
****

   This manual documents @{b}flex@{ub}.  It covers release 2.5.


 @{" Name " Link "Name"}                         Name
 @{" Synopsis " Link "Synopsis"}                     Synopsis
 @{" Overview " Link "Overview"}                     Overview
 @{" Description " Link "Description"}                  Description
 @{" Examples " Link "Examples"}                     Some simple examples
 @{" Format " Link "Format"}                       Format of the input file
 @{" Patterns " Link "Patterns"}                     Patterns
 @{" Matching " Link "Matching"}                     How the input is matched
 @{" Actions " Link "Actions"}                      Actions
 @{" Generated scanner " Link "Generated scanner"}            The generated scanner
 @{" Start conditions " Link "Start conditions"}             Start conditions
 @{" Multiple buffers " Link "Multiple buffers"}             Multiple input buffers
 @{" End-of-file rules " Link "End-of-file rules"}            End-of-file rules
 @{" Miscellaneous " Link "Miscellaneous"}                Miscellaneous macros
 @{" User variables " Link "User variables"}               Values available to the user
 @{" YACC interface " Link "YACC interface"}               Interfacing with @{b}yacc@{ub}
 @{" Options " Link "Options"}                      Options
 @{" Performance " Link "Performance"}                  Performance considerations
 @{" C++ " Link "C++"}                          Generating C++ scanners
 @{" Incompatibilities " Link "Incompatibilities"}            Incompatibilities with @{b}lex@{ub} and POSIX
 @{" Diagnostics " Link "Diagnostics"}                  Diagnostics
 @{" Files " Link "Files"}                        Files
 @{" Deficiencies " Link "Deficiencies"}                 Deficiencies / Bugs
 @{" See also " Link "See also"}                     See also
 @{" Author " Link "Author"}                       Author


@EndNode

@Node "Name" "Flex.guide/Name"
@Next "Synopsis"
@Prev "Main"
@Toc "Main"

Name
====

   flex - fast lexical analyzer generator


@EndNode

@Node "Synopsis" "Flex.guide/Synopsis"
@Next "Overview"
@Prev "Name"
@Toc "Main"

Synopsis
========

     flex [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]
     [--help --version] [@{i}filename@{ui} ...]


@EndNode

@Node "Overview" "Flex.guide/Overview"
@Next "Description"
@Prev "Synopsis"
@Toc "Main"

Overview
========

   This manual describes @{b}flex@{ub}, a tool for generating programs that
perform pattern-matching on text.  The manual includes both tutorial
and reference sections:

Description
     a brief overview of the tool

Some Simple Examples
Format Of The Input File
Patterns
     the extended regular expressions used by flex

How The Input Is Matched
     the rules for determining what has been matched

Actions
     how to specify what to do when a pattern is matched

The Generated Scanner
     details regarding the scanner that flex produces; how to control
     the input source

Start Conditions
     introducing context into your scanners, and managing
     "mini-scanners"

Multiple Input Buffers
     how to manipulate multiple input sources; how to scan from strings
     instead of files

End-of-file Rules
     special rules for matching the end of the input

Miscellaneous Macros
     a summary of macros available to the actions

Values Available To The User
     a summary of values available to the actions

Interfacing With Yacc
     connecting flex scanners together with yacc parsers

Options
     flex command-line options, and the "%option" directive

Performance Considerations
     how to make your scanner go as fast as possible

Generating C++ Scanners
     the (experimental) facility for generating C++ scanner classes

Incompatibilities With Lex And POSIX
     how flex differs from AT&T lex and the POSIX lex standard

Diagnostics
     those error messages produced by flex (or scanners it generates)
     whose meanings might not be apparent

Files
     files used by flex

Deficiencies / Bugs
     known problems with flex

See Also
     other documentation, related tools

Author
     includes contact information


@EndNode

@Node "Description" "Flex.guide/Description"
@Next "Examples"
@Prev "Overview"
@Toc "Main"

Description
===========

   @{b}flex@{ub} is a tool for generating @{i}scanners@{ui}: programs which recognized
lexical patterns in text.  @{b}flex@{ub} reads the given input files, or its
standard input if no file names are given, for a description of a
scanner to generate.  The description is in the form of pairs of
regular expressions and C code, called @{i}rules@{ui}. @{b}flex@{ub} generates as output
a C source file, @{b}lex.yy.c@{ub}, which defines a routine @{b}yylex()@{ub}.  This file
is compiled and linked with the @{b}-lfl@{ub} library to produce an executable.
When the executable is run, it analyzes its input for occurrences of
the regular expressions.  Whenever it finds one, it executes the
corresponding C code.


@EndNode

@Node "Examples" "Flex.guide/Examples"
@Next "Format"
@Prev "Description"
@Toc "Main"

Some simple examples
====================

   First some simple examples to get the flavor of how one uses @{b}flex@{ub}.
The following @{b}flex@{ub} input specifies a scanner which whenever it
encounters the string "username" will replace it with the user's login
name:

     %%
     username    printf( "%s", getlogin() );

   By default, any text not matched by a @{b}flex@{ub} scanner is copied to the
output, so the net effect of this scanner is to copy its input file to
its output with each occurrence of "username" expanded.  In this input,
there is just one rule.  "username" is the @{i}pattern@{ui} and the "printf" is
the @{i}action@{ui}.  The "%%" marks the beginning of the rules.

   Here's another simple example:

             int num_lines = 0, num_chars = 0;
     
     %%
     \n      ++num_lines; ++num_chars;
     .       ++num_chars;
     
     %%
     main()
             {
             yylex();
             printf( "# of lines = %d, # of chars = %d\n",
                     num_lines, num_chars );
             }

   This scanner counts the number of characters and the number of lines
in its input (it produces no output other than the final report on the
counts).  The first line declares two globals, "num_lines" and
"num_chars", which are accessible both inside @{b}yylex()@{ub} and in the @{b}main()@{ub}
routine declared after the second "%%".  There are two rules, one which
matches a newline ("\n") and increments both the line count and the
character count, and one which matches any character other than a
newline (indicated by the "." regular expression).

   A somewhat more complicated example:

     /* scanner for a toy Pascal-like language */
     
     %{
     /* need this for the call to atof() below */
     #include <math.h>
     %}
     
     DIGIT    [0-9]
     ID       [a-z][a-z0-9]*
     
     %%
     
     {DIGIT}+    {
                 printf( "An integer: %s (%d)\n", yytext,
                         atoi( yytext ) );
                 }
     
     {DIGIT}+"."{DIGIT}*        {
                 printf( "A float: %s (%g)\n", yytext,
                         atof( yytext ) );
                 }
     
     if|then|begin|end|procedure|function        {
                 printf( "A keyword: %s\n", yytext );
                 }
     
     {ID}        printf( "An identifier: %s\n", yytext );
     
     "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );
     
     "{"[^}\n]*"}"     /* eat up one-line comments */
     
     [ \t\n]+          /* eat up whitespace */
     
     .           printf( "Unrecognized character: %s\n", yytext );
     
     %%
     
     main( argc, argv )
     int argc;
     char **argv;
         {
         ++argv, --argc;  /* skip over program name */
         if ( argc > 0 )
                 yyin = fopen( argv[0], "r" );
         else
                 yyin = stdin;
     
         yylex();
         }

   This is the beginnings of a simple scanner for a language like
Pascal.  It identifies different types of @{i}tokens@{ui} and reports on what it
has seen.

   The details of this example will be explained in the following
sections.


@EndNode

@Node "Format" "Flex.guide/Format"
@Next "Patterns"
@Prev "Examples"
@Toc "Main"

Format of the input file
========================

   The @{b}flex@{ub} input file consists of three sections, separated by a line
with just @{b}%%@{ub} in it:

     definitions
     %%
     rules
     %%
     user code

   The @{i}definitions@{ui} section contains declarations of simple @{i}name@{ui}
definitions to simplify the scanner specification, and declarations of
@{i}start conditions@{ui}, which are explained in a later section.  Name
definitions have the form:

     name definition

   The "name" is a word beginning with a letter or an underscore ('_')
followed by zero or more letters, digits, '_', or '-' (dash).  The
definition is taken to begin at the first non-white-space character
following the name and continuing to the end of the line.  The
definition can subsequently be referred to using "{name}", which will
expand to "(definition)".  For example,

     DIGIT    [0-9]
     ID       [a-z][a-z0-9]*

defines "DIGIT" to be a regular expression which matches a single
digit, and "ID" to be a regular expression which matches a letter
followed by zero-or-more letters-or-digits.  A subsequent reference to

     {DIGIT}+"."{DIGIT}*

is identical to

     ([0-9])+"."([0-9])*

and matches one-or-more digits followed by a '.' followed by
zero-or-more digits.

   The @{i}rules@{ui} section of the @{b}flex@{ub} input contains a series of rules of
the form:

     pattern   action

where the pattern must be unindented and the action must begin on the
same line.

   See below for a further description of patterns and actions.

   Finally, the user code section is simply copied to @{b}lex.yy.c@{ub}
verbatim.  It is used for companion routines which call or are called
by the scanner.  The presence of this section is optional; if it is
missing, the second @{b}%%@{ub} in the input file may be skipped, too.

   In the definitions and rules sections, any @{i}indented@{ui} text or text
enclosed in @{b} %{@{ub} and @{b} %}@{ub} is copied verbatim to the output (with the @{b}
%{}@{ub}'s removed).  The @{b} %{}@{ub}'s must appear unindented on lines by
themselves.

   In the rules section, any indented or %{} text appearing before the
first rule may be used to declare variables which are local to the
scanning routine and (after the declarations) code which is to be
executed whenever the scanning routine is entered.  Other indented or
%{} text in the rule section is still copied to the output, but its
meaning is not well-defined and it may well cause compile-time errors
(this feature is present for @{b}POSIX@{ub} compliance; see below for other such
features).

   In the definitions section (but not in the rules section), an
unindented comment (i.e., a line beginning with "/*") is also copied
verbatim to the output up to the next "*/".


@EndNode

@Node "Patterns" "Flex.guide/Patterns"
@Next "Matching"
@Prev "Format"
@Toc "Main"

Patterns
========

   The patterns in the input are written using an extended set of
regular expressions.  These are:

@{b}x@{ub}
     match the character @{b}x@{ub}

@{b}.@{ub}
     any character (byte) except newline

@{b}[xyz]@{ub}
     a "character class"; in this case, the pattern matches either an
     @{b}x@{ub}, a @{b}y@{ub}, or a @{b}z@{ub}

@{b}[abj-oZ]@{ub}
     a "character class" with a range in it; matches an @{b}a@{ub}, a @{b}b@{ub}, any
     letter from @{b}j@{ub} through @{b}o@{ub}, or a @{b}Z@{ub}

@{b}[^A-Z]@{ub}
     a "negated character class", i.e., any character but those in the
     class.  In this case, any character EXCEPT an uppercase letter.

@{b}[^A-Z\n]@{ub}
     any character EXCEPT an uppercase letter or a newline

@{b}@{i}r@{ui}*@{ub}
     zero or more @{i}r@{ui}'s, where @{i}r@{ui} is any regular expression

@{b}@{i}r@{ui}+@{ub}
     one or more @{i}r@{ui}'s

@{b}@{i}r@{ui}?@{ub}
     zero or one @{i}r@{ui}'s (that is, "an optional @{i}r@{ui}")

@{b}@{i}r@{ui} {2,5}@{ub}
     anywhere from two to five @{i}r@{ui}'s

@{b}@{i}r@{ui} {2,}@{ub}
     two or more @{i}r@{ui}'s

@{b}@{i}r@{ui} {4}@{ub}
     exactly 4 @{i}r@{ui}'s

@{b}{@{i}name@{ui} }@{ub}
     the expansion of the "@{i}name@{ui}" definition (see above)

@{b}"[xyz]\"foo"@{ub}
     the literal string: @{b}[xyz]"foo@{ub}

@{b} \@{i}x@{ui}@{ub}
     if @{i}x@{ui} is an @{b}a@{ub}, @{b}b@{ub}, @{b}f@{ub}, @{b}n@{ub}, @{b}r@{ub}, @{b}t@{ub}, or @{b}v@{ub}, then the ANSI-C interpretation
     of \@{i}x@{ui}.  Otherwise, a literal @{b}@{i}x@{ui}@{ub} (used to escape operators such as @{b}*@{ub})

@{b}\0@{ub}
     a NUL character (ASCII code 0)

@{b}\123@{ub}
     the character with octal value 123

@{b}\x2a@{ub}
     the character with hexadecimal value @{b}2a@{ub}

@{b} (@{i}r@{ui})@{ub}
     match an @{i}r@{ui}; parentheses are used to override precedence (see below)

@{b}@{i}r@{ui} @{i}s@{ui}@{ub}
     the regular expression @{i}r@{ui} followed by the regular expression @{i}s@{ui};
     called "concatenation"

@{b}@{i}r@{ui}|@{i}s@{ui}@{ub}
     either an @{i}r@{ui} or an @{i}s@{ui}

@{b}@{i}r@{ui}/@{i}s@{ui}@{ub}
     an @{i}r@{ui} but only if it is followed by an @{i}s@{ui}.  The text matched by @{i}s@{ui} is
     included when determining whether this rule is the @{i}longest match@{ui},
     but is then returned to the input before the action is executed.
     So the action only sees the text matched by @{i}r@{ui}.  This type of
     pattern is called @{i}trailing context@{ui}.  (There are some combinations
     of @{b}@{i}r@{ui}/@{i}s@{ui}@{ub} that @{b}flex@{ub} cannot match correctly; see notes in the
     Deficiencies / Bugs section below regarding "dangerous trailing
     context".)

@{b} ^@{i}r@{ui}@{ub}
     an @{i}r@{ui}, but only at the beginning of a line (i.e., which just
     starting to scan, or right after a newline has been scanned).

@{b}@{i}r@{ui}$@{ub}
     an @{i}r@{ui}, but only at the end of a line (i.e., just before a newline).
     Equivalent to "@{i}r@{ui}/\n".

     Note that flex's notion of "newline" is exactly whatever the C
     compiler used to compile flex interprets '\n' as; in particular,
     on some DOS systems you must either filter out \r's in the input
     yourself, or explicitly use @{i}r@{ui}/\r\n for "r$".

@{b} <@{i}s@{ui}>@{i}r@{ui}@{ub}
     an @{i}r@{ui}, but only in start condition @{i}s@{ui} (see below for discussion of
     start conditions) <@{i}s1@{ui},@{i}s2@{ui},@{i}s3@{ui}>@{i}r@{ui} same, but in any of start conditions
     @{i}s1@{ui}, @{i}s2@{ui}, or @{i}s3@{ui}

@{b}<*>@{i}r@{ui}@{ub}
     an @{i}r@{ui} in any start condition, even an exclusive one.

@{b}<<EOF>>@{ub}
     an end-of-file <@{i}s1@{ui},@{i}s2@{ui}><<EOF>> an end-of-file when in start
     condition @{i}s1@{ui} or @{i}s2@{ui}

   Note that inside of a character class, all regular expression
operators lose their special meaning except escape ('\') and the
character class operators, '-', ']', and, at the beginning of the
class, '^'.

   The regular expressions listed above are grouped according to
precedence, from highest precedence at the top to lowest at the bottom.
Those grouped together have equal precedence.  For example,

     foo|bar*

is the same as

     (foo)|(ba(r*))

since the '*' operator has higher precedence than concatenation, and
concatenation higher than alternation ('|').  This pattern therefore
matches @{i}either@{ui} the string "foo" @{i}or@{ui} the string "ba" followed by
zero-or-more r's.  To match "foo" or zero-or-more "bar"'s, use:

     foo|(bar)*

and to match zero-or-more "foo"'s-or-"bar"'s:

     (foo|bar)*

   In addition to characters and ranges of characters, character
classes can also contain character class @{i}expressions@{ui}.  These are
expressions enclosed inside @{b}[@{ub}: and @{b}:@{ub}] delimiters (which themselves must
appear between the '[' and ']' of the character class; other elements
may occur inside the character class, too).  The valid expressions are:

     [:alnum:] [:alpha:] [:blank:]
     [:cntrl:] [:digit:] [:graph:]
     [:lower:] [:print:] [:punct:]
     [:space:] [:upper:] [:xdigit:]

   These expressions all designate a set of characters equivalent to
the corresponding standard C @{b}isXXX@{ub} function.  For example, @{b}[:alnum:]@{ub}
designates those characters for which @{b}isalnum()@{ub} returns true - i.e.,
any alphabetic or numeric.  Some systems don't provide @{b}isblank()@{ub}, so
flex defines @{b}[:blank:]@{ub} as a blank or a tab.

   For example, the following character classes are all equivalent:

     [[:alnum:]]
     [[:alpha:][:digit:]
     [[:alpha:]0-9]
     [a-zA-Z0-9]

   If your scanner is case-insensitive (the @{b}-i@{ub} flag), then @{b}[:upper:]@{ub}
and @{b}[:lower:]@{ub} are equivalent to @{b}[:alpha:]@{ub}.

   Some notes on patterns:

   - A negated character class such as the example "[^A-Z]" above @{i}will
     match a newline@{ui} unless "\n" (or an equivalent escape sequence) is
     one of the characters explicitly present in the negated character
     class (e.g., "[^A-Z\n]").  This is unlike how many other regular
     expression tools treat negated character classes, but
     unfortunately the inconsistency is historically entrenched.
     Matching newlines means that a pattern like [^"]* can match the
     entire input unless there's another quote in the input.

   - A rule can have at most one instance of trailing context (the '/'
     operator or the '$' operator).  The start condition, '^', and
     "<<EOF>>" patterns can only occur at the beginning of a pattern,
     and, as well as with '/' and '$', cannot be grouped inside
     parentheses.  A '^' which does not occur at the beginning of a
     rule or a '$' which does not occur at the end of a rule loses its
     special properties and is treated as a normal character.

     The following are illegal:

          foo/bar$
          <sc1>foo<sc2>bar

     Note that the first of these, can be written "foo/bar\n".

     The following will result in '$' or '^' being treated as a normal
     character:

          foo|(bar$)
          foo|^bar

     If what's wanted is a "foo" or a bar-followed-by-a-newline, the
     following could be used (the special '|' action is explained
     below):

          foo      |
          bar$     /* action goes here */

     A similar trick will work for matching a foo or a
     bar-at-the-beginning-of-a-line.


@EndNode

@Node "Matching" "Flex.guide/Matching"
@Next "Actions"
@Prev "Patterns"
@Toc "Main"

How the input is matched
========================

   When the generated scanner is run, it analyzes its input looking for
strings which match any of its patterns.  If it finds more than one
match, it takes the one matching the most text (for trailing context
rules, this includes the length of the trailing part, even though it
will then be returned to the input).  If it finds two or more matches
of the same length, the rule listed first in the @{b}flex@{ub} input file is
chosen.

   Once the match is determined, the text corresponding to the match
(called the @{i}token@{ui}) is made available in the global character pointer
@{b}yytext@{ub}, and its length in the global integer @{b}yyleng@{ub}.  The @{i}action@{ui}
corresponding to the matched pattern is then executed (a more detailed
description of actions follows), and then the remaining input is
scanned for another match.

   If no match is found, then the @{i}default rule@{ui} is executed: the next
character in the input is considered matched and copied to the standard
output.  Thus, the simplest legal @{b}flex@{ub} input is:

     %%

   which generates a scanner that simply copies its input (one
character at a time) to its output.

   Note that @{b}yytext@{ub} can be defined in two different ways: either as a
character @{i}pointer@{ui} or as a character @{i}array@{ui}.  You can control which
definition @{b}flex@{ub} uses by including one of the special directives
@{b}%pointer@{ub} or @{b}%array@{ub} in the first (definitions) section of your flex
input.  The default is @{b}%pointer@{ub}, unless you use the @{b}-l@{ub} lex
compatibility option, in which case @{b}yytext@{ub} will be an array.  The
advantage of using @{b}%pointer@{ub} is substantially faster scanning and no
buffer overflow when matching very large tokens (unless you run out of
dynamic memory).  The disadvantage is that you are restricted in how
your actions can modify @{b}yytext@{ub} (see the next section), and calls to the
@{b}unput()@{ub} function destroys the present contents of @{b}yytext@{ub}, which can be
a considerable porting headache when moving between different @{b}lex@{ub}
versions.

   The advantage of @{b}%array@{ub} is that you can then modify @{b}yytext@{ub} to your
heart's content, and calls to @{b}unput()@{ub} do not destroy @{b}yytext@{ub} (see
below).  Furthermore, existing @{b}lex@{ub} programs sometimes access @{b}yytext@{ub}
externally using declarations of the form:
     extern char yytext[];
   This definition is erroneous when used with @{b}%pointer@{ub}, but correct
for @{b}%array@{ub}.

   @{b}%array@{ub} defines @{b}yytext@{ub} to be an array of @{b}YYLMAX@{ub} characters, which
defaults to a fairly large value.  You can change the size by simply
#define'ing @{b}YYLMAX@{ub} to a different value in the first section of your
@{b}flex@{ub} input.  As mentioned above, with @{b}%pointer@{ub} yytext grows dynamically
to accommodate large tokens.  While this means your @{b}%pointer@{ub} scanner
can accommodate very large tokens (such as matching entire blocks of
comments), bear in mind that each time the scanner must resize @{b}yytext@{ub}
it also must rescan the entire token from the beginning, so matching
such tokens can prove slow.  @{b}yytext@{ub} presently does @{i}not@{ui} dynamically grow
if a call to @{b}unput()@{ub} results in too much text being pushed back;
instead, a run-time error results.

   Also note that you cannot use @{b}%array@{ub} with C++ scanner classes (the
@{b}c++@{ub} option; see below).


@EndNode

@Node "Actions" "Flex.guide/Actions"
@Next "Generated scanner"
@Prev "Matching"
@Toc "Main"

Actions
=======

   Each pattern in a rule has a corresponding action, which can be any
arbitrary C statement.  The pattern ends at the first non-escaped
whitespace character; the remainder of the line is its action.  If the
action is empty, then when the pattern is matched the input token is
simply discarded.  For example, here is the specification for a program
which deletes all occurrences of "zap me" from its input:

     %%
     "zap me"

   (It will copy all other characters in the input to the output since
they will be matched by the default rule.)

   Here is a program which compresses multiple blanks and tabs down to
a single blank, and throws away whitespace found at the end of a line:

     %%
     [ \t]+        putchar( ' ' );
     [ \t]+$       /* ignore this token */

   If the action contains a '{', then the action spans till the
balancing '}' is found, and the action may cross multiple lines.  @{b}flex@{ub}
knows about C strings and comments and won't be fooled by braces found
within them, but also allows actions to begin with @{b} %{@{ub} and will
consider the action to be all the text up to the next @{b} %}@{ub} (regardless of
ordinary braces inside the action).

   An action consisting solely of a vertical bar ('|') means "same as
the action for the next rule." See below for an illustration.

   Actions can include arbitrary C code, including @{b}return@{ub} statements to
return a value to whatever routine called @{b}yylex()@{ub}.  Each time @{b}yylex()@{ub}
is called it continues processing tokens from where it last left off
until it either reaches the end of the file or executes a return.

   Actions are free to modify @{b}yytext@{ub} except for lengthening it (adding
characters to its end-these will overwrite later characters in the
input stream).  This however does not apply when using @{b}%array@{ub} (see
above); in that case, @{b}yytext@{ub} may be freely modified in any way.

   Actions are free to modify @{b}yyleng@{ub} except they should not do so if
the action also includes use of @{b}yymore()@{ub} (see below).

   There are a number of special directives which can be included
within an action:

   -     @{b}ECHO@{ub} copies yytext to the scanner's output.

   -     @{b}BEGIN@{ub} followed by the name of a start condition places the
     scanner in the corresponding start condition (see below).

   -     @{b}REJECT@{ub} directs the scanner to proceed on to the "second best"
     rule which matched the input (or a prefix of the input).  The rule
     is chosen as described above in "How the Input is Matched", and
     @{b}yytext@{ub} and @{b}yyleng@{ub} set up appropriately.  It may either be one
     which matched as much text as the originally chosen rule but came
     later in the @{b}flex@{ub} input file, or one which matched less text.  For
     example, the following will both count the words in the input and
     call the routine special() whenever "frob" is seen:

                  int word_count = 0;
          %%
          
          frob        special(); REJECT;
          [^ \t\n]+   ++word_count;

     Without the @{b}REJECT@{ub}, any "frob"'s in the input would not be counted
     as words, since the scanner normally executes only one action per
     token.  Multiple @{b}REJECT's@{ub} are allowed, each one finding the next
     best choice to the currently active rule.  For example, when the
     following scanner scans the token "abcd", it will write
     "abcdabcaba" to the output:

          %%
          a        |
          ab       |
          abc      |
          abcd     ECHO; REJECT;
          .|\n     /* eat up any unmatched character */

     (The first three rules share the fourth's action since they use
     the special '|' action.)  @{b}REJECT@{ub} is a particularly expensive
     feature in terms of scanner performance; if it is used in @{i}any@{ui} of
     the scanner's actions it will slow down @{i}all@{ui} of the scanner's
     matching.  Furthermore, @{b}REJECT@{ub} cannot be used with the @{b}-Cf@{ub} or @{b}-CF@{ub}
     options (see below).

     Note also that unlike the other special actions, @{b}REJECT@{ub} is a
     @{i}branch@{ui}; code immediately following it in the action will @{i}not@{ui}
     be executed.

   -     @{b}yymore()@{ub} tells the scanner that the next time it matches a
     rule, the corresponding token should be @{i}appended@{ui} onto the current
     value of @{b}yytext@{ub} rather than replacing it.  For example, given the
     input "mega-kludge" the following will write "mega-mega-kludge" to
     the output:

          %%
          mega-    ECHO; yymore();
          kludge   ECHO;

     First "mega-" is matched and echoed to the output.  Then "kludge"
     is matched, but the previous "mega-" is still hanging around at
     the beginning of @{b}yytext@{ub} so the @{b}ECHO@{ub} for the "kludge" rule will
     actually write "mega-kludge".

   Two notes regarding use of @{b}yymore()@{ub}.  First, @{b}yymore()@{ub} depends on the
value of @{b}yyleng@{ub} correctly reflecting the size of the current token, so
you must not modify @{b}yyleng@{ub} if you are using @{b}yymore()@{ub}.  Second, the
presence of @{b}yymore()@{ub} in the scanner's action entails a minor
performance penalty in the scanner's matching speed.

   -     @{b}yyless(n)@{ub} returns all but the first @{i}n@{ui} characters of the
     current token back to the input stream, where they will be
     rescanned when the scanner looks for the next match.  @{b}yytext@{ub} and
     @{b}yyleng@{ub} are adjusted appropriately (e.g., @{b}yyleng@{ub} will now be equal
     to @{i}n@{ui} ).  For example, on the input "foobar" the following will
     write out "foobarbar":

          %%
          foobar    ECHO; yyless(3);
          [a-z]+    ECHO;

     An argument of 0 to @{b}yyless@{ub} will cause the entire current input
     string to be scanned again.  Unless you've changed how the scanner
     will subsequently process its input (using @{b}BEGIN@{ub}, for example),
     this will result in an endless loop.

     Note that @{b}yyless@{ub} is a macro and can only be used in the flex input
     file, not from other source files.

   -     @{b}unput(c)@{ub} puts the character @{b}c@{ub} back onto the input stream.  It
     will be the next character scanned.  The following action will
     take the current token and cause it to be rescanned enclosed in
     parentheses.

          {
          int i;
          /* Copy yytext because unput() trashes yytext */
          char *yycopy = strdup( yytext );
          unput( ')' );
          for ( i = yyleng - 1; i >= 0; --i )
              unput( yycopy[i] );
          unput( '(' );
          free( yycopy );
          }

     Note that since each @{b}unput()@{ub} puts the given character back at the
     @{i}beginning@{ui} of the input stream, pushing back strings must be done
     back-to-front.  An important potential problem when using @{b}unput()@{ub}
     is that if you are using @{b}%pointer@{ub} (the default), a call to @{b}unput()@{ub}
     @{i}destroys@{ui} the contents of @{b}yytext@{ub}, starting with its rightmost
     character and devouring one character to the left with each call.
     If you need the value of yytext preserved after a call to @{b}unput()@{ub}
     (as in the above example), you must either first copy it
     elsewhere, or build your scanner using @{b}%array@{ub} instead (see How The
     Input Is Matched).

     Finally, note that you cannot put back @{b}EOF@{ub} to attempt to mark the
     input stream with an end-of-file.

   -     @{b}input()@{ub} reads the next character from the input stream.  For
     example, the following is one way to eat up C comments:

          %%
          "/*"        {
                      register int c;
          
                      for ( ; ; )
                          {
                          while ( (c = input()) != '*' &&
                                  c != EOF )
                              ;    /* eat up text of comment */
          
                          if ( c == '*' )
                              {
                              while ( (c = input()) == '*' )
                                  ;
                              if ( c == '/' )
                                  break;    /* found the end */
                              }
          
                          if ( c == EOF )
                              {
                              error( "EOF in comment" );
                              break;
                              }
                          }
                      }

     (Note that if the scanner is compiled using @{b}C++@{ub}, then @{b}input()@{ub} is
     instead referred to as @{b}yyinput()@{ub}, in order to avoid a name clash
     with the @{b}C++@{ub} stream by the name of @{b}input@{ub}.)

   - YY_FLUSH_BUFFER flushes the scanner's internal buffer so that the
     next time the scanner attempts to match a token, it will first
     refill the buffer using @{b}YY_INPUT@{ub} (see The Generated Scanner,
     below).  This action is a special case of the more general
     @{b}yy_flush_buffer()@{ub} function, described below in the section
     Multiple Input Buffers.

   -     @{b}yyterminate()@{ub} can be used in lieu of a return statement in an
     action.  It terminates the scanner and returns a 0 to the
     scanner's caller, indicating "all done".  By default,
     @{b}yyterminate()@{ub} is also called when an end-of-file is
     encountered.  It is a macro and may be redefined.


@EndNode

@Node "Generated scanner" "Flex.guide/Generated scanner"
@Next "Start conditions"
@Prev "Actions"
@Toc "Main"

The generated scanner
=====================

   The output of @{b}flex@{ub} is the file @{b}lex.yy.c@{ub}, which contains the scanning
routine @{b}yylex()@{ub}, a number of tables used by it for matching tokens, and
a number of auxiliary routines and macros.  By default, @{b}yylex()@{ub} is
declared as follows:

     int yylex()
         {
         ... various definitions and the actions in here ...
         }

   (If your environment supports function prototypes, then it will be
"int yylex( void  )".)   This  definition  may  be changed by defining
the "YY_DECL" macro.  For example, you could use:

     #define YY_DECL float lexscan( a, b ) float a, b;

   to give the scanning routine the name @{b}lexscan@{ub}, returning a float,
and taking two floats as arguments.  Note that if you give arguments to
the scanning routine using a K&R-style/non-prototyped function
declaration, you must terminate the definition with a semi-colon (@{b};@{ub}).

   Whenever @{b}yylex()@{ub} is called, it scans tokens from the global input
file @{b}yyin@{ub} (which defaults to stdin).  It continues until it either
reaches an end-of-file (at which point it returns the value 0) or one
of its actions executes a @{b}return@{ub} statement.

   If the scanner reaches an end-of-file, subsequent calls are undefined
unless either @{b}yyin@{ub} is pointed at a new input file (in which case
scanning continues from that file), or @{b}yyrestart()@{ub} is called.
@{b}yyrestart()@{ub} takes one argument, a @{b}FILE *@{ub} pointer (which can be nil, if
you've set up @{b}YY_INPUT@{ub} to scan from a source other than @{b}yyin@{ub}), and
initializes @{b}yyin@{ub} for scanning from that file.  Essentially there is no
difference between just assigning @{b}yyin@{ub} to a new input file or using
@{b}yyrestart()@{ub} to do so; the latter is available for compatibility with
previous versions of @{b}flex@{ub}, and because it can be used to switch input
files in the middle of scanning.  It can also be used to throw away the
current input buffer, by calling it with an argument of @{b}yyin@{ub}; but
better is to use @{b}YY_FLUSH_BUFFER@{ub} (see above).  Note that @{b}yyrestart()@{ub}
does @{i}not@{ui} reset the start condition to @{b}INITIAL@{ub} (see Start Conditions,
below).

   If @{b}yylex()@{ub} stops scanning due to executing a @{b}return@{ub} statement in one
of the actions, the scanner may then be called again and it will resume
scanning where it left off.

   By default (and for purposes of efficiency), the scanner uses
block-reads rather than simple @{b}getc()@{ub} calls to read characters from
@{b}yyin@{ub}.  The nature of how it gets its input can be controlled by
defining the @{b}YY_INPUT@{ub} macro.  YY_INPUT's calling sequence is
"YY_INPUT(buf,result,max_size)".  Its action is to place up to @{i}max_size@{ui}
characters in the character array @{i}buf@{ui} and return in the integer
variable @{i}result@{ui} either the number of characters read or the constant
YY_NULL (0 on Unix systems) to indicate EOF.  The default YY_INPUT
reads from the global file-pointer "yyin".

   A sample definition of YY_INPUT (in the definitions section of the
input file):

     %{
     #define YY_INPUT(buf,result,max_size) \
         { \
         int c = getchar(); \
         result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
         }
     %}

   This definition will change the input processing to occur one
character at a time.

   When the scanner receives an end-of-file indication from YY_INPUT,
it then checks the @{b}yywrap()@{ub} function.  If @{b}yywrap()@{ub} returns false
(zero), then it is assumed that the function has gone ahead and set up
@{b}yyin@{ub} to point to another input file, and scanning continues.  If it
returns true (non-zero), then the scanner terminates, returning 0 to
its caller.  Note that in either case, the start condition remains
unchanged; it does @{i}not@{ui} revert to @{b}INITIAL@{ub}.

   If you do not supply your own version of @{b}yywrap()@{ub}, then you must
either use @{b}%option noyywrap@{ub} (in which case the scanner behaves as
though @{b}yywrap()@{ub} returned 1), or you must link with @{b}-lfl@{ub} to obtain the
default version of the routine, which always returns 1.

   Three routines are available for scanning from in-memory buffers
rather than files: @{b}yy_scan_string()@{ub}, @{b}yy_scan_bytes()@{ub}, and
@{b}yy_scan_buffer()@{ub}.  See the discussion of them below in the section
Multiple Input Buffers.

   The scanner writes its @{b}ECHO@{ub} output to the @{b}yyout@{ub} global (default,
stdout), which may be redefined by the user simply by assigning it to
some other @{b}FILE@{ub} pointer.


@EndNode

@Node "Start conditions" "Flex.guide/Start conditions"
@Next "Multiple buffers"
@Prev "Generated scanner"
@Toc "Main"

Start conditions
================

   @{b}flex@{ub} provides a mechanism for conditionally activating rules.  Any
rule whose pattern is prefixed with "<sc>" will only be active when the
scanner is in the start condition named "sc".  For example,

     <STRING>[^"]*        { /* eat up the string body ... */
                 ...
                 }

will be active only when the scanner is in the "STRING" start
condition, and

     <INITIAL,STRING,QUOTE>\.        { /* handle an escape ... */
                 ...
                 }

will be active only when the current start condition is either
"INITIAL", "STRING", or "QUOTE".

   Start conditions are declared in the definitions (first) section of
the input using unindented lines beginning with either @{b}%s@{ub} or @{b}%x@{ub}
followed by a list of names.  The former declares @{i}inclusive@{ui} start
conditions, the latter @{i}exclusive@{ui} start conditions.  A start condition
is activated using the @{b}BEGIN@{ub} action.  Until the next @{b}BEGIN@{ub} action is
executed, rules with the given start condition will be active and rules
with other start conditions will be inactive.  If the start condition
is @{i}inclusive@{ui}, then rules with no start conditions at all will also be
active.  If it is @{i}exclusive@{ui}, then @{i}only@{ui} rules qualified with the start
condition will be active.  A set of rules contingent on the same
exclusive start condition describe a scanner which is independent of
any of the other rules in the @{b}flex@{ub} input.  Because of this, exclusive
start conditions make it easy to specify "mini-scanners" which scan
portions of the input that are syntactically different from the rest
(e.g., comments).

   If the distinction between inclusive and exclusive start conditions
is still a little vague, here's a simple example illustrating the
connection between the two.  The set of rules:

     %s example
     %%
     
     <example>foo   do_something();
     
     bar            something_else();

is equivalent to

     %x example
     %%
     
     <example>foo   do_something();
     
     <INITIAL,example>bar    something_else();

   Without the @{b}<INITIAL,example>@{ub} qualifier, the @{b}bar@{ub} pattern in the
second example wouldn't be active (i.e., couldn't match) when in start
condition @{b}example@{ub}.  If we just used @{b}<example>@{ub} to qualify @{b}bar@{ub}, though,
then it would only be active in @{b}example@{ub} and not in @{b}INITIAL@{ub}, while in
the first example it's active in both, because in the first example the
@{b}example@{ub} starting condition is an @{i}inclusive@{ui} (@{b}%s@{ub}) start condition.

   Also note that the special start-condition specifier @{b}<*>@{ub} matches
every start condition.  Thus, the above example could also have been
written;

     %x example
     %%
     
     <example>foo   do_something();
     
     <*>bar    something_else();

   The default rule (to @{b}ECHO@{ub} any unmatched character) remains active in
start conditions.  It is equivalent to:

     <*>.|\\n     ECHO;

   @{b}BEGIN(0)@{ub} returns to the original state where only the rules with no
start conditions are active.  This state can also be referred to as the
start-condition "INITIAL", so @{b}BEGIN(INITIAL)@{ub} is equivalent to @{b}BEGIN(0)@{ub}.
(The parentheses around the start condition name are not required but
are considered good style.)

   @{b}BEGIN@{ub} actions can also be given as indented code at the beginning of
the rules section.  For example, the following will cause the scanner
to enter the "SPECIAL" start condition whenever @{b}yylex()@{ub} is called and
the global variable @{b}enter_special@{ub} is true:

             int enter_special;
     
     %x SPECIAL
     %%
             if ( enter_special )
                 BEGIN(SPECIAL);
     
     <SPECIAL>blahblahblah
     ...more rules follow...

   To illustrate the uses of start conditions, here is a scanner which
provides two different interpretations of a string like "123.456".  By
default it will treat it as as three tokens, the integer "123", a dot
('.'), and the integer "456".  But if the string is preceded earlier in
the line by the string "expect-floats" it will treat it as a single
token, the floating-point number 123.456:

     %{
     #include <math.h>
     %}
     %s expect
     
     %%
     expect-floats        BEGIN(expect);
     
     <expect>[0-9]+"."[0-9]+      {
                 printf( "found a float, = %f\n",
                         atof( yytext ) );
                 }
     <expect>\n           {
                 /* that's the end of the line, so
                  * we need another "expect-number"
                  * before we'll recognize any more
                  * numbers
                  */
                 BEGIN(INITIAL);
                 }
     
     [0-9]+      {
     
     Version 2.5               December 1994                        18
     
                 printf( "found an integer, = %d\n",
                         atoi( yytext ) );
                 }
     
     "."         printf( "found a dot\n" );

   Here is a scanner which recognizes (and discards) C comments while
maintaining a count of the current input line.

     %x comment
     %%
             int line_num = 1;
     
     "/*"         BEGIN(comment);
     
     <comment>[^*\n]*        /* eat anything that's not a '*' */
     <comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
     <comment>\n             ++line_num;
     <comment>"*"+"/"        BEGIN(INITIAL);

   This scanner goes to a bit of trouble to match as much text as
possible with each rule.  In general, when attempting to write a
high-speed scanner try to match as much possible in each rule, as it's
a big win.

   Note that start-conditions names are really integer values and can
be stored as such.  Thus, the above could be extended in the following
fashion:

     %x comment foo
     %%
             int line_num = 1;
             int comment_caller;
     
     "/*"         {
                  comment_caller = INITIAL;
                  BEGIN(comment);
                  }
     
     ...
     
     <foo>"/*"    {
                  comment_caller = foo;
                  BEGIN(comment);
                  }
     
     <comment>[^*\n]*        /* eat anything that's not a '*' */
     <comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
     <comment>\n             ++line_num;
     <comment>"*"+"/"        BEGIN(comment_caller);

   Furthermore, you can access the current start condition using the
integer-valued @{b}YY_START@{ub} macro.  For example, the above assignments to
@{b}comment_caller@{ub} could instead be written

     comment_caller = YY_START;

   Flex provides @{b}YYSTATE@{ub} as an alias for @{b}YY_START@{ub} (since that is what's
used by AT&T @{b}lex@{ub}).

   Note that start conditions do not have their own name-space; %s's
and %x's declare names in the same fashion as #define's.

   Finally, here's an example of how to match C-style quoted strings
using exclusive start conditions, including expanded escape sequences
(but not including checking for a string that's too long):

     %x str
     
     %%
             char string_buf[MAX_STR_CONST];
             char *string_buf_ptr;
     
     \"      string_buf_ptr = string_buf; BEGIN(str);
     
     <str>\"        { /* saw closing quote - all done */
             BEGIN(INITIAL);
             *string_buf_ptr = '\0';
             /* return string constant token type and
              * value to parser
              */
             }
     
     <str>\n        {
             /* error - unterminated string constant */
             /* generate error message */
             }
     
     <str>\\[0-7]{1,3} {
             /* octal escape sequence */
             int result;
     
             (void) sscanf( yytext + 1, "%o", &result );
     
             if ( result > 0xff )
                     /* error, constant is out-of-bounds */
     
             *string_buf_ptr++ = result;
             }
     
     <str>\\[0-9]+ {
             /* generate error - bad escape sequence; something
              * like '\48' or '\0777777'
              */
             }
     
     <str>\\n  *string_buf_ptr++ = '\n';
     <str>\\t  *string_buf_ptr++ = '\t';
     <str>\\r  *string_buf_ptr++ = '\r';
     <str>\\b  *string_buf_ptr++ = '\b';
     <str>\\f  *string_buf_ptr++ = '\f';
     
     <str>\\(.|\n)  *string_buf_ptr++ = yytext[1];
     
     <str>[^\\\n\"]+        {
             char *yptr = yytext;
     
             while ( *yptr )
                     *string_buf_ptr++ = *yptr++;
             }

   Often, such as in some of the examples above, you wind up writing a
whole bunch of rules all preceded by the same start condition(s).  Flex
makes this a little easier and cleaner by introducing a notion of start
condition @{i}scope@{ui}.  A start condition scope is begun with:

     <SCs>{

where SCs is a list of one or more start conditions.  Inside the start
condition scope, every rule automatically has the prefix @{b}<SCs>@{ub} applied
to it, until a @{b}}@{ub} which matches the initial @{b}{@{ub}.  So, for example,

     <ESC>{
         "\\n"   return '\n';
         "\\r"   return '\r';
         "\\f"   return '\f';
         "\\0"   return '\0';
     }

is equivalent to:

     <ESC>"\\n"  return '\n';
     <ESC>"\\r"  return '\r';
     <ESC>"\\f"  return '\f';
     <ESC>"\\0"  return '\0';

   Start condition scopes may be nested.

   Three routines are available for manipulating stacks of start
conditions:

@{b}void yy_push_state(int new_state)@{ub}
     pushes the current start condition onto the top of the start
     condition stack and switches to @{i}new_state@{ui} as though you had used
     @{b}BEGIN new_state@{ub} (recall that start condition names are also
     integers).

@{b}void yy_pop_state()@{ub}
     pops the top of the stack and switches to it via @{b}BEGIN@{ub}.

@{b}int yy_top_state()@{ub}
     returns the top of the stack without altering the stack's contents.

   The start condition stack grows dynamically and so has no built-in
size limitation.  If memory is exhausted, program execution aborts.

   To use start condition stacks, your scanner must include a @{b}%option
stack@{ub} directive (see Options below).


@EndNode

@Node "Multiple buffers" "Flex.guide/Multiple buffers"
@Next "End-of-file rules"
@Prev "Start conditions"
@Toc "Main"

Multiple input buffers
======================

   Some scanners (such as those which support "include" files) require
reading from several input streams.  As @{b}flex@{ub} scanners do a large amount
of buffering, one cannot control where the next input will be read from
by simply writing a @{b}YY_INPUT@{ub} which is sensitive to the scanning
context.  @{b}YY_INPUT@{ub} is only called when the scanner reaches the end of
its buffer, which may be a long time after scanning a statement such as
an "include" which requires switching the input source.

   To negotiate these sorts of problems, @{b}flex@{ub} provides a mechanism for
creating and switching between multiple input buffers.  An input buffer
is created by using:

     YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )

which takes a @{b}FILE@{ub} pointer and a size and creates a buffer associated
with the given file and large enough to hold @{i}size@{ui} characters (when in
doubt, use @{b}YY_BUF_SIZE@{ub} for the size).  It returns a @{b}YY_BUFFER_STATE@{ub}
handle, which may then be passed to other routines (see below).  The
@{b}YY_BUFFER_STATE@{ub} type is a pointer to an opaque @{b}struct@{ub} @{b}yy_buffer_state@{ub}
structure, so you may safely initialize YY_BUFFER_STATE variables to
@{b}((YY_BUFFER_STATE) 0)@{ub} if you wish, and also refer to the opaque
structure in order to correctly declare input buffers in source files
other than that of your scanner.  Note that the @{b}FILE@{ub} pointer in the
call to @{b}yy_create_buffer@{ub} is only used as the value of @{b}yyin@{ub} seen by
@{b}YY_INPUT@{ub}; if you redefine @{b}YY_INPUT@{ub} so it no longer uses @{b}yyin@{ub}, then you
can safely pass a nil @{b}FILE@{ub} pointer to @{b}yy_create_buffer@{ub}.  You select a
particular buffer to scan from using:

     void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )

   switches the scanner's input buffer so subsequent tokens will come
from @{i}new_buffer@{ui}.  Note that @{b}yy_switch_to_buffer()@{ub} may be used by
@{b}yywrap()@{ub} to set things up for continued scanning, instead of opening a
new file and pointing @{b}yyin@{ub} at it.  Note also that switching input
sources via either @{b}yy_switch_to_buffer()@{ub} or @{b}yywrap()@{ub} does @{i}not@{ui} change
the start condition.

     void yy_delete_buffer( YY_BUFFER_STATE buffer )

is used to reclaim the storage associated with a buffer.  You can also
clear the current contents of a buffer using:

     void yy_flush_buffer( YY_BUFFER_STATE buffer )

   This function discards the buffer's contents, so the next time the
scanner attempts to match a token from the buffer, it will first fill
the buffer anew using @{b}YY_INPUT@{ub}.

   @{b}yy_new_buffer()@{ub} is an alias for @{b}yy_create_buffer()@{ub}, provided for
compatibility with the C++ use of @{b}new@{ub} and @{b}delete@{ub} for creating and
destroying dynamic objects.

   Finally, the @{b}YY_CURRENT_BUFFER@{ub} macro returns a @{b}YY_BUFFER_STATE@{ub}
handle to the current buffer.

   Here is an example of using these features for writing a scanner
which expands include files (the @{b}<<EOF>>@{ub} feature is discussed below):

     /* the "incl" state is used for picking up the name
      * of an include file
      */
     %x incl
     
     %{
     #define MAX_INCLUDE_DEPTH 10
     YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
     int include_stack_ptr = 0;
     %}
     
     %%
     include             BEGIN(incl);
     
     [a-z]+              ECHO;
     [^a-z\n]*\n?        ECHO;
     
     <incl>[ \t]*      /* eat the whitespace */
     <incl>[^ \t\n]+   { /* got the include file name */
             if ( include_stack_ptr >= MAX_INCLUDE_DEPTH )
                 {
                 fprintf( stderr, "Includes nested too deeply" );
                 exit( 1 );
                 }
     
             include_stack[include_stack_ptr++] =
                 YY_CURRENT_BUFFER;
     
             yyin = fopen( yytext, "r" );
     
             if ( ! yyin )
                 error( ... );
     
             yy_switch_to_buffer(
                 yy_create_buffer( yyin, YY_BUF_SIZE ) );
     
             BEGIN(INITIAL);
             }
     
     <<EOF>> {
             if ( --include_stack_ptr < 0 )
                 {
                 yyterminate();
                 }
     
             else
                 {
                 yy_delete_buffer( YY_CURRENT_BUFFER );
                 yy_switch_to_buffer(
                      include_stack[include_stack_ptr] );
                 }
             }

   Three routines are available for setting up input buffers for
scanning in-memory strings instead of files.  All of them create a new
input buffer for scanning the string, and return a corresponding
@{b}YY_BUFFER_STATE@{ub} handle (which you should delete with @{b}yy_delete_buffer()@{ub}
when done with it).  They also switch to the new buffer using
@{b}yy_switch_to_buffer()@{ub}, so the next call to @{b}yylex()@{ub} will start scanning
the string.

@{b}yy_scan_string(const char *str)@{ub}
     scans a NUL-terminated string.

@{b}yy_scan_bytes(const char *bytes, int len)@{ub}
     scans @{b}len@{ub} bytes (including possibly NUL's) starting at location
     @{i}bytes@{ui}.

   Note that both of these functions create and scan a @{i}copy@{ui} of the
string or bytes.  (This may be desirable, since @{b}yylex()@{ub} modifies the
contents of the buffer it is scanning.) You can avoid the copy by using:

@{b}yy_scan_buffer(char *base, yy_size_t size)@{ub}
     which scans in place the buffer starting at @{i}base@{ui}, consisting of
     @{i}size@{ui} bytes, the last two bytes of which @{i}must@{ui} be
     @{b}YY_END_OF_BUFFER_CHAR@{ub} (ASCII NUL).  These last two bytes are not
     scanned; thus, scanning consists of @{b}base[0]@{ub} through @{b}base[size-2]@{ub},
     inclusive.

     If you fail to set up @{i}base@{ui} in this manner (i.e., forget the final
     two @{b}YY_END_OF_BUFFER_CHAR@{ub} bytes), then @{b}yy_scan_buffer()@{ub} returns a
     nil pointer instead of creating a new input buffer.

     The type @{b}yy_size_t@{ub} is an integral type to which you can cast an
     integer expression reflecting the size of the buffer.


@EndNode

@Node "End-of-file rules" "Flex.guide/End-of-file rules"
@Next "Miscellaneous"
@Prev "Multiple buffers"
@Toc "Main"

End-of-file rules
=================

   The special rule "<<EOF>>" indicates actions which are to be taken
when an end-of-file is encountered and yywrap() returns non-zero (i.e.,
indicates no further files to process).  The action must finish by
doing one of four things:

   - assigning @{b}yyin@{ub} to a new input file (in previous versions of flex,
     after doing the assignment you had to call the special action
     @{b}YY_NEW_FILE@{ub}; this is no longer necessary);

   - executing a @{b}return@{ub} statement;

   - executing the special @{b}yyterminate()@{ub} action;

   - or, switching to a new buffer using @{b}yy_switch_to_buffer()@{ub} as shown
     in the example above.

   <<EOF>> rules may not be used with other patterns; they may only be
qualified with a list of start conditions.  If an unqualified <<EOF>>
rule is given, it applies to @{i}all@{ui} start conditions which do not already
have <<EOF>> actions.  To specify an <<EOF>> rule for only the initial
start condition, use

     <INITIAL><<EOF>>

   These rules are useful for catching things like unclosed comments.
An example:

     %x quote
     %%
     
     ...other rules for dealing with quotes...
     
     <quote><<EOF>>   {
              error( "unterminated quote" );
              yyterminate();
              }
     <<EOF>>  {
              if ( *++filelist )
                  yyin = fopen( *filelist, "r" );
              else
                 yyterminate();
              }


@EndNode

@Node "Miscellaneous" "Flex.guide/Miscellaneous"
@Next "User variables"
@Prev "End-of-file rules"
@Toc "Main"

Miscellaneous macros
====================

   The macro @{b}YY_USER_ACTION@{ub} can be defined to provide an action which
is always executed prior to the matched rule's action.  For example, it
could be #define'd to call a routine to convert yytext to lower-case.
When @{b}YY_USER_ACTION@{ub} is invoked, the variable @{b}yy_act@{ub} gives the number of
the matched rule (rules are numbered starting with 1).  Suppose you
want to profile how often each of your rules is matched.  The following
would do the trick:

     #define YY_USER_ACTION ++ctr[yy_act]

   where @{b}ctr@{ub} is an array to hold the counts for the different rules.
Note that the macro @{b}YY_NUM_RULES@{ub} gives the total number of rules
(including the default rule, even if you use @{b}-s@{ub}, so a correct
declaration for @{b}ctr@{ub} is:

     int ctr[YY_NUM_RULES];

   The macro @{b}YY_USER_INIT@{ub} may be defined to provide an action which is
always executed before the first scan (and before the scanner's
internal initializations are done).  For example, it could be used to
call a routine to read in a data table or open a logging file.

   The macro @{b}yy_set_interactive(is_interactive)@{ub} can be used to control
whether the current buffer is considered @{i}interactive@{ui}.  An interactive
buffer is processed more slowly, but must be used when the scanner's
input source is indeed interactive to avoid problems due to waiting to
fill buffers (see the discussion of the @{b}-I@{ub} flag below).  A non-zero
value in the macro invocation marks the buffer as interactive, a zero
value as non-interactive.  Note that use of this macro overrides
@{b}%option always-interactive@{ub} or @{b}%option never-interactive@{ub} (see Options
below).  @{b}yy_set_interactive()@{ub} must be invoked prior to beginning to
scan the buffer that is (or is not) to be considered interactive.

   The macro @{b}yy_set_bol(at_bol)@{ub} can be used to control whether the
current buffer's scanning context for the next token match is done as
though at the beginning of a line.  A non-zero macro argument makes
rules anchored with

   The macro @{b}YY_AT_BOL()@{ub} returns true if the next token scanned from
the current buffer will have '^' rules active, false otherwise.

   In the generated scanner, the actions are all gathered in one large
switch statement and separated using @{b}YY_BREAK@{ub}, which may be redefined.
By default, it is simply a "break", to separate each rule's action from
the following rule's.  Redefining @{b}YY_BREAK@{ub} allows, for example, C++
users to #define YY_BREAK to do nothing (while being very careful that
every rule ends with a "break" or a "return"!) to avoid suffering from
unreachable statement warnings where because a rule's action ends with
"return", the @{b}YY_BREAK@{ub} is inaccessible.


@EndNode

@Node "User variables" "Flex.guide/User variables"
@Next "YACC interface"
@Prev "Miscellaneous"
@Toc "Main"

Values available to the user
============================

   This section summarizes the various values available to the user in
the rule actions.

   -     @{b}char *yytext@{ub} holds the text of the current token.  It may be
     modified but not lengthened (you cannot append characters to the
     end).

     If the special directive @{b}%array@{ub} appears in the first section of
     the scanner description, then @{b}yytext@{ub} is instead declared @{b}char
     yytext[YYLMAX]@{ub}, where @{b}YYLMAX@{ub} is a macro definition that you can
     redefine in the first section if you don't like the default value
     (generally 8KB).  Using @{b}%array@{ub} results in somewhat slower
     scanners, but the value of @{b}yytext@{ub} becomes immune to calls to
     @{b}input()@{ub} and @{b}unput()@{ub}, which potentially destroy its value when
     @{b}yytext@{ub} is a character pointer.  The opposite of @{b}%array@{ub} is
     @{b}%pointer@{ub}, which is the default.

     You cannot use @{b}%array@{ub} when generating C++ scanner classes (the @{b}-+@{ub}
     flag).

   -     @{b}int yyleng@{ub} holds the length of the current token.

   -     @{b}FILE *yyin@{ub} is the file which by default @{b}flex@{ub} reads from.  It
     may be redefined but doing so only makes sense before scanning
     begins or after an EOF has been encountered.  Changing it in the
     midst of scanning will have unexpected results since @{b}flex@{ub} buffers
     its input; use @{b}yyrestart()@{ub} instead.  Once scanning terminates
     because an end-of-file has been seen, you can assign @{b}yyin@{ub} at the
     new input file and then call the scanner again to continue
     scanning.

   -     @{b}void yyrestart( FILE *new_file )@{ub} may be called to point @{b}yyin@{ub}
     at the new input file.  The switch-over to the new file is
     immediate (any previously buffered-up input is lost).  Note that
     calling @{b}yyrestart()@{ub} with @{b}yyin@{ub} as an argument thus throws away the
     current input buffer and continues scanning the same input file.

   -     @{b}FILE *yyout@{ub} is the file to which @{b}ECHO@{ub} actions are done.  It
     can be reassigned by the user.

   -     @{b}YY_CURRENT_BUFFER@{ub} returns a @{b}YY_BUFFER_STATE@{ub} handle to the
     current buffer.

   -     @{b}YY_START@{ub} returns an integer value corresponding to the current
     start condition.  You can subsequently use this value with @{b}BEGIN@{ub}
     to return to that start condition.


@EndNode

@Node "YACC interface" "Flex.guide/YACC interface"
@Next "Options"
@Prev "User variables"
@Toc "Main"

Interfacing with @{b}yacc@{ub}
=====================

   One of the main uses of @{b}flex@{ub} is as a companion to the @{b}yacc@{ub}
parser-generator.  @{b}yacc@{ub} parsers expect to call a routine named @{b}yylex()@{ub}
to find the next input token.  The routine is supposed to return the
type of the next token as well as putting any associated value in the
global @{b}yylval@{ub}.  To use @{b}flex@{ub} with @{b}yacc@{ub}, one specifies the @{b}-d@{ub} option to
@{b}yacc@{ub} to instruct it to generate the file @{b}y.tab.h@{ub} containing definitions
of all the @{b}%tokens@{ub} appearing in the @{b}yacc@{ub} input.  This file is then
included in the @{b}flex@{ub} scanner.  For example, if one of the tokens is
"TOK_NUMBER", part of the scanner might look like:

     %{
     #include "y.tab.h"
     %}
     
     %%
     
     [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;


@EndNode

@Node "Options" "Flex.guide/Options"
@Next "Performance"
@Prev "YACC interface"
@Toc "Main"

Options
=======

   @{b}flex@{ub} has the following options:

@{b}-b@{ub}
     Generate backing-up information to @{b}lex.backup@{ub}.  This is a list of
     scanner states which require backing up and the input characters
     on which they do so.  By adding rules one can remove backing-up
     states.  If @{i}all@{ui} backing-up states are eliminated and @{b}-Cf@{ub} or @{b}-CF@{ub} is
     used, the generated scanner will run faster (see the @{b}-p@{ub} flag).
     Only users who wish to squeeze every last cycle out of their
     scanners need worry about this option.  (See the section on
     Performance Considerations below.)

@{b}-c@{ub}
     is a do-nothing, deprecated option included for POSIX compliance.

@{b}-d@{ub}
     makes the generated scanner run in @{i}debug@{ui} mode.  Whenever a pattern
     is recognized and the global @{b}yy_flex_debug@{ub} is non-zero (which is
     the default), the scanner will write to @{b}stderr@{ub} a line of the form:

          --accepting rule at line 53 ("the matched text")

     The line number refers to the location of the rule in the file
     defining the scanner (i.e., the file that was fed to flex).
     Messages are also generated when the scanner backs up, accepts the
     default rule, reaches the end of its input buffer (or encounters a
     NUL; at this point, the two look the same as far as the scanner's
     concerned), or reaches an end-of-file.

@{b}-f@{ub}
     specifies @{i}fast scanner@{ui}.  No table compression is done and stdio is
     bypassed.  The result is large but fast.  This option is
     equivalent to @{b}-Cfr@{ub} (see below).

@{b}-h@{ub}
     generates a "help" summary of @{b}flex's@{ub} options to @{b}stdout@{ub} and then
     exits.  @{b}-?@{ub} and @{b}-help@{ub} are synonyms for @{b}-h@{ub}.

@{b}-i@{ub}
     instructs @{b}flex@{ub} to generate a @{i}case-insensitive@{ui} scanner.  The case
     of letters given in the @{b}flex@{ub} input patterns will be ignored, and
     tokens in the input will be matched regardless of case.  The
     matched text given in @{b}yytext@{ub} will have the preserved case (i.e.,
     it will not be folded).

@{b}-l@{ub}
     turns on maximum compatibility with the original AT&T @{b}lex@{ub}
     implementation.  Note that this does not mean @{i}full@{ui} compatibility.
     Use of this option costs a considerable amount of performance, and
     it cannot be used with the @{b}-+, -f, -F, -Cf@{ub}, or @{b}-CF@{ub} options.  For
     details on the compatibilities it provides, see the section
     "Incompatibilities With Lex And POSIX" below.  This option also
     results in the name @{b}YY_FLEX_LEX_COMPAT@{ub} being #define'd in the
     generated scanner.

@{b}-n@{ub}
     is another do-nothing, deprecated option included only for POSIX
     compliance.

@{b}-p@{ub}
     generates a performance report to stderr.  The report consists of
     comments regarding features of the @{b}flex@{ub} input file which will
     cause a serious loss of performance in the resulting scanner.  If
     you give the flag twice, you will also get comments regarding
     features that lead to minor performance losses.

     Note that the use of @{b}REJECT@{ub}, @{b}%option yylineno@{ub} and variable
     trailing context (see the Deficiencies / Bugs section below)
     entails a substantial performance penalty; use of @{b}yymore()@{ub}, the @{b}^@{ub}
     operator, and the @{b}-I@{ub} flag entail minor performance penalties.

@{b}-s@{ub}
     causes the @{i}default rule@{ui} (that unmatched scanner input is echoed to
     @{b}stdout@{ub}) to be suppressed.  If the scanner encounters input that
     does not match any of its rules, it aborts with an error.  This
     option is useful for finding holes in a scanner's rule set.

@{b}-t@{ub}
     instructs @{b}flex@{ub} to write the scanner it generates to standard
     output instead of @{b}lex.yy.c@{ub}.

@{b}-v@{ub}
     specifies that @{b}flex@{ub} should write to @{b}stderr@{ub} a summary of statistics
     regarding the scanner it generates.  Most of the statistics are
     meaningless to the casual @{b}flex@{ub} user, but the first line identifies
     the version of @{b}flex@{ub} (same as reported by @{b}-V@{ub}), and the next line
     the flags used when generating the scanner, including those that
     are on by default.

@{b}-w@{ub}
     suppresses warning messages.

@{b}-B@{ub}
     instructs @{b}flex@{ub} to generate a @{i}batch@{ui} scanner, the opposite of
     @{i}interactive@{ui} scanners generated by @{b}-I@{ub} (see below).  In general, you
     use @{b}-B@{ub} when you are @{i}certain@{ui} that your scanner will never be used
     interactively, and you want to squeeze a @{i}little@{ui} more performance
     out of it.  If your goal is instead to squeeze out a @{i}lot@{ui} more
     performance, you should be using the @{b}-Cf@{ub} or @{b}-CF@{ub} options (discussed
     below), which turn on @{b}-B@{ub} automatically anyway.

@{b}-F@{ub}
     specifies that the @{i}fast@{ui} scanner table representation should be
     used (and stdio bypassed).  This representation is about as fast
     as the full table representation @{b}(-f)@{ub}, and for some sets of
     patterns will be considerably smaller (and for others, larger).
     In general, if the pattern set contains both "keywords" and a
     catch-all, "identifier" rule, such as in the set:

          "case"    return TOK_CASE;
          "switch"  return TOK_SWITCH;
          ...
          "default" return TOK_DEFAULT;
          [a-z]+    return TOK_ID;

     then you're better off using the full table representation.  If
     only the "identifier" rule is present and you then use a hash
     table or some such to detect the keywords, you're better off using
     @{b}-F@{ub}.

     This option is equivalent to @{b}-CFr@{ub} (see below).  It cannot be used
     with @{b}-+@{ub}.

@{b}-I@{ub}
     instructs @{b}flex@{ub} to generate an @{i}interactive@{ui} scanner.  An interactive
     scanner is one that only looks ahead to decide what token has been
     matched if it absolutely must.  It turns out that always looking
     one extra character ahead, even if the scanner has already seen
     enough text to disambiguate the current token, is a bit faster
     than only looking ahead when necessary.  But scanners that always
     look ahead give dreadful interactive performance; for example,
     when a user types a newline, it is not recognized as a newline
     token until they enter @{i}another@{ui} token, which often means typing in
     another whole line.

     @{b}Flex@{ub} scanners default to @{i}interactive@{ui} unless you use the @{b}-Cf@{ub} or @{b}-CF@{ub}
     table-compression options (see below).  That's because if you're
     looking for high-performance you should be using one of these
     options, so if you didn't, @{b}flex@{ub} assumes you'd rather trade off a
     bit of run-time performance for intuitive interactive behavior.
     Note also that you @{i}cannot@{ui} use @{b}-I@{ub} in conjunction with @{b}-Cf@{ub} or @{b}-CF@{ub}.
     Thus, this option is not really needed; it is on by default for
     all those cases in which it is allowed.

     You can force a scanner to @{i}not@{ui} be interactive by using @{b}-B@{ub} (see
     above).

@{b}-L@{ub}
     instructs @{b}flex@{ub} not to generate @{b}#line@{ub} directives.  Without this
     option, @{b}flex@{ub} peppers the generated scanner with #line directives
     so error messages in the actions will be correctly located with
     respect to either the original @{b}flex@{ub} input file (if the errors are
     due to code in the input file), or @{b}lex.yy.c@{ub} (if the errors are
     @{b}flex's@{ub} fault - you should report these sorts of errors to the email
     address given below).

@{b}-T@{ub}
     makes @{b}flex@{ub} run in @{b}trace@{ub} mode.  It will generate a lot of messages
     to @{b}stderr@{ub} concerning the form of the input and the resultant
     non-deterministic and deterministic finite automata.  This option
     is mostly for use in maintaining @{b}flex@{ub}.

@{b}-V@{ub}
     prints the version number to @{b}stdout@{ub} and exits.  @{b}-version@{ub} is a
     synonym for @{b}-V@{ub}.

@{b}-7@{ub}
     instructs @{b}flex@{ub} to generate a 7-bit scanner, i.e., one which can
     only recognized 7-bit characters in its input.  The advantage of
     using @{b}-7@{ub} is that the scanner's tables can be up to half the size of
     those generated using the @{b}-8@{ub} option (see below).  The disadvantage
     is that such scanners often hang or crash if their input contains
     an 8-bit character.

     Note, however, that unless you generate your scanner using the @{b}-Cf@{ub}
     or @{b}-CF@{ub} table compression options, use of @{b}-7@{ub} will save only a small
     amount of table space, and make your scanner considerably less
     portable.  @{b}Flex's@{ub} default behavior is to generate an 8-bit scanner
     unless you use the @{b}-Cf@{ub} or @{b}-CF@{ub}, in which case @{b}flex@{ub} defaults to
     generating 7-bit scanners unless your site was always configured to
     generate 8-bit scanners (as will often be the case with non-USA
     sites).  You can tell whether flex generated a 7-bit or an 8-bit
     scanner by inspecting the flag summary in the @{b}-v@{ub} output as
     described above.

     Note that if you use @{b}-Cfe@{ub} or @{b}-CFe@{ub} (those table compression
     options, but also using equivalence classes as discussed see
     below), flex still defaults to generating an 8-bit scanner, since
     usually with these compression options full 8-bit tables are not
     much more expensive than 7-bit tables.

@{b}-8@{ub}
     instructs @{b}flex@{ub} to generate an 8-bit scanner, i.e., one which can
     recognize 8-bit characters.  This flag is only needed for scanners
     generated using @{b}-Cf@{ub} or @{b}-CF@{ub}, as otherwise flex defaults to
     generating an 8-bit scanner anyway.

     See the discussion of @{b}-7@{ub} above for flex's default behavior and the
     tradeoffs between 7-bit and 8-bit scanners.

@{b}-+@{ub}
     specifies that you want flex to generate a C++ scanner class.  See
     the section on Generating C++ Scanners below for details.

@{b}-C[aefFmr]@{ub}
     controls the degree of table compression and, more generally,
     trade-offs between small scanners and fast scanners.

     @{b}-Ca@{ub} ("align") instructs flex to trade off larger tables in the
     generated scanner for faster performance because the elements of
     the tables are better aligned for memory access and computation.
     On some RISC architectures, fetching and manipulating long-words
     is more efficient than with smaller-sized units such as
     shortwords.  This option can double the size of the tables used by
     your scanner.

     @{b}-Ce@{ub} directs @{b}flex@{ub} to construct @{i}equivalence classes@{ui}, i.e., sets of
     characters which have identical lexical properties (for example,
     if the only appearance of digits in the @{b}flex@{ub} input is in the
     character class "[0-9]" then the digits '0', '1', ..., '9' will
     all be put in the same equivalence class).  Equivalence classes
     usually give dramatic reductions in the final table/object file
     sizes (typically a factor of 2-5) and are pretty cheap
     performance-wise (one array look-up per character scanned).

     @{b}-Cf@{ub} specifies that the @{i}full@{ui} scanner tables should be generated -
     @{b}flex@{ub} should not compress the tables by taking advantages of
     similar transition functions for different states.

     @{b}-CF@{ub} specifies that the alternate fast scanner representation
     (described above under the @{b}-F@{ub} flag) should be used.  This option
     cannot be used with @{b}-+@{ub}.

     @{b}-Cm@{ub} directs @{b}flex@{ub} to construct @{i}meta-equivalence classes@{ui}, which are
     sets of equivalence classes (or characters, if equivalence classes
     are not being used) that are commonly used together.
     Meta-equivalence classes are often a big win when using compressed
     tables, but they have a moderate performance impact (one or two
     "if" tests and one array look-up per character scanned).

     @{b}-Cr@{ub} causes the generated scanner to @{i}bypass@{ui} use of the standard I/O
     library (stdio) for input.  Instead of calling @{b}fread()@{ub} or @{b}getc()@{ub},
     the scanner will use the @{b}read()@{ub} system call, resulting in a
     performance gain which varies from system to system, but in
     general is probably negligible unless you are also using @{b}-Cf@{ub} or
     @{b}-CF@{ub}.  Using @{b}-Cr@{ub} can cause strange behavior if, for example,
     you read from @{b}yyin@{ub} using stdio prior to calling the scanner
     (because the scanner will miss whatever text your previous reads
     left in the stdio input buffer).

     @{b}-Cr@{ub} has no effect if you define @{b}YY_INPUT@{ub} (see The Generated
     Scanner above).

     A lone @{b}-C@{ub} specifies that the scanner tables should be compressed
     but neither equivalence classes nor meta-equivalence classes
     should be used.

     The options @{b}-Cf@{ub} or @{b}-CF@{ub} and @{b}-Cm@{ub} do not make sense together - there
     is no opportunity for meta-equivalence classes if the table is not
     being compressed.  Otherwise the options may be freely mixed, and
     are cumulative.

     The default setting is @{b}-Cem@{ub}, which specifies that @{b}flex@{ub} should
     generate equivalence classes and meta-equivalence classes.  This
     setting provides the highest degree of table compression.  You can
     trade off faster-executing scanners at the cost of larger tables
     with the following generally being true:

          slowest & smallest
                -Cem
                -Cm
                -Ce
                -C
                -C{f,F}e
                -C{f,F}
                -C{f,F}a
          fastest & largest

     Note that scanners with the smallest tables are usually generated
     and compiled the quickest, so during development you will usually
     want to use the default, maximal compression.

     @{b}-Cfe@{ub} is often a good compromise between speed and size for
     production scanners.

@{b}-ooutput@{ub}
     directs flex to write the scanner to the file @{b}out-@{ub} @{b}put@{ub} instead of
     @{b}lex.yy.c@{ub}.  If you combine @{b}-o@{ub} with the @{b}-t@{ub} option, then the scanner
     is written to @{b}stdout@{ub} but its @{b}#line@{ub} directives (see the @{b}-L@{ub} option
     above) refer to the file @{b}output@{ub}.

@{b}-Pprefix@{ub}
     changes the default @{b}yy@{ub} prefix used by @{b}flex@{ub} for all
     globally-visible variable and function names to instead be @{i}prefix@{ui}.
     For example, @{b}-Pfoo@{ub} changes the name of @{b}yytext@{ub} to @{b}footext@{ub}.  It
     also changes the name of the default output file from @{b}lex.yy.c@{ub} to
     @{b}lex.foo.c@{ub}.  Here are all of the names affected:

          yy_create_buffer
          yy_delete_buffer
          yy_flex_debug
          yy_init_buffer
          yy_flush_buffer
          yy_load_buffer_state
          yy_switch_to_buffer
          yyin
          yyleng
          yylex
          yylineno
          yyout
          yyrestart
          yytext
          yywrap

     (If you are using a C++ scanner, then only @{b}yywrap@{ub} and @{b}yyFlexLexer@{ub}
     are affected.) Within your scanner itself, you can still refer to
     the global variables and functions using either version of their
     name; but externally, they have the modified name.

     This option lets you easily link together multiple @{b}flex@{ub} programs
     into the same executable.  Note, though, that using this option
     also renames @{b}yywrap()@{ub}, so you now @{i}must@{ui} either provide your own
     (appropriately-named) version of the routine for your scanner, or
     use @{b}%option noyywrap@{ub}, as linking with @{b}-lfl@{ub} no longer provides one
     for you by default.

@{b}-Sskeleton_file@{ub}
     overrides the default skeleton file from which @{b}flex@{ub} constructs its
     scanners.  You'll never need this option unless you are doing @{b}flex@{ub}
     maintenance or development.

   @{b}flex@{ub} also provides a mechanism for controlling options within the
scanner specification itself, rather than from the flex command-line.
This is done by including @{b}%option@{ub} directives in the first section of
the scanner specification.  You can specify multiple options with a
single @{b}%option@{ub} directive, and multiple directives in the first section
of your flex input file.  Most options are given simply as names,
optionally preceded by the word "no" (with no intervening whitespace)
to negate their meaning.  A number are equivalent to flex flags or
their negation:

     7bit            -7 option
     8bit            -8 option
     align           -Ca option
     backup          -b option
     batch           -B option
     c++             -+ option
     
     caseful or
     case-sensitive  opposite of -i (default)
     
     case-insensitive or
     caseless        -i option
     
     debug           -d option
     default         opposite of -s option
     ecs             -Ce option
     fast            -F option
     full            -f option
     interactive     -I option
     lex-compat      -l option
     meta-ecs        -Cm option
     perf-report     -p option
     read            -Cr option
     stdout          -t option
     verbose         -v option
     warn            opposite of -w option
                     (use "%option nowarn" for -w)
     
     array           equivalent to "%array"
     pointer         equivalent to "%pointer" (default)

   Some @{b}%option's@{ub} provide features otherwise not available:

@{b}always-interactive@{ub}
     instructs flex to generate a scanner which always considers its
     input "interactive".  Normally, on each new input file the scanner
     calls @{b}isatty()@{ub} in an attempt to determine whether the scanner's
     input source is interactive and thus should be read a character at
     a time.  When this option is used, however, then no such call is
     made.

@{b}main@{ub}
     directs flex to provide a default @{b}main()@{ub} program for the scanner,
     which simply calls @{b}yylex()@{ub}.  This option implies @{b}noyywrap@{ub} (see
     below).

@{b}never-interactive@{ub}
     instructs flex to generate a scanner which never considers its
     input "interactive" (again, no call made to @{b}isatty())@{ub}.  This is
     the opposite of @{b}always-@{ub} @{i}interactive@{ui}.

@{b}stack@{ub}
     enables the use of start condition stacks (see Start Conditions
     above).

@{b}stdinit@{ub}
     if unset (i.e., @{b}%option nostdinit@{ub}) initializes @{b}yyin@{ub} and @{b}yyout@{ub} to
     nil @{b}FILE@{ub} pointers, instead of @{b}stdin@{ub} and @{b}stdout@{ub}.

@{b}yylineno@{ub}
     directs @{b}flex@{ub} to generate a scanner that maintains the number of
     the current line read from its input in the global variable
     @{b}yylineno@{ub}.  This option is implied by @{b}%option lex-compat@{ub}.

@{b}yywrap@{ub}
     if unset (i.e., @{b}%option noyywrap@{ub}), makes the scanner not call
     @{b}yywrap()@{ub} upon an end-of-file, but simply assume that there are no
     more files to scan (until the user points @{b}yyin@{ub} at a new file and
     calls @{b}yylex()@{ub} again).

   @{b}flex@{ub} scans your rule actions to determine whether you use the @{b}REJECT@{ub}
or @{b}yymore()@{ub} features.  The @{b}reject@{ub} and @{b}yymore@{ub} options are available to
override its decision as to whether you use the options, either by
setting them (e.g., @{b}%option reject@{ub}) to indicate the feature is indeed
used, or unsetting them to indicate it actually is not used (e.g.,
@{b}%option noyymore@{ub}).

   Three options take string-delimited values, offset with '=':

     %option outfile="ABC"

is equivalent to @{b}-oABC@{ub}, and

     %option prefix="XYZ"

is equivalent to @{b}-PXYZ@{ub}.

   Finally,

     %option yyclass="foo"

only applies when generating a C++ scanner (@{b}-+@{ub} option).  It informs
@{b}flex@{ub} that you have derived @{b}foo@{ub} as a subclass of @{b}yyFlexLexer@{ub} so @{b}flex@{ub}
will place your actions in the member function @{b}foo::yylex()@{ub} instead of
@{b}yyFlexLexer::yylex()@{ub}.  It also generates a @{b}yyFlexLexer::yylex()@{ub} member
function that emits a run-time error (by invoking
@{b}yyFlexLexer::LexerError()@{ub}) if called.  See Generating C++ Scanners,
below, for additional information.

   A number of options are available for lint purists who want to
suppress the appearance of unneeded routines in the generated scanner.
Each of the following, if unset, results in the corresponding routine
not appearing in the generated scanner:

     input, unput
     yy_push_state, yy_pop_state, yy_top_state
     yy_scan_buffer, yy_scan_bytes, yy_scan_string

(though @{b}yy_push_state()@{ub} and friends won't appear anyway unless you use
@{b}%option stack@{ub}).


@EndNode

@Node "Performance" "Flex.guide/Performance"
@Next "C++"
@Prev "Options"
@Toc "Main"

Performance considerations
==========================

   The main design goal of @{b}flex@{ub} is that it generate high-performance
scanners.  It has been optimized for dealing well with large sets of
rules.  Aside from the effects on scanner speed of the table
compression @{b}-C@{ub} options outlined above, there are a number of
options/actions which degrade performance.  These are, from most
expensive to least:

     REJECT
     %option yylineno
     arbitrary trailing context
     
     pattern sets that require backing up
     %array
     %option interactive
     %option always-interactive
     
     '^' beginning-of-line operator
     yymore()

   with the first three all being quite expensive and the last two
being quite cheap.  Note also that @{b}unput()@{ub} is implemented as a routine
call that potentially does quite a bit of work, while @{b}yyless()@{ub} is a
quite-cheap macro; so if just putting back some excess text you
scanned, use @{b}yyless()@{ub}.

   @{b}REJECT@{ub} should be avoided at all costs when performance is important.
It is a particularly expensive option.

   Getting rid of backing up is messy and often may be an enormous
amount of work for a complicated scanner.  In principal, one begins by
using the @{b}-b@{ub} flag to generate a @{b}lex.backup@{ub} file.  For example, on the
input

     %%
     foo        return TOK_KEYWORD;
     foobar     return TOK_KEYWORD;

the file looks like:

     State #6 is non-accepting -
      associated rule line numbers:
            2       3
      out-transitions: [ o ]
      jam-transitions: EOF [ \001-n  p-\177 ]
     
     State #8 is non-accepting -
      associated rule line numbers:
            3
      out-transitions: [ a ]
      jam-transitions: EOF [ \001-`  b-\177 ]
     
     State #9 is non-accepting -
      associated rule line numbers:
            3
      out-transitions: [ r ]
      jam-transitions: EOF [ \001-q  s-\177 ]
     
     Compressed tables always back up.

   The first few lines tell us that there's a scanner state in which it
can make a transition on an 'o' but not on any other character, and
that in that state the currently scanned text does not match any rule.
The state occurs when trying to match the rules found at lines 2 and 3
in the input file.  If the scanner is in that state and then reads
something other than an 'o', it will have to back up to find a rule
which is matched.  With a bit of head-scratching one can see that this
must be the state it's in when it has seen "fo".  When this has
happened, if anything other than another 'o' is seen, the scanner will
have to back up to simply match the 'f' (by the default rule).

   The comment regarding State #8 indicates there's a problem when
"foob" has been scanned.  Indeed, on any character other than an 'a',
the scanner will have to back up to accept "foo".  Similarly, the
comment for State #9 concerns when "fooba" has been scanned and an 'r'
does not follow.

   The final comment reminds us that there's no point going to all the
trouble of removing backing up from the rules unless we're using @{b}-Cf@{ub} or
@{b}-CF@{ub}, since there's no performance gain doing so with compressed
scanners.

   The way to remove the backing up is to add "error" rules:

     %%
     foo         return TOK_KEYWORD;
     foobar      return TOK_KEYWORD;
     
     fooba       |
     foob        |
     fo          {
                 /* false alarm, not really a keyword */
                 return TOK_ID;
                 }

   Eliminating backing up among a list of keywords can also be done
using a "catch-all" rule:

     %%
     foo         return TOK_KEYWORD;
     foobar      return TOK_KEYWORD;
     
     [a-z]+      return TOK_ID;

   This is usually the best solution when appropriate.

   Backing up messages tend to cascade.  With a complicated set of
rules it's not uncommon to get hundreds of messages.  If one can
decipher them, though, it often only takes a dozen or so rules to
eliminate the backing up (though it's easy to make a mistake and have
an error rule accidentally match a valid token.  A possible future @{b}flex@{ub}
feature will be to automatically add rules to eliminate backing up).

   It's important to keep in mind that you gain the benefits of
eliminating backing up only if you eliminate @{i}every@{ui} instance of backing
up.  Leaving just one means you gain nothing.

   @{i}Variable@{ui} trailing context (where both the leading and trailing parts
do not have a fixed length) entails almost the same performance loss as
@{b}REJECT@{ub} (i.e., substantial).  So when possible a rule like:

     %%
     mouse|rat/(cat|dog)   run();

is better written:

     %%
     mouse/cat|dog         run();
     rat/cat|dog           run();

or as

     %%
     mouse|rat/cat         run();
     mouse|rat/dog         run();

   Note that here the special '|' action does @{i}not@{ui} provide any savings,
and can even make things worse (see Deficiencies / Bugs below).

   Another area where the user can increase a scanner's performance
(and one that's easier to implement) arises from the fact that the
longer the tokens matched, the faster the scanner will run.  This is
because with long tokens the processing of most input characters takes
place in the (short) inner scanning loop, and does not often have to go
through the additional work of setting up the scanning environment
(e.g., @{b}yytext@{ub}) for the action.  Recall the scanner for C comments:

     %x comment
     %%
             int line_num = 1;
     
     "/*"         BEGIN(comment);
     
     <comment>[^*\n]*
     <comment>"*"+[^*/\n]*
     <comment>\n             ++line_num;
     <comment>"*"+"/"        BEGIN(INITIAL);

   This could be sped up by writing it as:

     %x comment
     %%
             int line_num = 1;
     
     "/*"         BEGIN(comment);
     
     <comment>[^*\n]*
     <comment>[^*\n]*\n      ++line_num;
     <comment>"*"+[^*/\n]*
     <comment>"*"+[^*/\n]*\n ++line_num;
     <comment>"*"+"/"        BEGIN(INITIAL);

   Now instead of each newline requiring the processing of another
action, recognizing the newlines is "distributed" over the other rules
to keep the matched text as long as possible.  Note that @{i}adding@{ui} rules
does @{i}not@{ui} slow down the scanner!  The speed of the scanner is
independent of the number of rules or (modulo the considerations given
at the beginning of this section) how complicated the rules are with
regard to operators such as '*' and '|'.

   A final example in speeding up a scanner: suppose you want to scan
through a file containing identifiers and keywords, one per line and
with no other extraneous characters, and recognize all the keywords.  A
natural first approach is:

     %%
     asm      |
     auto     |
     break    |
     ... etc ...
     volatile |
     while    /* it's a keyword */
     
     .|\n     /* it's not a keyword */

   To eliminate the back-tracking, introduce a catch-all rule:

     %%
     asm      |
     auto     |
     break    |
     ... etc ...
     volatile |
     while    /* it's a keyword */
     
     [a-z]+   |
     .|\n     /* it's not a keyword */

   Now, if it's guaranteed that there's exactly one word per line, then
we can reduce the total number of matches by a half by merging in the
recognition of newlines with that of the other tokens:

     %%
     asm\n    |
     auto\n   |
     break\n  |
     ... etc ...
     volatile\n |
     while\n  /* it's a keyword */
     
     [a-z]+\n |
     .|\n     /* it's not a keyword */

   One has to be careful here, as we have now reintroduced backing up
into the scanner.  In particular, while @{i}we@{ui} know that there will never
be any characters in the input stream other than letters or newlines,
@{b}flex@{ub} can't figure this out, and it will plan for possibly needing to
back up when it has scanned a token like "auto" and then the next
character is something other than a newline or a letter.  Previously it
would then just match the "auto" rule and be done, but now it has no
"auto" rule, only a "auto\n" rule.  To eliminate the possibility of
backing up, we could either duplicate all rules but without final
newlines, or, since we never expect to encounter such an input and
therefore don't how it's classified, we can introduce one more
catch-all rule, this one which doesn't include a newline:

     %%
     asm\n    |
     auto\n   |
     break\n  |
     ... etc ...
     volatile\n |
     while\n  /* it's a keyword */
     
     [a-z]+\n |
     [a-z]+   |
     .|\n     /* it's not a keyword */

   Compiled with @{b}-Cf@{ub}, this is about as fast as one can get a @{b}flex@{ub}
scanner to go for this particular problem.

   A final note: @{b}flex@{ub} is slow when matching NUL's, particularly when a
token contains multiple NUL's.  It's best to write rules which match
@{i}short@{ui} amounts of text if it's anticipated that the text will often
include NUL's.

   Another final note regarding performance: as mentioned above in the
section How the Input is Matched, dynamically resizing @{b}yytext@{ub} to
accommodate huge tokens is a slow process because it presently requires
that the (huge) token be rescanned from the beginning.  Thus if
performance is vital, you should attempt to match "large" quantities of
text but not "huge" quantities, where the cutoff between the two is at
about 8K characters/token.


@EndNode

@Node "C++" "Flex.guide/C++"
@Next "Incompatibilities"
@Prev "Performance"
@Toc "Main"

Generating C++ scanners
=======================

   @{b}flex@{ub} provides two different ways to generate scanners for use with
C++.  The first way is to simply compile a scanner generated by @{b}flex@{ub}
using a C++ compiler instead of a C compiler.  You should not encounter
any compilations errors (please report any you find to the email address
given in the Author section below).  You can then use C++ code in your
rule actions instead of C code.  Note that the default input source for
your scanner remains @{b}yyin@{ub}, and default echoing is still done to @{b}yyout@{ub}.
Both of these remain @{b}FILE *@{ub} variables and not C++ @{b}streams@{ub}.

   You can also use @{b}flex@{ub} to generate a C++ scanner class, using the @{b}-+@{ub}
option, (or, equivalently, @{b}%option c++@{ub}), which is automatically
specified if the name of the flex executable ends in a @{b}+@{ub}, such as
@{b}flex++@{ub}.  When using this option, flex defaults to generating the
scanner to the file @{b}lex.yy.cc@{ub} instead of @{b}lex.yy.c@{ub}.  The generated
scanner includes the header file @{b}FlexLexer.h@{ub}, which defines the
interface to two C++ classes.

   The first class, @{b}FlexLexer@{ub}, provides an abstract base class defining
the general scanner class interface.  It provides the following member
functions:

@{b}const char* YYText()@{ub}
     returns the text of the most recently matched token, the
     equivalent of @{b}yytext@{ub}.

@{b}int YYLeng()@{ub}
     returns the length of the most recently matched token, the
     equivalent of @{b}yyleng@{ub}.

@{b}int lineno() const@{ub}
     returns the current input line number (see @{b}%option yylineno@{ub}), or 1
     if @{b}%option yylineno@{ub} was not used.

@{b}void set_debug( int flag )@{ub}
     sets the debugging flag for the scanner, equivalent to assigning to
     @{b}yy_flex_debug@{ub} (see the Options section above).  Note that you must
     build the scanner using @{b}%option debug@{ub} to include debugging
     information in it.

@{b}int debug() const@{ub}
     returns the current setting of the debugging flag.

   Also provided are member functions equivalent to
@{b}yy_switch_to_buffer(), yy_create_buffer()@{ub} (though the first argument is
an @{b}istream*@{ub} object pointer and not a @{b}FILE*@{ub}, @{b}yy_flush_buffer()@{ub},
@{b}yy_delete_buffer()@{ub}, and @{b}yyrestart()@{ub} (again, the first argument is a
@{b}istream*@{ub} object pointer).

   The second class defined in @{b}FlexLexer.h@{ub} is @{b}yyFlexLexer@{ub}, which is
derived from @{b}FlexLexer@{ub}.  It defines the following additional member
functions:

@{b}yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )@{ub}
     constructs a @{b}yyFlexLexer@{ub} object using the given streams for input
     and output.  If not specified, the streams default to @{b}cin@{ub} and
     @{b}cout@{ub}, respectively.

@{b}virtual int yylex()@{ub}
     performs the same role is @{b}yylex()@{ub} does for ordinary flex scanners:
     it scans the input stream, consuming tokens, until a rule's action
     returns a value.  If you derive a subclass @{i}S@{ui} from @{b}yyFlexLexer@{ub} and
     want to access the member functions and variables of @{i}S@{ui} inside
     @{b}yylex()@{ub}, then you need to use @{b}%option yyclass="@{i}S@{ui}"@{ub} to inform @{b}flex@{ub}
     that you will be using that subclass instead of @{b}yyFlexLexer@{ub}.  In
     this case, rather than generating @{b}yyFlexLexer::yylex()@{ub}, @{b}flex@{ub}
     generates @{b}@{i}S@{ui}::yylex()@{ub} (and also generates a dummy
     @{b}yyFlexLexer::yylex()@{ub} that calls @{b}yyFlexLexer::LexerError()@{ub} if
     called).

@{b}virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)@{ub}
     reassigns @{b}yyin@{ub} to @{b}new_in@{ub} (if non-nil) and @{b}yyout@{ub} to @{b}new_out@{ub}
     (ditto), deleting the previous input buffer if @{b}yyin@{ub} is reassigned.

@{b}int yylex( istream* new_in = 0, ostream* new_out = 0 )@{ub}
     first switches the input streams via @{b}switch_streams( new_in,
     new_out )@{ub} and then returns the value of @{b}yylex()@{ub}.

   In addition, @{b}yyFlexLexer@{ub} defines the following protected virtual
functions which you can redefine in derived classes to tailor the
scanner:

@{b}virtual int LexerInput( char* buf, int max_size )@{ub}
     reads up to @{b}max_size@{ub} characters into @{i}buf@{ui} and returns the number of
     characters read.  To indicate end-of-input, return 0 characters.
     Note that "interactive" scanners (see the @{b}-B@{ub} and @{b}-I@{ub} flags) define
     the macro @{b}YY_INTERACTIVE@{ub}.  If you redefine @{b}LexerInput()@{ub} and need
     to take different actions depending on whether or not the scanner
     might be scanning an interactive input source, you can test for
     the presence of this name via @{b}#ifdef@{ub}.

@{b}virtual void LexerOutput( const char* buf, int size )@{ub}
     writes out @{i}size@{ui} characters from the buffer @{i}buf@{ui}, which, while
     NUL-terminated, may also contain "internal" NUL's if the scanner's
     rules can match text with NUL's in them.

@{b}virtual void LexerError( const char* msg )@{ub}
     reports a fatal error message.  The default version of this
     function writes the message to the stream @{b}cerr@{ub} and exits.

   Note that a @{b}yyFlexLexer@{ub} object contains its @{i}entire@{ui} scanning state.
Thus you can use such objects to create reentrant scanners.  You can
instantiate multiple instances of the same @{b}yyFlexLexer@{ub} class, and you
can also combine multiple C++ scanner classes together in the same
program using the @{b}-P@{ub} option discussed above.  Finally, note that the
@{b}%array@{ub} feature is not available to C++ scanner classes; you must use
@{b}%pointer@{ub} (the default).

   Here is an example of a simple C++ scanner:

         // An example of using the flex C++ scanner class.
     
     %{
     int mylineno = 0;
     %}
     
     string  \"[^\n"]+\"
     
     ws      [ \t]+
     
     alpha   [A-Za-z]
     dig     [0-9]
     name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
     num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
     num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
     number  {num1}|{num2}
     
     %%
     
     {ws}    /* skip blanks and tabs */
     
     "/*"    {
             int c;
     
             while((c = yyinput()) != 0)
                 {
                 if(c == '\n')
                     ++mylineno;
     
                 else if(c == '*')
                     {
                     if((c = yyinput()) == '/')
                         break;
                     else
                         unput(c);
                     }
                 }
             }
     
     {number}  cout << "number " << YYText() << '\n';
     
     \n        mylineno++;
     
     {name}    cout << "name " << YYText() << '\n';
     
     {string}  cout << "string " << YYText() << '\n';
     
     %%
     
     Version 2.5               December 1994                        44
     
     int main( int /* argc */, char** /* argv */ )
         {
         FlexLexer* lexer = new yyFlexLexer;
         while(lexer->yylex() != 0)
             ;
         return 0;
         }

   If you want to create multiple (different) lexer classes, you use
the @{b}-P@{ub} flag (or the @{b}prefix=@{ub} option) to rename each @{b}yyFlexLexer@{ub} to some
other @{b}xxFlexLexer@{ub}.  You then can include @{b}<FlexLexer.h>@{ub} in your other
sources once per lexer class, first renaming @{b}yyFlexLexer@{ub} as follows:

     #undef yyFlexLexer
     #define yyFlexLexer xxFlexLexer
     #include <FlexLexer.h>
     
     #undef yyFlexLexer
     #define yyFlexLexer zzFlexLexer
     #include <FlexLexer.h>

   if, for example, you used @{b}%option prefix="xx"@{ub} for one of your
scanners and @{b}%option prefix="zz"@{ub} for the other.

   IMPORTANT: the present form of the scanning class is @{i}experimental@{ui}
and may change considerably between major releases.


@EndNode

@Node "Incompatibilities" "Flex.guide/Incompatibilities"
@Next "Diagnostics"
@Prev "C++"
@Toc "Main"

Incompatibilities with @{b}lex@{ub} and POSIX
====================================

   @{b}flex@{ub} is a rewrite of the AT&T Unix @{b}lex@{ub} tool (the two implementations
do not share any code, though), with some extensions and
incompatibilities, both of which are of concern to those who wish to
write scanners acceptable to either implementation.  Flex is fully
compliant with the POSIX @{b}lex@{ub} specification, except that when using
@{b}%pointer@{ub} (the default), a call to @{b}unput()@{ub} destroys the contents of
@{b}yytext@{ub}, which is counter to the POSIX specification.

   In this section we discuss all of the known areas of incompatibility
between flex, AT&T lex, and the POSIX specification.

   @{b}flex's@{ub} @{b}-l@{ub} option turns on maximum compatibility with the original
AT&T @{b}lex@{ub} implementation, at the cost of a major loss in the generated
scanner's performance.  We note below which incompatibilities can be
overcome using the @{b}-l@{ub} option.

   @{b}flex@{ub} is fully compatible with @{b}lex@{ub} with the following exceptions:

   - The undocumented @{b}lex@{ub} scanner internal variable @{b}yylineno@{ub} is not
     supported unless @{b}-l@{ub} or @{b}%option yylineno@{ub} is used.  @{b}yylineno@{ub} should
     be maintained on a per-buffer basis, rather than a per-scanner
     (single global variable) basis.  @{b}yylineno@{ub} is not part of the POSIX
     specification.

   - The @{b}input()@{ub} routine is not redefinable, though it may be called to
     read characters following whatever has been matched by a rule.  If
     @{b}input()@{ub} encounters an end-of-file the normal @{b}yywrap()@{ub} processing is
     done.  A "real" end-of-file is returned by @{b}input()@{ub} as @{b}EOF@{ub}.

     Input is instead controlled by defining the @{b}YY_INPUT@{ub} macro.

     The @{b}flex@{ub} restriction that @{b}input()@{ub} cannot be redefined is in
     accordance with the POSIX specification, which simply does not
     specify any way of controlling the scanner's input other than by
     making an initial assignment to @{b}yyin@{ub}.

   - The @{b}unput()@{ub} routine is not redefinable.  This restriction is in
     accordance with POSIX.

   -     @{b}flex@{ub} scanners are not as reentrant as @{b}lex@{ub} scanners.  In
     particular, if you have an interactive scanner and an interrupt
     handler which long-jumps out of the scanner, and the scanner is
     subsequently called again, you may get the following message:

          fatal flex scanner internal error--end of buffer missed

     To reenter the scanner, first use

          yyrestart( yyin );

     Note that this call will throw away any buffered input; usually
     this isn't a problem with an interactive scanner.

     Also note that flex C++ scanner classes @{i}are@{ui} reentrant, so if using
     C++ is an option for you, you should use them instead.  See
     "Generating C++ Scanners" above for details.

   -     @{b}output()@{ub} is not supported.  Output from the @{b}ECHO@{ub} macro is done
     to the file-pointer @{b}yyout@{ub} (default @{b}stdout@{ub}).

     @{b}output()@{ub} is not part of the POSIX specification.

   -     @{b}lex@{ub} does not support exclusive start conditions (%x), though
     they are in the POSIX specification.

   - When definitions are expanded, @{b}flex@{ub} encloses them in parentheses.
     With lex, the following:

          NAME    [A-Z][A-Z0-9]*
          %%
          foo{NAME}?      printf( "Found it\n" );
          %%

     will not match the string "foo" because when the macro is expanded
     the rule is equivalent to "foo[A-Z][A-Z0-9]*?" and the precedence
     is such that the '?' is associated with "[A-Z0-9]*".  With @{b}flex@{ub},
     the rule will be expanded to "foo([A-Z][A-Z0-9]*)?" and so the
     string "foo" will match.

     Note that if the definition begins with @{b}^@{ub} or ends with @{b}$@{ub} then it
     is @{i}not@{ui} expanded with parentheses, to allow these operators to
     appear in definitions without losing their special meanings.  But
     the @{b}<s>, /@{ub}, and @{b}<<EOF>>@{ub} operators cannot be used in a @{b}flex@{ub}
     definition.

     Using @{b}-l@{ub} results in the @{b}lex@{ub} behavior of no parentheses around the
     definition.

     The POSIX specification is that the definition be enclosed in
     parentheses.

   - Some implementations of @{b}lex@{ub} allow a rule's action to begin on a
     separate line, if the rule's pattern has trailing whitespace:

          %%
          foo|bar<space here>
            { foobar_action(); }

     @{b}flex@{ub} does not support this feature.

   - The @{b}lex@{ub} @{b}%r@{ub} (generate a Ratfor scanner) option is not supported.
     It is not part of the POSIX specification.

   - After a call to @{b}unput()@{ub}, @{b}yytext@{ub} is undefined until the next token
     is matched, unless the scanner was built using @{b}%array@{ub}.  This is
     not the case with @{b}lex@{ub} or the POSIX specification.  The @{b}-l@{ub} option
     does away with this incompatibility.

   - The precedence of the @{b}{}@{ub} (numeric range) operator is different.
     @{b}lex@{ub} interprets "abc{1,3}" as "match one, two, or three occurrences
     of 'abc'", whereas @{b}flex@{ub} interprets it as "match 'ab' followed by
     one, two, or three occurrences of 'c'".  The latter is in
     agreement with the POSIX specification.

   - The precedence of the @{b}^@{ub} operator is different.  @{b}lex@{ub} interprets
     "^foo|bar" as "match either 'foo' at the beginning of a line, or
     'bar' anywhere", whereas @{b}flex@{ub} interprets it as "match either 'foo'
     or 'bar' if they come at the beginning of a line".  The latter is
     in agreement with the POSIX specification.

   - The special table-size declarations such as @{b}%a@{ub} supported by @{b}lex@{ub}
     are not required by @{b}flex@{ub} scanners; @{b}flex@{ub} ignores them.

   - The name FLEX_SCANNER is #define'd so scanners may be written for
     use with either @{b}flex@{ub} or @{b}lex@{ub}.  Scanners also include
     @{b}YY_FLEX_MAJOR_VERSION@{ub} and @{b}YY_FLEX_MINOR_VERSION@{ub} indicating which
     version of @{b}flex@{ub} generated the scanner (for example, for the 2.5
     release, these defines would be 2 and 5 respectively).

   The following @{b}flex@{ub} features are not included in @{b}lex@{ub} or the POSIX
specification:

     C++ scanners
     %option
     start condition scopes
     start condition stacks
     interactive/non-interactive scanners
     yy_scan_string() and friends
     yyterminate()
     yy_set_interactive()
     yy_set_bol()
     YY_AT_BOL()
     <<EOF>>
     <*>
     YY_DECL
     YY_START
     YY_USER_ACTION
     YY_USER_INIT
     #line directives
     %{}'s around actions
     multiple actions on a line

plus almost all of the flex flags.  The last feature in the list refers
to the fact that with @{b}flex@{ub} you can put multiple actions on the same
line, separated with semicolons, while with @{b}lex@{ub}, the following

     foo    handle_foo(); ++num_foos_seen;

is (rather surprisingly) truncated to

     foo    handle_foo();

   @{b}flex@{ub} does not truncate the action.  Actions that are not enclosed in
braces are simply terminated at the end of the line.


@EndNode

@Node "Diagnostics" "Flex.guide/Diagnostics"
@Next "Files"
@Prev "Incompatibilities"
@Toc "Main"

Diagnostics
===========

@{b}warning, rule cannot be matched@{ub}
     indicates that the given rule cannot be matched because it follows
     other rules that will always match the same text as it.  For
     example, in the following "foo" cannot be matched because it comes
     after an identifier "catch-all" rule:

          [a-z]+    got_identifier();
          foo       got_foo();

     Using @{b}REJECT@{ub} in a scanner suppresses this warning.

@{b}warning, -s option given but default rule can be matched@{ub}
     means that it is possible (perhaps only in a particular start
     condition) that the default rule (match any single character) is
     the only one that will match a particular input.  Since @{b}-s@{ub} was
     given, presumably this is not intended.

@{b}reject_used_but_not_detected undefined@{ub}
@{b}yymore_used_but_not_detected undefined@{ub}
     These errors can occur at compile time.  They indicate that the
     scanner uses @{b}REJECT@{ub} or @{b}yymore()@{ub} but that @{b}flex@{ub} failed to notice the
     fact, meaning that @{b}flex@{ub} scanned the first two sections looking for
     occurrences of these actions and failed to find any, but somehow
     you snuck some in (via a #include file, for example).  Use @{b}%option
     reject@{ub} or @{b}%option yymore@{ub} to indicate to flex that you really do
     use these features.

@{b}flex scanner jammed@{ub}
     a scanner compiled with @{b}-s@{ub} has encountered an input string which
     wasn't matched by any of its rules.  This error can also occur due
     to internal problems.

@{b}token too large, exceeds YYLMAX@{ub}
     your scanner uses @{b}%array@{ub} and one of its rules matched a string
     longer than the @{b}YYL-@{ub} @{b}MAX@{ub} constant (8K bytes by default).  You can
     increase the value by #define'ing @{b}YYLMAX@{ub} in the definitions
     section of your @{b}flex@{ub} input.

@{b}scanner requires -8 flag to use the character '@{i}x@{ui}'@{ub}
     Your scanner specification includes recognizing the 8-bit
     character @{i}x@{ui} and you did not specify the -8 flag, and your scanner
     defaulted to 7-bit because you used the @{b}-Cf@{ub} or @{b}-CF@{ub} table
     compression options.  See the discussion of the @{b}-7@{ub} flag for
     details.

@{b}flex scanner push-back overflow@{ub}
     you used @{b}unput()@{ub} to push back so much text that the scanner's
     buffer could not hold both the pushed-back text and the current
     token in @{b}yytext@{ub}.  Ideally the scanner should dynamically resize
     the buffer in this case, but at present it does not.

@{b}input buffer overflow, can't enlarge buffer because scanner uses REJECT@{ub}
     the scanner was working on matching an extremely large token and
     needed to expand the input buffer.  This doesn't work with
     scanners that use @{b}REJECT@{ub}.

@{b}fatal flex scanner internal error-end of buffer missed@{ub}
     This can occur in an scanner which is reentered after a long-jump
     has jumped out (or over) the scanner's activation frame.  Before
     reentering the scanner, use:

          yyrestart( yyin );

     or, as noted above, switch to using the C++ scanner class.

@{b}too many start conditions in <> construct!@{ub}
     you listed more start conditions in a <> construct than exist (so
     you must have listed at least one of them twice).


@EndNode

@Node "Files" "Flex.guide/Files"
@Next "Deficiencies"
@Prev "Diagnostics"
@Toc "Main"

Files
=====

@{b}-lfl@{ub}
     library with which scanners must be linked.

@{b}lex.yy.c@{ub}
     generated scanner (called @{b}lexyy.c@{ub} on some systems).

@{b}lex.yy.cc@{ub}
     generated C++ scanner class, when using @{b}-+@{ub}.

@{b}<FlexLexer.h>@{ub}
     header file defining the C++ scanner base class, @{b}FlexLexer@{ub}, and
     its derived class, @{b}yyFlexLexer@{ub}.

@{b}flex.skl@{ub}
     skeleton scanner.  This file is only used when building flex, not
     when flex executes.

@{b}lex.backup@{ub}
     backing-up information for @{b}-b@{ub} flag (called @{b}lex.bck@{ub} on some
     systems).


@EndNode

@Node "Deficiencies" "Flex.guide/Deficiencies"
@Next "See also"
@Prev "Files"
@Toc "Main"

Deficiencies / Bugs
===================

   Some trailing context patterns cannot be properly matched and
generate warning messages ("dangerous trailing context").  These are
patterns where the ending of the first part of the rule matches the
beginning of the second part, such as "zx*/xy*", where the 'x*' matches
the 'x' at the beginning of the trailing context.  (Note that the POSIX
draft states that the text matched by such patterns is undefined.)

   For some trailing context rules, parts which are actually
fixed-length are not recognized as such, leading to the abovementioned
performance loss.  In particular, parts using '|' or {n} (such as
"foo{3}") are always considered variable-length.

   Combining trailing context with the special '|' action can result in
@{i}fixed@{ui} trailing context being turned into the more expensive @{i}variable@{ui}
trailing context.  For example, in the following:

     %%
     abc      |
     xyz/def

   Use of @{b}unput()@{ub} invalidates yytext and yyleng, unless the @{b}%array@{ub}
directive or the @{b}-l@{ub} option has been used.

   Pattern-matching of NUL's is substantially slower than matching
other characters.

   Dynamic resizing of the input buffer is slow, as it entails
rescanning all the text matched so far by the current (generally huge)
token.

   Due to both buffering of input and read-ahead, you cannot intermix
calls to <stdio.h> routines, such as, for example, @{b}getchar()@{ub}, with @{b}flex@{ub}
rules and expect it to work.  Call @{b}input()@{ub} instead.

   The total table entries listed by the @{b}-v@{ub} flag excludes the number of
table entries needed to determine what rule has been matched.  The
number of entries is equal to the number of DFA states if the scanner
does not use @{b}REJECT@{ub}, and somewhat greater than the number of states if
it does.

   @{b}REJECT@{ub} cannot be used with the @{b}-f@{ub} or @{b}-F@{ub} options.

   The @{b}flex@{ub} internal algorithms need documentation.


@EndNode

@Node "See also" "Flex.guide/See also"
@Next "Author"
@Prev "Deficiencies"
@Toc "Main"

See also
========

   @{b}lex@{ub}(1), @{b}yacc@{ub}(1), @{b}sed@{ub}(1), @{b}awk@{ub}(1).

   John Levine, Tony Mason, and Doug Brown: Lex & Yacc; O'Reilly and
Associates.  Be sure to get the 2nd edition.

   M. E. Lesk and E. Schmidt, LEX - Lexical Analyzer Generator.

   Alfred Aho, Ravi Sethi and Jeffrey Ullman: Compilers: Principles,
Techniques and Tools; Addison-Wesley (1986).  Describes the
pattern-matching techniques used by @{b}flex@{ub} (deterministic finite
automata).


@EndNode

@Node "Author" "Flex.guide/Author"
@Prev "See also"
@Toc "Main"

Author
======

   Vern Paxson, with the help of many ideas and much inspiration from
Van Jacobson.  Original version by Jef Poskanzer.  The fast table
representation is a partial implementation of a design done by Van
Jacobson.  The implementation was done by Kevin Gong and Vern Paxson.

   Thanks to the many @{b}flex@{ub} beta-testers, feedbackers, and contributors,
especially Francois Pinard, Casey Leedom, Stan Adermann, Terry Allen,
David Barker-Plummer, John Basrai, Nelson H.F. Beebe, @{b}benson@odi.com@{ub},
Karl Berry, Peter A. Bigot, Simon Blanchard, Keith Bostic, Frederic
Brehm, Ian Brockbank, Kin Cho, Nick Christopher, Brian Clapper, J.T.
Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave Curtis, Scott
David Daniels, Chris G. Demetriou, Theo Deraadt, Mike Donahue, Chuck
Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris Flatters, Jon
Forrest, Joe Gayda, Kaveh R. Ghazi, Eric Goldman, Christopher M.
Gould, Ulrich Grepel, Peer Griebel, Jan Hajic, Charles Hemphill, NORO
Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, Dana Hudes, Eric
Hughes, John Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari
Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, Jonathan I.
Kamens, Terrence O Kane, Amir Katz, @{b}ken@ken.hilco.com@{ub}, Kevin B. Kenny,
Steve Kirsch, Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee,
Rohan Lenard, Craig Leres, John Levine, Steve Liddle, Mike Long,
Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall, Bengt Martensson,
Chris Metcalf, Luke Mewburn, Jim Meyering, R.  Alexander Milowski, Erik
Naggum, G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, Richard
Ohnemus, Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero,
Gaumond Pierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha,
Frederic Raimbault, Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe
Rommel, Jim Roskind, Alberto Santini, Andreas Scherer, Darrell
Schiebel, Raf Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas
Schwab, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump,
Paul Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt, Richard M.
Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard
Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn,
and those whose names have slipped my marginal mail-archiving skills but
whose contributions are appreciated all the same.

   Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore,
Craig Leres, John Levine, Bob Mulcahy, G.T.  Nicol, Francois Pinard,
Rich Salz, and Richard Stallman for help with various distribution
headaches.

   Thanks to Esmond Pitt and Earle Horton for 8-bit character support;
to Benson Margulies and Fred Burke for C++ support; to Kent Williams
and Tom Epperly for C++ class support; to Ove Ewerlid for support of
NUL's; and to Eric Hughes for support of multiple buffers.

   This work was primarily done when I was with the Real Time Systems
Group at the Lawrence Berkeley Laboratory in Berkeley, CA.  Many thanks
to all there for the support I received.

   Send comments to @{b}vern@ee.lbl.gov@{ub}.

@EndNode

