/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from amkey.c
*/
/************************************************************************/
/*									*/
/*		K	E	Y	-	h a n d l i n g		*/
/*									*/
/************************************************************************/


#include "defines.h"

#include <stdio.h>
#include <ctype.h>

#include <intuition/intuition.h>
#include <exec/devices.h>
#include <devices/console.h>

#ifdef AZTEC_C
#  include <functions.h>
#endif

#include "globals.h"

#include <string.h>
#include <stdlib.h>
#include <dos.h>

#include <clib/intuition_protos.h>
#include <clib/exec_protos.h>
#include <clib/console_protos.h>

#include <pragmas/intuition_pragmas.h>
#include <pragmas/exec_pragmas.h>
#include <pragmas/console_pragmas.h>

#include "amscreen.h"
#include "gad_def.h"
#include "small_arp.h"
#include "minrexx.h"
#include "arexx.h"

#include "amscreen.i"
#include "messwin.i"
#include "showdvi.i"
#include "gadget.i"
#include "am_requ.i"
#include "am_menu.i"
#include "globals.i"
#include "config.i"
#include "newcli.i"
#include "amkey.i"
#include "prefwin.i"
#include "help.i"
#include "search.i"
#include "searchwin.i"


#include <pragmas/console_pragmas.h>

/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



extern struct Library  *ConsoleDevice;
extern struct IOStdReq  ConsoleReq;


extern long		current_page_phy;
extern long		current_page;



#define SCROLL_Y_NORM		1	// 9
#define SCROLL_Y_NORM_REPEAT	12	// 18
#define SCROLL_Y_ALT		6	// 1
#define SCROLL_Y_ALT_REPEAT	24	// 6

#define SCROLL_X_NORM		1	// 4
#define SCROLL_X_NORM_REPEAT	4	// 8
#define SCROLL_X_ALT		4	// 1
#define SCROLL_X_ALT_REPEAT	8	// 4



static void handle_number		Args((int n));
static char *change_key			Args((unsigned int Code, unsigned int Qualifier,
					      char *buffer, int buflen));



static char *change_key(unsigned int Code, unsigned int Qualifier,
			char *buffer, int buflen)
{
  long error;
  struct InputEvent ie;
  char *ret = NULL;
#if 0
  struct KeyMap km;

  if (!OpenDevice("console.device",-1L, &req, 0L)) {
    ConsoleDevice = &(req.io_Device->dd_Library);
#endif

    if (ConsoleDevice != NULL) {
#if 0 /* superfluous */
      ConsoleReq.io_Message.mn_ReplyPort = NULL;
      ConsoleReq.io_Command = CD_ASKDEFAULTKEYMAP;
      ConsoleReq.io_Flags   = IOF_QUICK;
      ConsoleReq.io_Length  = sizeof(km);
      ConsoleReq.io_Data    = (APTR)&km;
      
      error = DoIO((struct IORequest *)&ConsoleReq);
      
      if (!error) {
#endif
        ie.ie_NextEvent = NULL;
        ie.ie_Class     = IECLASS_RAWKEY;
        ie.ie_SubClass  = 0;
        ie.ie_Code      = Code;
        ie.ie_Qualifier = Qualifier;
        ie.ie_EventAddress = NULL;
        
        error = RawKeyConvert(&ie, buffer, (long)buflen-1L, NULL /*&km*/);
        if (error>0) {
          buffer[error] = '\0';
        }
        else {
          buffer[0] = '\0';
        }
        ret = buffer;
#if 0 /* superfluous */
      }
#endif
    }
#if 0
    CloseDevice(&req);
  }
#endif

  return ret;
}



/***************    T A S T A T U R    ***********************/

static void handle_number(int n)
{
  if (n == 10)		set_counter(0);
  if (n>0 && n<10)	set_counter(n);
  switch (n) {
    case 15:	set_counter(0);
		break;
    case 29:
    case 30:
    case 31:	set_counter(n-28);
		break;
    case 45:
    case 46:
    case 47:	set_counter(n-41);
		break;
    case 61:
    case 62:
    case 63:	set_counter(n-54);
		break;
  }
}

static long tast(int *dx, int *dy, unsigned int Code, unsigned int Qualifier,
		 int *is_p_nr, WORD MouseX, WORD MouseY)
{
  register long ret;
  int scroll;
  int help;
  char buffer[40], *b, c;
  unsigned int code, qualifier;

  *dx = *dy = 0;
  *is_p_nr = 0;
  ret = 5;
  qualifier = Qualifier - 32768;
  code = Code & 255;

#ifdef DEBUG
  if (DeBug) {
    printf("Code: %d, Qual: %d\n",code,qualifier); 
  }
#endif

  b = change_key(Code, Qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT), buffer, 39);

  /** bb = change_key(Code, Qualifier, buffer, 39); **/
  if (b == NULL) {
    FatalStr(5, "can't convert RAW-code!");
  }
  c = *b;	/* take first character */

  /* printf("Code: %d, Qual: %d, Zeichen: %c\n",code,qualifier,c);  */

  if ((code == 51) && (qualifier & IEQUALIFIER_CONTROL) && (Enable_Abort == 1)) {
    CXBRK();		/* CTRL C  --  Prog. Ende 	*/
    return 0;		/* oder falls es nicht geht... 	*/
  }
  

  if (c == '=' && (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT))) {
    c = '+';	/* HACK wg. amerikanischer tastatur */
  }

  if ((qualifier & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND))
	&& c >= '0' && c <= '9') {
    int k;
    
    if (c == '0') {
      k = 9;
    }
    else {
      k = c - '1';
    }
    if (k < show_state.menu_res_lines) {
      if (resolution != show_state.mres[k]) {
        resolution = show_state.mres[k];
        hconvresolution = resolution;
        vconvresolution = resolution;
        if (is_dvif) {
          OpenNewDVI(filename, TRUE);
          set_chres;
          if (is_show) {
            show_full_page(TRUE);	/* full-page modus off (no_refresh=TRUE) */
          }
	  /* set_checked_os_menu(); sollte auch mit 'mutual exclude' gehen!! */
          return 3L;	    		/* neues File, Name nicht geaendert. */
        }
      }
    }
  }

  if (!(qualifier & ~IEQUALIFIER_NUMERICPAD)) {
    handle_number(code);	/* ohne alles (kein SHIFT, ALT, AMIGA ...) */
  }

  if (code > 79 && code < 90) {			/* function keys */
    /*int result = 0;*/
    /* ACHTUNG!!!							*/
    /* call_rexx ist synchron. Wenn man in call_rexx einen ShowDVI	*/
    /* Befehl absetzt, gibt es eine Endlos-Schleife!!			*/
    if (qualifier == 0L && show_state.ftast[code-80] != NULL) {
      /* call_rexx(show_state.ftast[code-80], &result, TRUE); */
      /* ok("Call command: \n\"%s\"\nResult: %ld", show_state.ftast[code-80], result); */
      asyncRexxCmd(show_state.ftast[code-80]);
    }
    else if ((qualifier == IEQUALIFIER_LSHIFT 
	   || qualifier == IEQUALIFIER_RSHIFT) &&
		show_state.ftast[code-70] != NULL) {
           /* ok("Call command: \n\"%s\"", show_state.ftast[code-70]); */
           /* call_rexx(show_state.ftast[code-70], &result, TRUE); */
           asyncRexxCmd(show_state.ftast[code-70]);
         }
  }

  if (is_show) {
    if (code == CURSORUP || code == CURSORDOWN ||
        code == CURSORLEFT || code == CURSORRIGHT || 
        c == ' ' || c == 'b' || c == 'B' ||
	(code == 24 && !(qualifier & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND))/* Ao */)
       ) {
      return 5;
    }
  }

  switch (code) 
   {
    case CURSORUP:
    case CURSORDOWN:
	if (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) {

	  /* bei SHIFT und REPEAT wird *nix* gemacht */

	  if (!(qualifier & IEQUALIFIER_REPEAT)) {
	    if (!is_print &&
			(code == CURSORUP   && static_y_Koo == 0) || 
			(code == CURSORDOWN && static_y_Koo+x_win_i_height == wy)) {

	      /* nicht im drucken und ganz am Ende/Anfang der Seite */
	      if (code == CURSORUP) {
	        set_jmpdown;
	        ret = -1;	/* prev page */
	      }
	      else {
	        set_jmpup;
	        ret =  1;	/* next page */
	      }
	    }
	    else {
	      /* noch nicht ganz am Ende/Anfang der Seite */

	      *dy = x_win_i_height-x_win_i_height/4;
	      if (code == CURSORUP) *dy = - *dy;
	      ret = 0;
	    }
	  }

	}
	else {
          if (qualifier & IEQUALIFIER_REPEAT) {				/* *** REPEAT *** */
            if (qualifier & (IEQUALIFIER_LALT | IEQUALIFIER_RALT)) {		/* ALT */
	      scroll = SCROLL_Y_ALT_REPEAT;
            }
            else if (qualifier & IEQUALIFIER_CONTROL) {				/* CTRL */
	      scroll = wy;
            }
            else {								/* weder noch */
              scroll = SCROLL_Y_NORM_REPEAT;
            }
	  }
	  else {							/* *** erstmalig *** */
            if (qualifier & (IEQUALIFIER_LALT | IEQUALIFIER_RALT)) {		/* ALT */
	      scroll = SCROLL_Y_ALT;
            }
            else if (qualifier & IEQUALIFIER_CONTROL) {				/* CTRL */
	      scroll = wy;
            }
            else {								/* weder noch */
              scroll = SCROLL_Y_NORM;
            }
	  }

	  if (code == CURSORUP) {
	    scroll = -scroll;
	  }
	  *dy = scroll;
	  ret = 0;
	}
        break;


    case CURSORLEFT:
    case CURSORRIGHT:

        if (qualifier & IEQUALIFIER_REPEAT) {				/* *** REPEAT *** */
          if (qualifier & (IEQUALIFIER_LALT | IEQUALIFIER_RALT)) {		/* ALT */
	    scroll = SCROLL_X_ALT_REPEAT;
          }
          else if (qualifier & IEQUALIFIER_CONTROL) {				/* CTRL */
	    scroll = wx;
          }
          else if (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) {	/* SHIFT */
            scroll = x_win_i_width-x_win_i_width/2;
          }
          else {								/* weder noch */
            scroll = SCROLL_X_NORM_REPEAT;
          }
	}
	else {								/* *** erstmalig *** */
          if (qualifier & (IEQUALIFIER_LALT | IEQUALIFIER_RALT)) {		/* ALT */
	    scroll = SCROLL_X_ALT;
          }
          else if (qualifier & IEQUALIFIER_CONTROL) {				/* CTRL */
	    scroll = wx;
          }
          else if (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) {	/* SHIFT */
            scroll = x_win_i_width-x_win_i_width/2;
          }
          else {								/* weder noch */
            scroll = SCROLL_X_NORM;
          }
	}

	if (code == CURSORLEFT) {
	  scroll = -scroll;
	}

	*dx = scroll;
	ret = 0;
	
	break;


#ifdef OLDIEOLD
	if (qualifier & IEQUALIFIER_REPEAT) {
	  if (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) {
	    scroll = SCROLL_X_SHIFT_R;
	  }
	  else if (qualifier & (IEQUALIFIER_LALT | IEQUALIFIER_RALT)) {
	    scroll = wx;
	  }
	  else scroll = SCROLL_X_NORM_R;
	}
	else {
	  if (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) {
	    scroll = SCROLL_X_SHIFT;
	  }
	  else if (qualifier & (IEQUALIFIER_LALT | IEQUALIFIER_RALT)) {
	    scroll = wx;
	  }
	  else scroll = SCROLL_X_NORM;
	}
	if (code == CURSORLEFT) {
	  scroll = -scroll;
	}
	*dx = scroll;
	ret = 0;

        break;
#endif


    case 95:			    /* HELP */
        if (is_amigaguide) {
          HelpKeyAGuide(qualifier & IEQUALIFIER_CONTROL);
        }
        else {
      	  AboutWinUp();		/* File am_requ.c */
        }
	break;

    default:

      // if (isascii(c)) c = toupper(c);

      switch (c) {
        case 'x':
	     TogglePrefWin();
	     break;
	case 'm':
	     ToggleMessWin(MouseX, MouseY);
	     break;
	case 'M':
	     SetupMargin();
	     break;
	case 'r':
	case 'R':
	     execute_script(show_state.command, (c == 'R'));
	     break;
	case 'l':
	     if (is_dvif) {
	       DrawDottedBorder(TRUE, FALSE);	/* toggle, !no_refresh */
	     }
	     else {
	       Message(MSG_NO_DVI_FILE);
	       beep();
	     }
	     break;
        case 27:                        /* ESC */
    	     if (is_escex) {
               if (real_prog_end()) {
      	         Enable_Abort = 0;	    /* am Ende nicht noch ein ^C */
                 ret = 10;
               }
	     }
	     else {
	       if (is_ownscr) {
	         ScreenToBack(screen);		/* Screen weg!! */
	       }
	       else {
	         WindowToBack(win2);
	       }
 	       make_old_active();
	     }
             break;
        case 13:			    /* RET - ENTER */
        case '+':
	     if (qualifier & IEQUALIFIER_REPEAT) {
	       break;
	     }

	     if (is_print) {
	       ret = 42;
	     }
	     else {
               if ((!(qualifier & ~(IEQUALIFIER_CONTROL)) && code == 68) ||
	           (!(qualifier & ~(IEQUALIFIER_NUMERICPAD | IEQUALIFIER_CONTROL)) && code == 67) ||
		    (!(qualifier & ~(IEQUALIFIER_NUMERICPAD | IEQUALIFIER_CONTROL)) && c == '+')) {
	         help = clear_counter(0);
	         if (help <= 0) {
		   if (qualifier & IEQUALIFIER_CONTROL) {
	             set_tusephy;		/* temp use of physical number */
	           }
                   ret = 1;
	         }
	         else {
	           ret = current_page + help;
	           *is_p_nr = 1;
	         }
               }
     	       else {
		  if (qualifier & IEQUALIFIER_CONTROL) {
	           set_tusephy;		/* temp use of physical number */
	         }
                 ret = 2;
               }
	       if (code == 67 || c == '+') {
		  set_jmpup;
	       }
             }
             break;
        case ' ':			    /* SPACE */
             if (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) {
	       if (!is_print && static_y_Koo == 0) {	/* selbe wie bei 'b' */
		 set_jmpdown;
		 ret = -1;	/* prev page */
	       }
	       else {
	     	 *dy = -x_win_i_height+x_win_i_height/4;
		 ret = 0;
	       }
             }
             else {
	       if (!is_print && static_y_Koo+x_win_i_height==wy) {
		 set_jmpup;
		 ret = 1;	/* next page */
	       }
	       else {
	    	 *dy = x_win_i_height-x_win_i_height/4;
	    	 ret = 0;
	       }
	     }
	     break;
        case 'b':			    /* b ... back */
	     if (!is_print && static_y_Koo == 0) {
		set_jmpdown;
		ret = -1;	/* prev page */
	     }
	     else {
	    	*dy = -x_win_i_height+x_win_i_height/4;
		ret = 0;
	     }
	     break;
        case 8:			  	 /* Backspace */
        case '-':                        /* - Zehnerfeld */
	     if (qualifier & IEQUALIFIER_REPEAT) {
	       break;
	     }

	     if (is_print) {
	       ret = 42;
	     }
	     else {
	       if (is_pscro) {
#if 0
	         blatt_ok_gad(&page);
		 if (page != 0L) {
		   ret = page;
		   *is_p_nr = 1;
		 }
#endif
	       }
	       else {
	         if ((!(qualifier & ~(IEQUALIFIER_CONTROL)) && (code == 11 || code == 65)) ||
	             (!(qualifier & ~(IEQUALIFIER_NUMERICPAD | IEQUALIFIER_CONTROL)) && code == 74) ||
		     (!(qualifier & ~(IEQUALIFIER_CONTROL)) && c == '-')) {
	           help = clear_counter(0);
	           if (help <= 0) {
	  	     if (qualifier & IEQUALIFIER_CONTROL) {
	               set_tusephy;		/* temp use of physical number */
	             }
	             ret = -1;
	           }
	           else {
	             ret = current_page - help;
	             *is_p_nr = 1;
	           }
	         }
	         else {
		   if (qualifier & IEQUALIFIER_CONTROL) {
	             set_tusephy;		/* temp use of physical number */
	           }
	           ret = -2;
	         }
	         if (c == '-') {
		   set_jmpdown;
	         }
	       }
	     }
	     break;

        case 's':				/* s ... search */
             ret = StartSearch(SO_OpenSearchWin);
    	     break;

        case '1':		    		/* ! ... newcli */
        case '!':
             if (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) {
    	       make_newcli(screen);
             }
             break;
        case 'p':			    /* p ... page on printer  */
	     if (is_dvif) {
  	       printing();
	     }
	     else {
	       Message(MSG_NO_DVI_FILE);
	       beep();
  	     }
             break;
        case 'c':			    /* c ... Counter loeschen */
	     if (qualifier & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND)) {
	       show_col_request();  	    /* Ac .. change color     */
	     }
	     else {
	       (void)clear_counter(0);
	     }
             break ;
        case '.':			    /* . numeric-pad and ...  */
        case 'g':			    /* g ... gehe zur Seite NR  */
	     if (is_print) {
	       ret = 42;
	     }
	     else {
	       if (code != 60 || (qualifier & IEQUALIFIER_NUMERICPAD)) {
		 if (qualifier & IEQUALIFIER_CONTROL) {
	           set_tusephy;		/* temp use of physical number */
	         }
	         if (is_pscro) {
#if 0
		   blatt_ok_gad(&page);
		   if (page != 0L) {
		     ret = page;
		     *is_p_nr = 1;
		   }
#endif
		 }
		 else {
	           help = clear_counter(0);
	           if (help != -1) {
	             ret = help;
	             *is_p_nr = 1;
	           }
	         }
	       }
	     }
             break;
        case 'i':			    /* i ... vert. Aufl. aendern */
	     if (is_show) {
		show_full_page(FALSE);  /* show-Modus ausschalten */
	     }
	     change_resolution();
             break;
        case 'd': 			    /* d ... WB-Screen her!! */
	     (void)WBenchToFront();
	     make_old_active();
	     break;
        case 'f':			    /* f ... show full page */
 	     if (is_dvif) {
	       show_full_page(FALSE);
	     }
	     else {			/* noch kein DVI-File geladen */
	       Message(MSG_NO_DVI_FILE);
	       beep();
	     }
             break;
        case 'o':			    /* o ... change Gadgets */
	     if (qualifier & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND)) {
    	       if (is_print) {
    	         ret = 42;
    	       }
    	       else {
	         ret = LoadFileReq();
	       }
	     }
	     else {
	       if (!is_show) {
	         toggle_scrollbar(FALSE);
	       }
	     }
             break;
	case '\\':			    /* CTRL-\ Programm Ende */
	     if (qualifier & IEQUALIFIER_CONTROL) {
               if (real_prog_end()) {
      	         Enable_Abort = 0;	    /* am Ende nicht noch ein ^C */
                 ret = 10;			/* QUIT */
               }
	     }
	     break;
        case 'q':			    /* q ... Quit */
	     if (qualifier & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND)) {
               if (real_prog_end()) {
      	         Enable_Abort = 0;	    /* am Ende nicht noch ein ^C */
                 ret = 10;			/* QUIT */
               }
	     }
             break;
        case 'w':			    /* w ... write configuration */
	     if (qualifier & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND)) {
	       write_config_file();
	     }
             break;
        case 'a':			    /* a ... Again- File neu einlesen */
        case 1  : /* ^a */
	     if (qualifier & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND)) {
	       ToggleAutoAgain();
	     }
	     else {
    	       if (is_print) {
    	         ret = 42;
    	       }
    	       else {
    	         if (access(filename,4) == 0) {
    	           char *p = strrchr(filename,'.');
    	           if (p != NULL && stricmp(p,".dvi") == 0) {
		   if (qualifier & IEQUALIFIER_CONTROL) {
	               set_tusephy;		/* temp use of physical number */
	             }
	             OpenNewDVI(filename, FALSE);
	             ret = 3;		/* neues File, Name nicht geaendert. */
	           }
	           else {
	             Message(MSG_NO_DVI_FILE);
	             beep();
	           }
	         }
	         else {			/* noch kein DVI-File geladen */
	           Message(MSG_CANT_ACCESS_FILE,filename);
	           beep();
	         }
	       }
	     }
	     break;
        case 'y':			    /* y ... umschalten phy <-> log Seitennummeren */
             toggle_usephy;
	     write_status();
	     Set_PgGadPageCur();
             break;
#if defined(MYDEBUG)
	case 'D':
#if defined(MWDEBUG)
	     MWReport("MemoryLib Report", MWR_SUM);
#endif
	     D(bug("ShowDVI: alw: %ld, bmfast: %ld, bmcpu: %ld, scroll: %ld\n",
			is_alwbmfast, is_bmfast, is_bmcpu, is_scrollras));
	     break;
#endif
        default: ret = 5;            /* no action */
    	     break;
      } /* end switch (c) */
   }
  if (ret == 42 && *is_p_nr != 1) {
    Message(MSG_NOT_WHILE_PRINTING);
    beep();
    ret = 5;
  }
  return (ret);
}

long work_with_raw_key(unsigned int Code, unsigned int Qualifier,
			 WORD MouseX, WORD MouseY)
{
  long ret, ex = 0;
  int dx, dy;
  int is_page_number;

  if (!is_osmenu) {
    /* dieses hin/weg ist, damit die Short-Cuts funktionieren */
    if (Code == 103) {
      /* Rechte AMIGA Taste nach unten */
      MyModifyIDCMP(0, IDCMP_MENUVERIFY);		/* weg mit dem MENUVERIFY */
      return 0;
    }
    if (Code == 103+128) {
      /* Rechte AMIGA Taste nach oben */
      MyModifyIDCMP(IDCMP_MENUVERIFY, 0);		/* MENUVERIFY wieder hin */
      /* des return kommt gleich danach */
    }
  }

  if (Code&128) {		/* Taste hoch */
    return 0;
  }
  ret = tast(&dx, &dy, Code, Qualifier, &is_page_number, MouseX, MouseY);
  if (is_page_number == 1) {
    ex = ret;
    if (ex == 0) ex = -1;		/* special hack for page number 0 */
  }
  else {
    if ((ret != 0)&&(ret != 5)) {
      ex = KOMM+(long)ret; 		
				/* ret ==  0 normal        */
				/* ret ==  5 no action     */
				/* ret == -1 Seite zurueck */
				/* ret ==  1 Seite vor     */
				/* ret == -2 Textanfang    */
				/* ret ==  2 Textende      */
				/* ret == 10 Programmende  */
				/* ret ==  3 again DVI-F.  */
				/* ret ==  4 neues DVI-F.  */
				/* ret ==  6 search mode   */
    }     	
    else {                     		
      if (ret == 0) {         		
	if (is_gadg) {
	  window_plus_sbar_move(dx,dy);
	}		/* setzt auch die Scrollbars richtig */
	else {
	  window_move(dx,dy);
	}
      }
    }
  }
  
  return ex;
}

