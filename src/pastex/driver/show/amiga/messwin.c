/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from messwin.c
*/
#include "defines.h"

#include <stdio.h>
#include <string.h>
#include <graphics/gfxbase.h>
#include <intuition/intuition.h>
#include <intuition/intuitionbase.h>
#include <libraries/dos.h>

#ifdef AZTEC_C
#  include <functions.h>
#endif

#include "globals.h"

#include <stdlib.h>
#include <clib/intuition_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/exec_protos.h>

#include <pragmas/intuition_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/exec_pragmas.h>

#include "amscreen.h"

#include "amscreen.i"
#include "amkey.i"
#include "messwin.i"
#include "globals.i"
#include "help.i"
#include "am_menu.i"


/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



/*******************************************************************************/
/*			     M E S S W I N D O W			       */
/*******************************************************************************/

extern UBYTE sig_messwin;
extern short FullPageLeftEdge;
extern short FullPageTopEdge;
extern short FullPageWidth;
extern short FullPageHeight;


short MessWinXpos;	/* wird in OpenS() auf -1 gesetzt */
short MessWinYpos;

struct Window		*MessWin = NULL;	/* = NULL wichtig, damit wird gearbeitet! */


static float MessWinHOff;
static float MessWinVOff;
static float MessWinSavetyX;
static float MessWinSavetyY;

static void DrawRect(struct RastPort * rp, short x0, short y0, short x1, short y1);



#define MESS_WIN_WIDTH		168
#define MESS_WIN_HEIGHT		68
#define MESS_WIN_LINES		3


void ToggleMessWin(WORD MouseX, WORD MouseY)
{
  if (!is_messwin) {
    /* das set_messwin wird in der Open Fkt. gemacht.. */
    if (is_dvif) {
      OpenMessWin();
      if (MouseX != -1) {
        WorkMessWin(MouseX, MouseY, FALSE, FALSE);
      }
    }
    else {
      Message(MSG_NO_DVI_FILE);
    }
  }
  else {
    /* das unset_messwin wird in der Close Fkt. gemacht.. */
    WorkMessWin(MouseX, MouseY, FALSE, TRUE);	// Maus hoch
    CloseMessWin();
  }
}

void OpenMessWin(void)
{
  struct NewWindow new_win;
  //struct TextAttr textAttr;
  UWORD XSize, YSize;

  if (MessWin != NULL) {
    return;
  }
  
#if 0
  if (win2 != NULL) {
    AskFont(win2->RPort, &textAttr);
    YSize = textAttr.ta_YSize;
  }
  else {
    return;	/* naja, sollt eigentlich nicht vorkommen */
  }
#endif

  if (win2 == NULL) {
    return;	/* naja, sollt eigentlich nicht vorkommen */
  }
  
  XSize = GfxBase->DefaultFont->tf_XSize;
  YSize = GfxBase->DefaultFont->tf_YSize;

  if (MessWinXpos == -1) {
    new_win.LeftEdge = win2->LeftEdge + win2->BorderLeft + 3;
    new_win.TopEdge  = win2->TopEdge + HeightWinTitle + 3;
  }
  else {
    new_win.LeftEdge = MessWinXpos;
    new_win.TopEdge  = MessWinYpos;
  }
  new_win.Width = MESS_WIN_WIDTH+win2->BorderLeft+win2->BorderRight + 21*(XSize-8);
  new_win.Height = win2->BorderTop+win2->BorderBottom+ 6*YSize + 21+4 - 8;	/* ist zwar unlogisch.. */
  new_win.DetailPen = 0;
  new_win.BlockPen = 1; 
  new_win.Title = GetTeXString(MSG_MEASURE_WINDOW);
  new_win.Flags = WFLG_DEPTHGADGET | WFLG_CLOSEGADGET | WFLG_DRAGBAR | WFLG_NOCAREREFRESH | WFLG_RMBTRAP;
  new_win.IDCMPFlags = IDCMP_CLOSEWINDOW | IDCMP_RAWKEY | ((is_amigaguide) ? IDCMP_GADGETHELP : 0);
  new_win.Type = CUSTOMSCREEN;
  if (!is_os2 && !is_ownscr) {
    new_win.Type = WBENCHSCREEN;
  }
  new_win.FirstGadget = NULL;
  new_win.CheckMark = NULL;
  new_win.Screen = screen;
  new_win.BitMap = NULL;
  if (is_amigaguide) {
    MessWin = (struct Window *)OpenWindowTags(&new_win, WA_HelpGroupWindow, win2, TAG_DONE);
  }
  else {
    MessWin = (struct Window *)OpenWindow(&new_win);
  }
  if (MessWin == NULL) {
    unset_messwin;
    Warning(MSG_CANT_OPEN_MESSWIN);
  }
  else {
    set_messwin;		/* MessWin ist da! */
    sig_messwin = MessWin->UserPort->mp_SigBit;
    SetAPen(MessWin->RPort, 1);
    
    SetUpMessWin(FALSE);

    add_mmove;
    MyModifyIDCMP(MOUSEMOVE, 0L);
  }
  
  MessWinHOff = hoffset_in * 1000 / mag * 72.27;	/* Speed Improvement */
  MessWinVOff = voffset_in * 1000 / mag * 72.27;
  MessWinSavetyX = (((float)SAVETY_BITS_X / (float)hconvresolution) * 1000.0 / mag) * 72.27 ;
  MessWinSavetyY = (((float)SAVETY_BITS_Y / (float)vconvresolution) * 1000.0 / mag) * 72.27 ;
  
  set_checked_os_menu();
}


void SetUpMessWin(int delta)
{
  register struct RastPort *rp;
  int x,y;
  UWORD XSize, YSize;
  float hin, vin;
  char str[30];
  char * ptr;

  hin = hoffset_in * 1000 / mag;
  vin = voffset_in * 1000 / mag;

  if (MessWin != NULL) {
    rp = MessWin->RPort;
    XSize = rp->Font->tf_XSize;
    YSize = rp->Font->tf_YSize;
    x = MessWin->BorderLeft + 3;
    y = MessWin->BorderTop + 3 + YSize;				/* Y + 3 */
    ptr = GetTeXString(MSG_MESSWIN_WIDTH);
    Move(rp, x, y);
    Text(rp, ptr, strlen(ptr));
    y += YSize + 3;						/* 2Y + 6 */
    if (is_unit_in) {
      sprintf(str,"%4.1f in",(float)pwidth_pt / 72.27 - hin);
    }
    else {
      if (is_unit_cm) {
        sprintf(str,"%4.1f cm",(float)pwidth_pt / 28.54 - hin * 2.54);
      }
      else {
        sprintf(str,"%6d pt",pwidth_pt - (long)(hin * 72.27));
      }
    }
    Move(rp, x+2, y);
    Text(rp,str,(long)strlen(str));
    y += YSize + 5;						/* 3Y + 11 */
    ptr = GetTeXString(MSG_MESSWIN_HEIGHT);
    Move(rp, x, y);
    Text(rp, ptr, strlen(ptr));
    y += YSize + 3;						/* 4Y + 14 */
    Move(rp, x+2, y);
    if (is_unit_in) {
      sprintf(str,"%4.1f in",(float)pheight_pt / 72.27 - vin);
    }
    else {
      if (is_unit_cm) {
        sprintf(str,"%4.1f cm",(float)pheight_pt / 28.54 - vin * 2.54);
      }
      else {
        sprintf(str,"%6d pt",pheight_pt - (long)(vin * 72.27));
      }
    }
    Text(rp,str,(long)strlen(str));

    x = MessWin->BorderLeft + 90 + 10*(XSize - 8);
    y = MessWin->BorderTop + 3 + YSize;				/* Y + 3 */
    Move(rp, x, y);
    if (delta) {
      ptr = GetTeXString(MSG_MESSWIN_DEL_X);
      Text(rp, ptr, strlen(ptr));
    }
    else {
      ptr = GetTeXString(MSG_MESSWIN_X);
      Text(rp, ptr, strlen(ptr));
    }
    y += 2*YSize + 8;						/* 3Y + 11 */
    Move(rp, x, y);
    if (delta) {
      ptr = GetTeXString(MSG_MESSWIN_DEL_Y);
      Text(rp, ptr, strlen(ptr));
    }
    else {
      ptr = GetTeXString(MSG_MESSWIN_Y);
      Text(rp, ptr, strlen(ptr));
    }

    x = MessWin->BorderLeft +3;
    y += 2*YSize + 10;						/* 5Y + 21 */
    Move(rp, x, y);
    sprintf(str, GetTeXString(MSG_MESSWIN_MAG), mag);
    Text(rp, str, (long)strlen(str));
  }
}


void CloseMessWin(void)
{
  if (MessWin != NULL) {
    sub_mmove;
    if (!is_mmove){
      MyModifyIDCMP(0L, MOUSEMOVE);
    }
    MessWinXpos = MessWin->LeftEdge;	/* merke die alte Position */
    MessWinYpos = MessWin->TopEdge;
    CloseWindow(MessWin);
    MessWin = NULL;
    unset_messwin;
  }

  set_checked_os_menu();
}

static void DrawRect(struct RastPort * rp, short x0, short y0, short x1, short y1)
{
  short X0, Y0, X1, Y1;

  Move(rp, x0, y0);
  Draw(rp, x0, y1);
  Draw(rp, x1, y1);
  Draw(rp, x1, y0);
  Draw(rp, x0, y0);

  if (x0 < x1) {
    X0 = x0+1;
    X1 = x1-1;
  }
  else {
    X0 = x0-1;
    X1 = x1+1;
  }
  if (y0 < y1) {
    Y0 = y0+1;
    Y1 = y1-1;
  }
  else {
    Y0 = y0-1;
    Y1 = y1+1;
  }

  Move(rp, X0, Y0);
  Draw(rp, X0, Y1);
  Move(rp, X1, Y1);
  Draw(rp, X1, Y0);
}


void WorkMessWin(int mx, int my, int down, int up)
{
  register struct RastPort *rp;
  int x,y;
  UWORD XSize, YSize;
  char *str, buf[30];
  float xpos, ypos;
  int outX, outY;
  struct RastPort * wrp;
  short  mmx, mmy;
  static float oldxpos, oldypos;
  static short oldmx, oldmy;
  static short lastmx, lastmy;
  static short is_down;
  static short has_paint;	// Gummiband ist gezeichnet?
  
  if (!down) {
    // wenn das nicht gerade der Klick nach unten ist, dann wird
    // die aktuellere Maus-Position aus der Window Struktur verwendet.
    mx = win2->MouseX;
    my = win2->MouseY;
  }

  if (MessWin != NULL) {
  
    /* zuerst, falls down, das Gummiband loeschen/neuzeichnen */

    wrp = win2->RPort;
    mmx = mx;
    if (mx < win2->BorderLeft) {
      mmx = win2->BorderLeft;
    }
    if (mx >= win2->Width-win2->BorderRight) {
      mmx = win2->Width-win2->BorderRight-1;
    }
    mmy = my;
    if (my < win2->BorderTop) {
      mmy = win2->BorderTop;
    }
    if (my >= win2->Height-win2->BorderBottom) {
      mmy = win2->Height-win2->BorderBottom-1;
    }

    if (down)  {
      if (has_paint) {		// Huch...!! (kann mal vorkommen) Wegen middle-menu und hide
        SetDrMd(wrp, COMPLEMENT);
        DrawRect(wrp, oldmx, oldmy, lastmx, lastmy);
      }
      oldmx = mmx;
      oldmy = mmy;
      lastmx = lastmy = -1;
      has_paint = FALSE;
    }
    if (is_down)  {
      if (lastmx != mmx || lastmy != mmy) {
        SetDrMd(wrp, COMPLEMENT);
        if (lastmx > 0 && lastmy > 0 && has_paint) {
          DrawRect(wrp, oldmx, oldmy, lastmx, lastmy);
        }
        
        DrawRect(wrp, oldmx, oldmy, mmx, mmy);
        
        lastmx = mmx;
        lastmy = mmy;
        has_paint = TRUE;
      }
    }
    if (up && has_paint)  {
      SetDrMd(wrp, COMPLEMENT);
      DrawRect(wrp, oldmx, oldmy, lastmx, lastmy);

      lastmx = lastmy = -1;
      has_paint = FALSE;
    }


    /* nun den Text formatieren/ausgeben */

    rp = MessWin->RPort;
    XSize = rp->Font->tf_XSize;
    YSize = rp->Font->tf_YSize;
    x = MessWin->BorderLeft + 85 + 10*(XSize - 8);
    y = MessWin->BorderTop + 3 + YSize;
    y += YSize + 3;
    

    if (down) {
      SetUpMessWin(TRUE);
      is_down = TRUE;
    }
    if (up) {
      SetUpMessWin(FALSE);
      is_down = FALSE;
    }

    if (is_show) {
      xpos = ((mx - FullPageLeftEdge) * ((float)pwidth_pt + MessWinSavetyX)) / FullPageWidth;
      ypos = ((my - FullPageTopEdge) * ((float)pheight_pt + MessWinSavetyY)) / FullPageHeight;
      outX = (mx < FullPageLeftEdge || mx > FullPageLeftEdge + FullPageWidth);
      outY = (my < FullPageTopEdge  || my > FullPageTopEdge + FullPageHeight);
    }
    else {
      outX = (mx < Page_LeftPoint || mx >= Page_RightPoint);
      outY = (my < Page_TopPoint  || my >= Page_BottomPoint);
      xpos = ((float)(static_x_Koo + mx - Page_LeftPoint) * ((float)pwidth_pt +	MessWinSavetyX)) / (float)wx;
      ypos = ((float)(static_y_Koo + my - Page_TopPoint) * ((float)pheight_pt +	MessWinSavetyY)) / (float)wy;
    }

    xpos -= MessWinHOff;	/* diese Variablen werden beim Fenster oeffnen berechnet */
    ypos -= MessWinVOff;
    

    if (down){
      oldxpos = xpos;
      oldypos = ypos;
    }
    if (is_down) {
      xpos = xpos - oldxpos;
      ypos = ypos - oldypos;
    }

    if (outX) {
      str = "         ";
    }
    else {
      if (is_unit_in) {
        sprintf(buf,"%6.2f in",(float)xpos / 72.27);
      }
      else {
        if (is_unit_cm) {
          sprintf(buf,"%6.2f cm",(float)xpos / 28.54);
        }
        else {
          sprintf(buf,"%6d pt",(long)xpos);
        }
      }
      str = &(buf[0]);
    }
    Move(rp, x+2, y);
    Text(rp,str,(long)strlen(str));

    y += YSize + 5;
    y += YSize + 3;
    if (outY) {
      str = "         ";
    }
    else {
      if (is_unit_in) {
        sprintf(buf,"%6.2f in",(float)ypos / 72.27);
      }
      else {
        if (is_unit_cm) {
          sprintf(buf,"%6.2f cm",(float)ypos / 28.54);
        }
        else {
          sprintf(buf,"%6d pt",(long)ypos);
        }
      }
      str = &(buf[0]);
    }
    Move(rp, x+2, y);
    Text(rp,str,(long)strlen(str));
  }
}


long MessWinMsg(void)
{
  struct IntuiMessage *msg;
  ULONG msg_class;
  UWORD	Code,Qualifier;
  WORD	MouseX, MouseY;
  int cont = 1;
  long ex = 0;

  if (MessWin == NULL) {
    return ex;
  }

  while(cont && (msg = (struct IntuiMessage *)GetMsg(MessWin->UserPort))!=NULL) {

    msg_class	= msg->Class;
    Code  	= msg->Code;
    Qualifier	= msg->Qualifier;
    MouseX	= msg->MouseX;
    MouseY	= msg->MouseY;

    switch (msg_class) {
      case IDCMP_CLOSEWINDOW:
  	cont = 0;
  	break;
      case IDCMP_RAWKEY:
	ex = work_with_raw_key(Code, Qualifier, MouseX, MouseY);
	break;
      case IDCMP_GADGETHELP:
        work_with_gadgethelp(msg);
        break;
    }

    ReplyMsg(&(msg->ExecMessage));
  }
  if (!cont) {
    WorkMessWin(MouseX, MouseY, FALSE, TRUE);	// Maus hoch
    CloseMessWin();
  }
  
  return ex;
}
