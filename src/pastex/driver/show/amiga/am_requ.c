/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from am_requ.c
*/
/* *** am_requ.c *** */

#ifdef AMIGA


#include "defines.h"

#include <sprof.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <intuition/intuition.h>
#include <libraries/dos.h>
#include <libraries/asl.h>
#include <dos/dostags.h>

#ifdef AZTEC_C
#  include <functions.h>
#endif

#include "globals.h"

#include <clib/intuition_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/asl_protos.h>
#include <clib/exec_protos.h>

#include <pragmas/intuition_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/asl_pragmas.h>
#include <pragmas/exec_pragmas.h>



#include "amscreen.h"
#include "version.h"
#include "gad_def.h"
#include "searchwin.h"

#include "showdvi.i"
#include "amscreen.i"
#include "gadget.i"
#include "am_requ.i"
#include "globals.i"
#include "dvihand.i"
#include "search.i"
#include "searchwin.i"

/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



/* locale Funktionen */
static int ReadHelpTxtPages	Args((void));
static void AboutWinToggleText	Args((void));
#if !defined(REQ_LIBRARY)
static void draw_active		Args((long x,
	                	      long y));
#endif

/* externe Variablen */
extern struct TextFont		*font8,
				*font11;
extern UBYTE			sig_aboutwin;

extern char			PubScreenName[];
extern char			MyPubScreenName[];

/* lokale Variablen */
static struct Window *AboutRequesterWin = NULL;
static struct TextAttr AbWintxtAttr;		/* TxtAttr fuer das AboutWindow */

static short help_counter;
static struct IntuiText VersionText;


#include "am_requ.h"


/* da kommt der gesamte Hilfstext rein ... */
static	      short         HelpTxtPages;
static	      short	   *HelpTxtPagesLines;	/* Anzahl Zeilen pro Seite */
static struct MyTextStruct **HelpTxt = NULL;

static struct TagItem	   okBevelGadTags[] = { {GT_VisualInfo, NULL}, {TAG_DONE, 0L} };
static struct TagItem	   helpBevelGadTags[] = { {GT_VisualInfo, NULL}, {TAG_DONE, 0L} };

static        short	   LineNumber;
static        char         *ErrorMsg;


void CenterWindow(WORD *LeftEdge, WORD *TopEdge, WORD Width, WORD Height)
{
  WORD vis_width, vis_height;

  vis_width  = screen->Width+1;
  vis_height = screen->Height+1;

  if (is_os2) {
    struct ViewPort *vp;
    ULONG modeID;
    struct DimensionInfo DimInfo;
    
    vp = &(screen->ViewPort);
    if ((modeID = GetVPModeID(vp)) != INVALID_ID) {
      GetDisplayInfoData(NULL, (UBYTE *)&DimInfo, sizeof(DimInfo), DTAG_DIMS, modeID);
      vis_width  = DimInfo.TxtOScan.MaxX + 1;
      vis_height = DimInfo.TxtOScan.MaxY + 1;
    }
  }

  if (screen->Width <= vis_width) {
    *LeftEdge = ((screen->Width - Width) >> 1);
  }
  else {
    *LeftEdge = abs(screen->LeftEdge) + ((vis_width - Width) >> 1);
  }

  if (screen->Height <= vis_height) {
    *TopEdge = ((screen->Height - Height) >> 1);
  }
  else {
    *TopEdge = abs(screen->TopEdge) + ((vis_height - Height) >> 1);
  }
}

/* (von stefan st.)
                                GetDisplayInfoData(0, (UBYTE *)&di, sizeof(struct DimensionInfo), DTAG_DIMS, vpmid);
                                rect = &di.TxtOScan;
                                left = -(scr->LeftEdge) + (min((rect->MaxX - rect->MinX + 1), scr->Width) - mywindowtag[P_WA_Width].ti_Data) / 2;
                                top = -(scr->TopEdge) + (min((rect->MaxY - rect->MinY + 1), scr->Height) - mywindowtag[P_WA_Height].ti_Data) / 2;
                                zoompos[0] = mywindowtag[P_WA_Left].ti_Data = (left < 0) ? 0 : left;
                                zoompos[1] = mywindowtag[P_WA_Top].ti_Data = (top < 0) ? 0 : top;
*/

static int ReadHelpTxtPages(void)
{
  char *ptr, *p, *pp, line[128], pattern[40];
  int len, found, anz = 0, zeilen, page, TxtLine;
  int xpos, ypos;
  struct MyTextStruct **HTxtArr = NULL;
  struct MyTextStruct *HTxtPage;
  FILE *fp;
  LineNumber = 0;
  ErrorMsg = NULL;

  fp = OpenConfigFile("ShowDVI.help", MODE_READ);

  if (fp == NULL) {
    Warning(MSG_CANT_OPEN_HELP_FILE, "ShowDVI.help");
  }
  else {
    /* so nun auf die Suche nach dem #helpwindow-Eintrag */
    do {
      ptr = fgets(line, 127, fp);
      LineNumber++;
      found = (strncmp(line, "#helpwindow", 11) == 0);
    } while (ptr != NULL && !found);
    
    if (found) {
      if (sscanf(line+11, "%d", &anz) == 1) {
        /* allociere ein Array von Pointer */
        HTxtArr = xmalloc(anz*sizeof(struct MyTextStruct *));
        HelpTxtPagesLines = xmalloc(anz*sizeof(short));

	/*========= ueber alle Seiten ==========*/
        for (page=0; page<anz; page++) {
          sprintf(pattern, "#help %d,", page);
          len = strlen(pattern);
	  do {
	    ptr = fgets(line, 127, fp);
	    LineNumber++;
	    found = (strncmp(line, pattern, len) == 0);
	  } while (ptr != NULL && !found);

	  if (found) {
	    if (sscanf(line+len, "%d", &zeilen) == 1) {
  	      /* allociere die Eintraege fuer die Zeilen */
	      HTxtPage = xmalloc(zeilen*sizeof(struct MyTextStruct));
	      HTxtArr[page] = HTxtPage;
	      HelpTxtPagesLines[page] = zeilen;

	      /*=========== ueber alle Zeilen einer Seite ============*/
	      for (TxtLine=0; TxtLine<zeilen && ptr != NULL; TxtLine++) {
	        /* lese die einzelnen Zeilen hintereinander */
	        ptr = fgets(line, 127, fp);
	        LineNumber++;
	        if (ptr != NULL) {
	          if (sscanf(line, "%d %d", &xpos, &ypos) == 2) {
	            p = strchr(line, '\"');
	            if (p != NULL) {
	              /* und nun die " weg.. */
	              p++;	/* vorders AnfZeichen */
	              if ((pp = strrchr(p, '\"')) != NULL) *pp = '\0';	/* hinteres */
	              HTxtPage[TxtLine].xKoo          = xpos;
	              HTxtPage[TxtLine].yKoo          = ypos;
	              HTxtPage[TxtLine].txt.FrontPen  = 1;
	              HTxtPage[TxtLine].txt.BackPen   = 0;
	              HTxtPage[TxtLine].txt.DrawMode  = JAM1;
	              HTxtPage[TxtLine].txt.LeftEdge  = 0;
	              HTxtPage[TxtLine].txt.ITextFont = &AbWintxtAttr;
	              HTxtPage[TxtLine].txt.IText     = strdup(p);
	              if (TxtLine < zeilen-1) {
	                /* noch nicht die letzte Zeile */
	                HTxtPage[TxtLine].txt.NextText = &(HTxtPage[TxtLine+1].txt);
	              }
	              else {
	                HTxtPage[TxtLine].txt.NextText = NULL;
	              }
	            }
	          }
		  else {
	            /* kann xpos, ypos nicht lesen */
	            ErrorMsg = "x/y-pos";
	            return FALSE;
	            /* Fatal(20, "Can't read x/y-pos! (%d, %d)", page, TxtLine); */
	          }
	        }
	      }
	      if (TxtLine != zeilen) {
	        /* habe nicht alle Zeilen lesen koennen */
	        ErrorMsg = "too few lines";
	        return FALSE;
	        /* Fatal(20, "Can't read all lines! (%d, %d)", page, TxtLine); */
	      }
	    }
	    else {
	      /* kann Zeilenanzahl nicht lesen! */
	      ErrorMsg = "no line number";
	      return FALSE;
	      /* Fatal(20, "Can't read line number! (%d)", page); */
	    }
	  }
	  else {
	    /* Kann #help %d, nicht finden */
	    ErrorMsg = "no #help";
	    return FALSE;
	    /* Fatal(20, "Can't find #help line!"); */
	  }
        } /* for page */
      }
      else {
        /* kann Anzahl Seiten nicht lesen! */
        ErrorMsg = "no page number";
        return FALSE;
        /* Fatal(20, "Can't read page number!"); */
      }
    }
    else {
      /* kann #helpwin nicht finden */
      ErrorMsg = "no #helpwin";
      return FALSE;
      /* Fatal(20, "Can't fint #helpwin entry!"); */
    }
    
    fclose(fp);
  }
  HelpTxt = HTxtArr;
  HelpTxtPages = anz;
  return TRUE;
}


void AboutWinUp(void)
{
  struct RastPort *rp;
  long i, x, y;
  /* long YSize; */
  short TextHeight, TextWidth;
  struct NewWindow new_win; 

  if (is_about) {
    return;		/* ignore such strange things */
  }

  if (AboutRequesterWin != NULL) {
    /* Window ist schon da, aber is_about ist FALSE?? */
    Fatal(20,MSG_CONFUSED_ABOUT_REQ);
  }

#if 0	/* das sollte nun auch gehen... */
#if !defined(REQ_LIBRARY)
  if (is_colre) {
    remove_col_request();
  }
#endif
#endif

  set_about;
  help_counter = 0;

#if 0
  if (win2 != NULL) {
    AskFont(win2->RPort, &AbWintxtAttr);
  }
  YSize = AbWintxtAttr.ta_YSize;
  /* soll ich's so machen und den System-Default Font nehmen.... das ist aber meinstens */
  /* nur topaz 8 Font. Mein topaz 11 sieht besser aus! */
#endif
  /* ich verwende nun doch meine alten Sachen */
  
  if (TRUE /*(is_lace && YSize > 15) || (!is_lace && YSize > 12)*/) {
    if (is_lace && font11 != NULL) {
      /* struct Assignment! */
      AbWintxtAttr = txtAttr11;	/* nehme topaz 11 bei interlace */
    }
    else {
      /* struct Assignment! */
      AbWintxtAttr = txtAttr8;	/* nehme topaz 8 bei noninterlace */
    }
  }

  about_ok_gadg.TopEdge   = ABOUT_OK_Y+win2->BorderTop;
  about_ok_gadg.Height    = ABOUT_OK_HEIGHT;
  about_help_gadg.TopEdge = ABOUT_OK_Y+win2->BorderTop;
  about_help_gadg.Height  = ABOUT_OK_HEIGHT;
  about_border_ok_pairs[5]= ABOUT_OK_HEIGHT+1;
  about_border_ok_pairs[7]= ABOUT_OK_HEIGHT+1;
  about_border_no_pairs[5]= ABOUT_OK_HEIGHT-1;
  about_border_no_pairs[7]= ABOUT_OK_HEIGHT-1;
  

  about_help_text.LeftEdge = 7;
  about_help_text.IText = (UBYTE*)ABOUT_HELP_STRING;


  if (is_os2) {
    /* es werden die Bevel Boxes gezeichnet! */
    about_ok_gadg.GadgetRender = NULL;
    about_help_gadg.GadgetRender = NULL;
  }


  new_win.Width  = ABOUT_WIDTH;
  new_win.Height = ABOUT_HEIGHT+win2->BorderTop;

  CenterWindow(&(new_win.LeftEdge), &(new_win.TopEdge), new_win.Width, new_win.Height);

  
  new_win.DetailPen = 0;
  new_win.BlockPen = 1; 
  new_win.Title = GetTeXString(MSG_SHOWDVI_ABOUT_WINDOW);
  new_win.Flags = WFLG_DEPTHGADGET | WFLG_CLOSEGADGET | WFLG_DRAGBAR | WFLG_ACTIVATE | WFLG_NOCAREREFRESH | WFLG_RMBTRAP;
  new_win.IDCMPFlags = IDCMP_GADGETUP | IDCMP_VANILLAKEY | IDCMP_CLOSEWINDOW;
  new_win.Type = CUSTOMSCREEN;
  if (!is_os2 && !is_ownscr) {
    new_win.Type = WBENCHSCREEN;
  }
  new_win.FirstGadget = &about_ok_gadg;
  new_win.CheckMark = NULL;
  new_win.Screen = screen;
  new_win.BitMap = NULL;
  AboutRequesterWin = (struct Window *)OpenWindow(&new_win);

  if (AboutRequesterWin == NULL) {
    Fatal(20, MSG_CANT_OPEN_ABOUT_REQ);
  }

  rp = AboutRequesterWin->RPort;

  if (is_os2) {
    okBevelGadTags[0].ti_Data = (ULONG)SDVI_VI;
    DrawBevelBoxA(rp, about_ok_gadg.LeftEdge, about_ok_gadg.TopEdge,
	about_ok_gadg.Width, about_ok_gadg.Height, okBevelGadTags);
    helpBevelGadTags[0].ti_Data = (ULONG)SDVI_VI;
    DrawBevelBoxA(rp, about_help_gadg.LeftEdge, about_help_gadg.TopEdge,
	about_help_gadg.Width, about_help_gadg.Height, helpBevelGadTags);
  }


  /* hier kommt nun die Initialisierung der IText Structuren je nach Fontgroesse... */
  /* YSize = AboutReqText[0].txt.ITextFont->ta_YSize; */
  /* Mit diesen Werten kann die gewuenschte Anzahl Zeilen ausgegeben werden */
  if (is_lace) {
    TextHeight = 15;
  }
  else {
    TextHeight = 9;
  }
  
  /* TextHeight = YSize + abs(((is_lace) ? 4 : 1) - (YSize - 8)); */

  TextWidth = 8;

  for (i=0; i<ABOUTREQNUM; i++) {
    AboutReqText[i].txt.LeftEdge = (AboutReqText[i].xKoo * TextWidth) / 10;
    AboutReqText[i].txt.TopEdge = (AboutReqText[i].yKoo * TextHeight) / 10;
    if (i<ABOUTREQNUM-1) {
      AboutReqText[i].txt.NextText = &(AboutReqText[i+1].txt);
    }
    if (i == 3) {	// Versionsstring kommt auf die Zeile mit dem 'X'
      y = AboutReqText[i].txt.TopEdge;
      x = (455 * TextWidth) / 10;
    }
  }

  AboutReqText[ABOUTREQNUM-1].txt.NextText = &VersionText;
  VersionText.FrontPen  = 1;
  VersionText.BackPen   = 0;
  VersionText.DrawMode  = JAM1;
  VersionText.LeftEdge  = x;
  VersionText.TopEdge   = y;
  VersionText.ITextFont = &AbWintxtAttr;
  VersionText.IText     = "V" SHOWDVI_VERSION;
  VersionText.NextText  = NULL;

  /* Ausgabe des 'about' Textes... */
  PrintIText(rp,&(AboutReqText[0].txt),AboutRequesterWin->BorderLeft, AboutRequesterWin->BorderTop);
  
  sig_aboutwin = AboutRequesterWin->UserPort->mp_SigBit;

  /* lese (einmal) die Helpseiten ein */
  if (HelpTxt == NULL) {
    if (!ReadHelpTxtPages()) {		/* lies die Seiten vom File ein */
      FatalStr(20, "Error in File \"%s\"\n  (Line %d, %s)", "ShowDVI.help", LineNumber, ErrorMsg);
    }
  }
  
  /* aber jedesmal muessen die Koordinaten korrigiert werden (lace/nicht lace) */
  if (HelpTxt != NULL) {
    int k;
    /* TextWidth = 8; */
    for (k=0; k<HelpTxtPages; k++) {
      /* über alle Seiten */
      /* Die Texthoehe wird nun strikt festgelegt */
      /* YSize = HelpTxt[k][0].txt.ITextFont->ta_YSize; */
      /* TextHeight = YSize + abs(((is_lace) ? 4 : 1) - (YSize - 8)); */
      i = 0;
      do {
        /* ueber alle Zeilen */
        HelpTxt[k][i].txt.LeftEdge = (HelpTxt[k][i].xKoo * TextWidth) / 10;
        HelpTxt[k][i].txt.TopEdge  = (HelpTxt[k][i].yKoo * TextHeight) / 10;
        i++;
      } while (HelpTxt[k][i-1].txt.NextText != NULL);
    }
  }

}



static void AboutWinToggleText(void)
{
  struct RastPort *rp;
  char str[20];

  if (AboutRequesterWin == NULL) return;

  rp = AboutRequesterWin->RPort;
  SetAPen(rp,0);
  RectFill(rp,AboutRequesterWin->BorderLeft + 1,
		AboutRequesterWin->BorderTop + 1,
	  	AboutRequesterWin->Width - AboutRequesterWin->BorderLeft - 1,
  		about_ok_gadg.TopEdge-4);
  SetAPen(rp,1);

  help_counter++;
  if (help_counter > HelpTxtPages) help_counter = 0;

  Move(rp, about_help_gadg.LeftEdge+about_help_gadg.Width+20, about_help_gadg.TopEdge+12);

  if (help_counter > 0) {
    sprintf(str, "%2d/%d ", help_counter, HelpTxtPages);
    Text(rp, str, strlen(str));

    if (HelpTxt != NULL) {
      PrintIText(rp,&(HelpTxt[help_counter-1][0].txt),AboutRequesterWin->BorderLeft, 
  	AboutRequesterWin->BorderTop);
    }
    if (help_counter == HelpTxtPages) {
      /* auf letzter HELP Seite */
      about_help_text.LeftEdge = 3;
      about_help_text.IText = (UBYTE*)ABOUT_ABOUT_STRING;
    }
    else {
      /* es gibt noch mehr HELP Seiten */
      about_help_text.LeftEdge = 7;
      about_help_text.IText = (UBYTE*)ABOUT_MORE_STRING;
    }
  } 
  else {
    Text(rp, "       ", 7);

    PrintIText(rp,&(AboutReqText[0].txt),AboutRequesterWin->BorderLeft, 
	  	AboutRequesterWin->BorderTop);
    about_help_text.LeftEdge = 7;
    about_help_text.IText = (UBYTE*)ABOUT_HELP_STRING;
  }
  RefreshGadgets(&about_help_gadg,AboutRequesterWin,NULL);
}



long AboutWinMsg(void)
{
  struct IntuiMessage *msg;
  long ex = 0;
  ULONG msg_class, gid;
  int i, k;
  char c;

  if (AboutRequesterWin == NULL || !is_about) {
    Fatal(20,MSG_CONFUSED_ABOUT_REQ);
  }
  
  
  while((msg = (struct IntuiMessage *)GetMsg(AboutRequesterWin->UserPort))!=NULL) {
    msg_class = msg->Class;
    switch (msg_class) {
      case IDCMP_CLOSEWINDOW:
    		ReplyMsg(&(msg->ExecMessage));
  		AboutWinDown();
  		return ex; /* WEG  HIER, damit wir kein GetMsg von einem nicht mehr vorhandenen Window machen! */
		break;
      case IDCMP_VANILLAKEY:
		c = msg->Code;
    		ReplyMsg(&(msg->ExecMessage));
    		if (c >= '0' && c <= '9') {
    		  const int num = c - '1';
    		  if (num < HelpTxtPages) {
    		    if (num == -1) {
    		      help_counter = HelpTxtPages;
    		    }
    		    else {
    		      help_counter = num;
    		    }
    		    AboutWinToggleText();
    		  }
    		}
    		else {
    		  switch (c) {
    		    case 8  :
    		    case 127:
    		    case 'b':
    		    case 'B':
    		    case '-':	if (help_counter <= 1) {
    		 		  help_counter = HelpTxtPages-1;/* cyklisch durch.. */
    		    		}
    		    		else {
    		    		  help_counter -= 2;
    		    		}
    		    		AboutWinToggleText();
    		    		break;

		    case ' ':
		    case '+':
    		    case 'h':
    		    case 'H':
    		    case 'm':
    		    case 'M':	if (help_counter == HelpTxtPages) {
    		 		  help_counter = 0;	/* cyklisch durch.. */
    		    		}
    		    		AboutWinToggleText();
    		    		break;

    		    case 'a':
    		    case 'A':	if (help_counter != 0) {
    		    		  help_counter = HelpTxtPages;	/* damit man wirklich auf about kommt */
    		    		  AboutWinToggleText();
    		    		}
    		    		break;

    		    case 'Q':   /* Bei 'Q' wird der Speicher freigegeben */
				for (i=0; i<HelpTxtPages; i++) {
				  for (k=0; k<HelpTxtPagesLines[i]; k++) {
				    xfree(HelpTxt[i][k].txt.IText);	/* String   */
				  }
				  xfree(HelpTxt[i]);			/* Struktur */
				}
				xfree(HelpTxt);				/* Array of pages   */
				xfree(HelpTxtPagesLines);		/* Array of numbers */
				HelpTxt = NULL;
				HelpTxtPagesLines = NULL;
				HelpTxtPages = 0;
    		    case 'o':
    		    case 'O':
    		    case 'q':
		    case 27 :	/* ESC */
    		    case 13 :	AboutWinDown();
		  		return ex; /* WEG  HIER, damit wir kein GetMsg von einem nicht mehr vorhandenen Window machen! */

    		    case  3 : 		/* ^C */
				CXBRK();		/* lattice ^C funktion */
    		    		break;
    		  }
    		}
		break;
      case IDCMP_GADGETUP:
		gid = ((struct Gadget *)msg->IAddress)->GadgetID;
    		ReplyMsg(&(msg->ExecMessage));
		switch (gid) {
		    case ABOUT_OK_GAD_NR:
		  		AboutWinDown();
		  		return ex; /* WEG  HIER, damit wir kein GetMsg von einem nicht mehr vorhandenen Window machen! */
		    case ABOUT_HELP_GAD_NR:
		    		AboutWinToggleText();
		  		break;
		}
		break;
      default:
    		ReplyMsg(&(msg->ExecMessage));
		FatalStr(20, "Unknown Intuimessage!");
		break;
    }
  }
  
  return ex;
}


void AboutWinDown(void)
{
  struct Message *msg;

  if (is_about && AboutRequesterWin != NULL) {
    unset_about;
    help_counter = 0;

    Forbid();
    do {
      msg = GetMsg(AboutRequesterWin->UserPort);
      if (msg != NULL) ReplyMsg(msg);
    } while (msg != NULL);
    ModifyIDCMP(AboutRequesterWin, 0);
    Permit();

    CloseWindow(AboutRequesterWin);			/* Requester Window loeschen */
    AboutRequesterWin = NULL;				/* wichtig */
  }
}



/*************************************************************************/

#if !defined(REQ_LIBRARY)

static void draw_active(long x, long y)
{
  register struct RastPort *rp = &(screen->RastPort);

  Move(rp,x,y);
  Draw(rp,x+CREQ_COL_WIDTH+3,y);
  Draw(rp,x+CREQ_COL_WIDTH+3,y+CREQ_COL_HEIGHT+3);
  Draw(rp,x,y+CREQ_COL_HEIGHT+3);
  Draw(rp,x,y);

  Move(rp,x-1,y+2);
  Draw(rp,x-1,y-1);
  Draw(rp,x+2,y-1);

  Move(rp,x+CREQ_COL_WIDTH+1+3,y+2);
  Draw(rp,x+CREQ_COL_WIDTH+1+3,y-1);
  Draw(rp,x+CREQ_COL_WIDTH-2+3,y-1);

  Move(rp,x-1,y+CREQ_COL_HEIGHT-2+3);
  Draw(rp,x-1,y+CREQ_COL_HEIGHT+1+3);
  Draw(rp,x+2,y+CREQ_COL_HEIGHT+1+3);

  Move(rp,x+CREQ_COL_WIDTH+1+3,y+CREQ_COL_HEIGHT-2+3);
  Draw(rp,x+CREQ_COL_WIDTH+1+3,y+CREQ_COL_HEIGHT+1+3);
  Draw(rp,x+CREQ_COL_WIDTH-2+3,y+CREQ_COL_HEIGHT+1+3);
}

void set_0_active(void)
{
  register struct RastPort *rp = &(screen->RastPort);
  register long x = ((x_win_i_width-CREQ_WIDTH)/2) + WIN_X_KOO+CREQ_COL_0_X-2,
	        y = ((x_win_i_height-CREQ_HEIGHT)/2) + WIN_Y_KOO+CREQ_COL_0_Y-2;

  /* zeichnen */
  SetAPen(rp,1);
  draw_active(x,y);

  /* loeschen */
  x = ((x_win_i_width-CREQ_WIDTH)/2) + WIN_X_KOO+CREQ_COL_1_X-2,
  y = ((x_win_i_height-CREQ_HEIGHT)/2) + WIN_Y_KOO+CREQ_COL_1_Y-2;
  SetAPen(rp,0);
  draw_active(x,y);
  SetAPen(rp,1);
  current_col.col_number_t = 0;
}

void set_1_active(void)
{
  register struct RastPort *rp = &(screen->RastPort);
  register long x = ((x_win_i_width-CREQ_WIDTH)/2) + WIN_X_KOO+CREQ_COL_1_X-2,
	        y = ((x_win_i_height-CREQ_HEIGHT)/2) + WIN_Y_KOO+CREQ_COL_1_Y-2;

  /* zeichnen */
  SetAPen(rp,1);
  draw_active(x,y);

  /* loeschen */
  x = ((x_win_i_width-CREQ_WIDTH)/2) + WIN_X_KOO+CREQ_COL_0_X-2,
  y = ((x_win_i_height-CREQ_HEIGHT)/2) + WIN_Y_KOO+CREQ_COL_0_Y-2;
  SetAPen(rp,0);
  draw_active(x,y);
  SetAPen(rp,1);
  current_col.col_number_t = 1;
}

void set_col_0(void)
{
  cprop_r_info.HorizPot = (USHORT)(current_col.red_t0 * 4095);
  cprop_g_info.HorizPot = (USHORT)(current_col.green_t0 * 4095);
  cprop_b_info.HorizPot = (USHORT)(current_col.blue_t0 * 4095);
}

void set_col_1(void)
{
  cprop_r_info.HorizPot = (USHORT)(current_col.red_t1 * 4095);
  cprop_g_info.HorizPot = (USHORT)(current_col.green_t1 * 4095);
  cprop_b_info.HorizPot = (USHORT)(current_col.blue_t1 * 4095);
}


void show_col_request(void)
{
  register long y = (x_win_i_height - CREQ_HEIGHT) / 2,
 	        x = (x_win_i_width - CREQ_WIDTH) / 2;

  if (is_colre) {
    return;
  }
  if (is_about) {
    AboutWinDown();
  }

  current_col.red_t0   = current_col.red_0;
  current_col.green_t0 = current_col.green_0;
  current_col.blue_t0  = current_col.blue_0;
  current_col.red_t1   = current_col.red_1;
  current_col.green_t1 = current_col.green_1;
  current_col.blue_t1  = current_col.blue_1;  

  color_request.TopEdge = y;
  color_request.LeftEdge = x;

  set_col_0();

  PROFILE_OFF();
  Request(&color_request,win2);
  PROFILE_ON();

  set_colre;				/* Requester am Bildschirm */
  x += WIN_X_KOO + CREQ_COL_1_X+1;
  y += WIN_Y_KOO + CREQ_COL_1_Y+1;
  SetAPen(&(screen->RastPort),1);
  RectFill(&(screen->RastPort), x, y, x+CREQ_COL_WIDTH-3, y+CREQ_COL_HEIGHT-3);

  set_0_active();
}

void refresh_props(void)
{
  RefreshGadgets(&color_blue_gadg,win2,&color_request);
}


void remove_col_request(void)
{
  if (is_colre && win2 != NULL) {
    unset_colre;
    EndRequest(&color_request,win2);
  }
}

#else	/* !REQ_LIBRARY */

#include 	<stdarg.h>
#include	<libraries/reqbase.h>
#include 	<clib/req_protos.h>
#include	<pragmas/req.h>

extern struct ReqLib		*ReqBase;

void show_col_request(void)
{
  long newcolor;

  /* Fatal(10,"Huhu. bäää... %s Program ist tot!","Mein");  ** TEST */

  if (is_colre) {
    return;
  }
  if (is_about) {
    AboutWinDown();
  }

  if (ReqBase == NULL) {
    Warning(MSG_NEED_REQ_LIB);   
    return;
  }

  set_colre;
  sleep_pointer();

  PROFILE_OFF();
  newcolor = ColorRequester(1L);
  PROFILE_ON();

  if (newcolor != -1) {
     struct ColorMap *cmap = screen->ViewPort.ColorMap;
     short *coltab;

     coltab = (short *)cmap->ColorTable;
     
     current_col.red_0   = (coltab[0] & 0x0F00) >> 8;
     current_col.green_0 = (coltab[0] & 0x00F0) >> 4;
     current_col.blue_0  =  coltab[0] & 0x000F;
     current_col.red_1   = (coltab[1] & 0x0F00) >> 8;
     current_col.green_1 = (coltab[1] & 0x00F0) >> 4;
     current_col.blue_1  =  coltab[1] & 0x000F;
     current_col.red_2   = (coltab[2] & 0x0F00) >> 8;
     current_col.green_2 = (coltab[2] & 0x00F0) >> 4;
     current_col.blue_2  =  coltab[2] & 0x000F;
     current_col.red_3   = (coltab[3] & 0x0F00) >> 8;
     current_col.green_3 = (coltab[3] & 0x00F0) >> 4;
     current_col.blue_3  =  coltab[3] & 0x000F;
     
     /* wenn Farbe ueber Col-Req geaendert, dann nicht mehr clonen! */
     unset_clwbcol;
  }
  
  clear_pointer();
  unset_colre;
}

#endif	/* !REQ_LIBRARY */


void __stdargs ok(char *format, ...)
{
  volatile va_list ap;

  va_start(ap,format);
  MySimpleRequest(1, NULL, NULL, NULL, NULL, format, va_arg(ap, long), va_arg(ap, long), va_arg(ap, long));
  va_end(ap);
}

int __stdargs MySimpleRequest(int NrBut, char *Lbut, char *Rbut, char *Mbut, char *title, char *format,...)
{
  volatile va_list ap;
  int ret = FALSE;
  
  if (title == NULL) title = GetTeXString(MSG_SHOWDVI_REQUEST);
  if (Lbut == NULL)  Lbut = GetTeXString(MSG_OK);
  if (Rbut == NULL)  Rbut = GetTeXString(MSG_CANCEL);
  if (Mbut == NULL)  Mbut = GetTeXString(MSG_OK);

  va_start(ap,format);

  if (is_os2) {
    struct EasyStruct MyES;
    

    strcpy(m_string, Lbut);
    if (NrBut > 2) {
      strcat(m_string, "|");
      strcat(m_string, Mbut);
    }
    if (NrBut > 1) {
      strcat(m_string, "|");
      strcat(m_string, Rbut);
    }

    MyES.es_StructSize = sizeof(MyES);
    MyES.es_Flags = 0;
    MyES.es_Title = title;
    MyES.es_TextFormat = format;
    MyES.es_GadgetFormat = m_string;
    
    PROFILE_OFF();
    ret = EasyRequestArgs(win2, &MyES, NULL, ap);
    PROFILE_ON();
  }
#if defined(REQ_LIBRARY)
  else {
    if (ReqBase == NULL) {
      Message(MSG_NEED_REQ_LIB);
    }
    else {
      struct TRStructure trs;
      
      if (NrBut <= 1) {
        Lbut = Mbut = NULL;
        Rbut = GetTeXString(MSG_OK);
      }
      if (NrBut <= 2) {
        Mbut = NULL;
      }

      trs.Text     = format;
      trs.Controls = ap;
      trs.Window = 0;
      trs.MiddleText = Mbut;
      trs.PositiveText = Lbut;
      trs.NegativeText = Rbut;
      trs.Title = title;
      trs.KeyMask = (short)0xFFFF;
      trs.textcolor = 1;
      trs.detailcolor = 1;
      trs.blockcolor = 1;
      trs.versionnumber = REQVERSION;
      trs.Timeout = 0; 		/* you could put a timeout here if you wanted */
      trs.AbortMask = 0;  	/* If you wanted to abort this requester from another */
				/* process, pass the mask for Signal() in this element. */
				/* Then just Signal() the process that brought up the requester */
      trs.rfu1 = 0;
      ret = TextRequest(&trs);
    }
  }
#endif
  va_end(ap);
  
  return ret;
}



/* Struktur fuer den Fatal-Requester */
static struct EasyStruct FatalES = {
    sizeof (struct EasyStruct),
    0,
    NULL,
    NULL,
    NULL
};

/* show the message in an easy-request... */
void FatalMessage(int ret, char *msg)
{
  char *TxtFmt;
  
  FatalES.es_Title = GetTeXString(MSG_SHOWDVI_FATAL_MESSAGE);
  FatalES.es_GadgetFormat = GetTeXString(MSG_OK);

  if (ret < 6)        TxtFmt = GetTeXString(MSG_FATAL_WRONG);
  else if (ret ==  9) TxtFmt = GetTeXString(MSG_FATAL_CHIPMEM);
  else if (ret == 10) TxtFmt = GetTeXString(MSG_FATAL_MEMORY);
  else if (ret < 16)  TxtFmt = GetTeXString(MSG_FATAL_INTERNAL);
  else		      TxtFmt = GetTeXString(MSG_FATAL_FATAL);

  if (is_os2) {
    FatalES.es_TextFormat = TxtFmt;
    /* der Return-Code ist unwichtig, da das Programm ohnehin nur beendet werden soll */
    PROFILE_OFF();
    (void)EasyRequestArgs(win2, &FatalES, NULL, &msg);
    PROFILE_ON();
  }
#if defined(REQ_LIBRARY)
  else {
    if (ReqBase != NULL) {
      struct TRStructure trs;

      /* hier auf keinen Fall ein Fatal(), da sonst Endlosschleife!! */
      trs.Text     = TxtFmt;
      trs.Controls = (char *)&msg;	/* dies funktioniert sogar! */
      trs.Window       = 0;
      trs.MiddleText   = NULL;
      trs.PositiveText = GetTeXString(MSG_OK);
      trs.NegativeText = NULL;
      trs.Title = GetTeXString(MSG_SHOWDVI_FATAL_MESSAGE);
      trs.KeyMask = (short)0xFFFF;
      trs.textcolor = 1;
      trs.detailcolor = 1;
      trs.blockcolor = 1;
      trs.versionnumber = REQVERSION;
      trs.Timeout = 60; 		/* you could put a timeout here if you wanted */
      trs.AbortMask = 0;  		/* If you wanted to abort this requester from another */
					/* process, pass the mask for Signal() in this element. */
					/* Then just Signal() the process that brought up the requester */
      trs.rfu1 = 0;
      (void)TextRequest(&trs);
    }
  }
#endif
}


/* Struktur fuer die Exit-Abfrage */
static struct EasyStruct ExitES = {
    sizeof (struct EasyStruct),
    0,
    NULL,
    NULL,
    NULL
};


long real_prog_end(void)
{ 
  long ret = FALSE;
  
  ExitES.es_Title	 = GetTeXString(MSG_SHOWDVI_MESSAGE);
  ExitES.es_TextFormat	 = GetTeXString(MSG_REALLY_QUIT);
  ExitES.es_GadgetFormat = GetTeXString(MSG_YES_NO);

  if (can_i_exit()) {
    if (is_quickex) {
      ret = TRUE;
    }
    else {
      if (is_os2) {
        PROFILE_OFF();
        ret = EasyRequestArgs(win2, &ExitES, NULL, NULL);
        PROFILE_ON();
      }
      else {
        ret = (long)AutoRequest(win2,&end_body_text,&end_positive_text,&end_negative_text,0,0,270,70);
      }
    }
  }

  /* weg mit MENUVERIFY!! */
  if (ret &&!is_osmenu) MyModifyIDCMP(0, IDCMP_MENUVERIFY);

  return ret;
}


#endif




/*======================================================================================*/
/*		F I L E R E Q E S T E R  --  F U N K T I O N E N			*/
/*======================================================================================*/



#if defined(ARP_FILEREQ)
  static long __stdargs ArpFileFuncReq	(LONGBITS mask, CPTR object);
  static long 		ArpLoadFileReq	(void);
  static void 		ArpInitFileReq	(void);
  static void		ArpFreeFileReq	(void);
  static int 		ArpShowFileReq  (char *str);
#endif

#if defined(REQ_FILEREQ)
  static long 		ReqLoadFileReq	(void);
  static void 		ReqInitFileReq	(void);
  static void		ReqFreeFileReq	(void);
#endif

#if defined(ASL_FILEREQ)
  static long 		AslLoadFileReq	(void);
  static void 		AslInitFileReq	(void);
  static void		AslFreeFileReq	(void);
/*
  static ULONG __stdargs AslFileFuncReq (ULONG Mask, struct AnchorPath *anchor, 
						struct FileRequester *req);
*/
#endif



void InitFileReq(void)
{
#if defined(ASL_FILEREQ)
  AslInitFileReq();
#endif
#if defined(REQ_FILEREQ)
  ReqInitFileReq();
#endif
#if defined(ARP_FILEREQ)
  ArpInitFileReq();
#endif
}

long LoadFileReq(void)
{
#if defined(ASL_FILEREQ)
  return AslLoadFileReq();
#endif
#if defined(REQ_FILEREQ)
  return ReqLoadFileReq();
#endif
#if defined(ARP_FILEREQ)
  return ArpLoadFileReq();
#endif
}

void FreeFileReq(void)
{
#if defined(ASL_FILEREQ)
  AslFreeFileReq();
#endif
#if defined(REQ_FILEREQ)
  ReqFreeFileReq();
#endif
#if defined(ARP_FILEREQ)
  ArpFreeFileReq();
#endif
}




#if defined(ARP_FILEREQ) /* ------------------------------------------------------ */

#undef FCHARS
#undef DSIZE
#include "small_arp.h"

static struct ARPFileRequester	*file_req;


static long __stdargs ArpFileFuncReq(LONGBITS mask, CPTR object)
{
  struct AnchorPath *info = (struct AnchorPath *)object;
  struct FileInfoBlock *fib;
  char *hptr;

  if (mask != FRF_DoWildFunc || info == NULL) {
    return 0L;
  }

  fib = &(info->ap_Info);

  if (fib->fib_EntryType > 0) return 0L;	/* Dirs immer */
  hptr = strrchr(fib->fib_FileName,'.');
  if (hptr == NULL) return 1L;			/* kein Punkt ?? */
  if (stricmp(hptr,".dvi")) return 1L;		/* kein .dvi ?? */

  return 0L;
}


static long ArpLoadFileReq(void)
{
  char fr_file[108], *ptr, fname[108], c;
  long ret;
  int i, ac;

  if (is_arp) {
    ac = 0;	/* importand */
    strcpy(file_req->fr_Dir,
		(char *)((struct StringInfo *)(dir_Gad.SpecialInfo))->Buffer);
    strcpy(file_req->fr_File,
		(char *)((struct StringInfo *)(fil_Gad.SpecialInfo))->Buffer);

    ptr = strrchr(file_req->fr_Dir,'/');
    if (ptr != NULL && *(ptr+1) == '\0') {	/* / at the end */
      *ptr = '\0';
    }

    ptr = strrchr(file_req->fr_File,'.');
    if (ptr == NULL || strcmp(ptr,".dvi") != 0) {
      strcat(file_req->fr_File,".dvi");
    }

    if (ArpShowFileReq(fr_file)) {
      strcpy(fname,file_req->fr_Dir);
      TackOn(fname,file_req->fr_File);
      ptr = strrchr(fname,'.');
      if (ptr == NULL || strcmp(ptr,".dvi") != 0 ||
          (ac = access(fname,4)) != 0 ) {
	ptr = (char *)((struct StringInfo *)(dir_Gad.SpecialInfo))->Buffer;
        strcpy(ptr, file_req->fr_Dir);
        i = strlen(ptr);
        if (i > 0)  { 	/* haenge slash an */
          c = ptr[i-1];
          if (c != ':' && c != '/' )  {
             ptr[i] = '/';
             ptr[i+1] = (char)0;
          }
        }
        strcpy((char *)((struct StringInfo *)(fil_Gad.SpecialInfo))->Buffer,
		file_req->fr_File);
        RefreshGadgets(&dir_Gad,win2,NULL);
        if (strlen(fname) > 30) {
          strcpy(fname,file_req->fr_File);
        }
        if (ac == 0) {
          sprintf(m_string,GetTeXString(MSG_FILE_ISNT_DVI_FILE),fname);
        }
        else {
          sprintf(m_string,GetTeXString(MSG_CANT_FOUND_FILE),fname);
        }
        Message(m_string);
        beep();
        ret = 5L;
      }
      else {
        strcpy(filename,fname);
        OpenNewDVI(fname, FALSE);
        ret = 4L;		    /* neues File, Name geaendert. */
      }
    }
    else {
      ret = 5L;
    }
  }
  else {
    Message("I need the ARP-Library!");
    beep();
    ret = 5L;
  }
  return ret;
}


static void ArpInitFileReq(void)
{
  void (*func)();

  if (!is_arp) {
    return;
  }

  func = (void *)&ArpFileFuncReq;

  file_req = ArpAllocFreq();
  if (file_req == NULL) {
    Fatal(10,MSG_CANT_ALLOC_FREQ);
  }
  file_req->fr_Hail = GetTeXString(MSG_LOAD_NEW_DVI);
  file_req->fr_FuncFlags |= FRF_DoWildFunc;
  file_req->fr_Function = func;
}


#define FR_HEIGHT	100
#define FR_WIDTH	200



static int ArpShowFileReq(char *str)
{
  char *hptr;
  register int x=(x_scr_width-FR_WIDTH-20)/2,
	       y=(x_scr_height-FR_HEIGHT-20)/2;

/*
  if (x+FR_WIDTH > x_scr_width) x = x_scr_width-FR_WIDTH;
  if (y+FR_HEIGHT > x_scr_height) y = x_scr_height-FR_HEIGHT;
*/

  file_req->fr_Window = win2;
  file_req->fr_LeftEdge = x;
  file_req->fr_TopEdge = y;

  PROFILE_OFF();
  hptr = FileRequest(file_req);
  PROFILE_ON();

  if (hptr == NULL)
    return (FALSE);

  strcpy(str,hptr);
  return (TRUE);
}


static void ArpFreeFileReq(void)
{
  return;
}


#endif /* ARP_FILEREQ  ------------------------------------------------------------- */




#if defined(REQ_FILEREQ)   /* ------------------------------------------------------ */


static struct ReqFileRequester	MyFileReqStruct;
static short IsReqStarted = FALSE;
static char ReqFileName[FCHARS];
static char ReqDirName[DSIZE];

static long ReqLoadFileReq(void)
{
  char answerarray[DSIZE+FCHARS];
  long ret;
  char *ptr;



  if (ReqBase != NULL) {

	answerarray[0] = 0;



	/* Initialize the 'PathName' field so that the file requester will */
	/* construct a complete path name for me.  It will also put the two */
	/* parts of the answer (directory and file name) into the directory */
	/* file name which I also decided to supply it with.  Since the */
	/* directory and file name arrays are present, it will use their */
	/* initial contents as the initial file and directory.  If they aren't */
	/* present it will leave both blank to start. */

#if 0
	strcpy(&(ReqDirName[0]),(char *)((struct StringInfo *)(dir_Gad.SpecialInfo))->Buffer);
	strcpy(&(ReqFileName[0]), (char *)((struct StringInfo *)(fil_Gad.SpecialInfo))->Buffer);
#else
	if (is_dir(filename)) {
	  strcpy(ReqDirName, filename);
	  ReqFileName[0] = '\0';
	}
	else {
	  strcpy(ReqFileName, FilePart(filename));
	  ptr = strrchr(filename, '/');
	  if (ptr == NULL) ptr = strchr(filename, ':');
	  if (ptr == NULL) ReqDirName[0] = '\0';
	  else {
	    int n = ptr - filename;
	    if (*ptr == ':') n++;		// Doppelpunkt kommt mit
	    strncpy(ReqDirName, filename, n);
	    ReqDirName[n] = '\0';
	  }
	}
#endif
  
	/* printf("Dir: '%s', File: '%s'\n", ReqDirName, ReqFileName); */

	MyFileReqStruct.PathName = answerarray;
	MyFileReqStruct.Dir = ReqDirName;
	MyFileReqStruct.File = ReqFileName;

	/* The directory caching of this file requester is one of its nice */
	/* features, so I decided to show it off.  It is completely optional */
	/* though, so if you don't want it, don't set this flag.  If you do */
	/* want it, don't forget to call PurgeFiles() when you are done. */
	MyFileReqStruct.Flags = FRQCACHINGM | FRQHIDEWILDSM | FRQABSOLUTEXYM;

	/* Initialize a few colour fields.  Not strictly necessary, but */
	/* personally, I like having my files a different colour from my */
	/* directories. */
	if (is_col4) {
	  MyFileReqStruct.dirnamescolor = 2;
	  MyFileReqStruct.devicenamescolor = 1;
	}
	else {
	  MyFileReqStruct.dirnamescolor = 1;
	  MyFileReqStruct.devicenamescolor = 1;
	}

	MyFileReqStruct.numlines = 30;

	/* I could also make it larger, pass it a file and/or directory */
	/* name, set the window title, set various flags and customize */
	/* in many other ways, but I wanted to show that it can be easily */
	/* used without having to fill in a lot of fields. */

	MyFileReqStruct.VersionNumber = REQVERSION;
	MyFileReqStruct.Title = GetTeXString(MSG_LOAD_NEW_DVI);
	strcpy(MyFileReqStruct.Show, "*.dvi");

	IsReqStarted = TRUE;

        PROFILE_OFF();
	if (FileRequester(&MyFileReqStruct)) {
  
            PROFILE_ON();

	    /* printf("Result: '%s', Dir: '%s', File: '%s'\n",
      			MyFileReqStruct.PathName,
      			MyFileReqStruct.Dir,
      			MyFileReqStruct.File); */

	    ptr = strrchr(answerarray, '.');
	    if (ptr == NULL || stricmp(ptr, ".dvi") != 0) {
	      strcat(answerarray, ".dvi");
	    }

	    if (access(answerarray, 4) != 0) {
	      Message(MSG_CANT_FOUND_FILE, answerarray);
	      beep();
	      ret = 5L;
	    }
	    else {
	      if (stricmp(filename, &(answerarray[0])) == 0) {
	        OpenNewDVI(&(answerarray[0]), FALSE);
	        ret = 3L;		    /* neues File, Name *nicht* geaendert. */
	      }
	      else {
	        strcpy(filename, &(answerarray[0]));
	        OpenNewDVI(&(answerarray[0]), FALSE);
	        ret = 4L;		    /* neues File, Name geaendert. */
	      }
	    }
	}
	else {
	    PROFILE_ON();
	    ret = 5L;
	}
	
  }
  else {
    Message(MSG_NEED_REQ_LIB);
    ret = 5L;
  }

  return ret;
}

static void ReqInitFileReq(void)
{
  return;
}

static void ReqFreeFileReq(void)
{
  if (ReqBase && IsReqStarted) {
    PurgeFiles(&MyFileReqStruct);	/* Only necessary if the FRQCACHINGM flag */
    IsReqStarted = FALSE;
  }
}


#endif /* REQ_FILEREQ  ------------------------------------------------------------- */


#if defined(ASL_FILEREQ)  /* ------------------------------------------------------- */


#include <libraries/asl.h>
#include <clib/asl_protos.h>
#include <pragmas/asl_pragmas.h>

extern struct Library 		* AslBase;
static struct FileRequester 	* AslRequestPtr = NULL;
static char 			* AslFileTitle  = NULL;
static char 			  AslFileName[FCHARS+1];
static char 			  AslDirName[DSIZE+1];


static long AslLoadFileReq(void)
{
  long ret = 5;
  char * ptr;
  char answerarray[FCHARS+DSIZE+1];

  if (AslBase != NULL && AslRequestPtr != NULL) {
    if (is_dir(filename)) {
      strcpy(AslDirName, filename);
      AslFileName[0] = '\0';
    }
    else {
      strcpy(AslFileName, FilePart(filename));
      ptr = strrchr(filename, '/');
      if (ptr == NULL) ptr = strchr(filename, ':');
      if (ptr == NULL) AslDirName[0] = '\0';
      else {
        int n = ptr - filename;
        if (*ptr == ':') n++;		// Doppelpunkt kommt mit
        strncpy(AslDirName, filename, n);
        AslDirName[n] = '\0';
      }
    }

    PROFILE_OFF();
    if (AslRequestTags(AslRequestPtr, ASLFR_Window, win2, 
				      ASLFR_PrivateIDCMP, TRUE, 
				      ASLFR_TitleText, AslFileTitle, 
				      ASLFR_InitialFile, AslFileName,
				      ASLFR_InitialDrawer, AslDirName,
				      TAG_DONE)) {

      PROFILE_ON();
      if (AslRequestPtr->rf_File[0] == 0) return 5;	// leere Eingabe

      strncpy(answerarray, AslRequestPtr->rf_Dir, sizeof(answerarray)-1);
      AddPart(answerarray, AslRequestPtr->rf_File, sizeof(answerarray)-1);

      if (access(answerarray, 4) != 0) {
        ptr = strrchr(answerarray, '.');
        if (ptr == NULL || stricmp(ptr, ".dvi") != 0) {
          strcat(answerarray, ".dvi");
        }
      }

      if (access(answerarray, 4) != 0) {
        Message(MSG_CANT_FOUND_FILE, answerarray);
        beep();
        ret = 5L;
      }
      else {
        if (stricmp(filename, &(answerarray[0])) == 0) {
          OpenNewDVI(&(answerarray[0]), FALSE);
          ret = 3L;		    /* neues File, Name *nicht* geaendert. */
        }
        else {
          strcpy(filename, &(answerarray[0]));
          OpenNewDVI(&(answerarray[0]), FALSE);
          ret = 4L;		    /* neues File, Name geaendert. */
        }
      }
    }
    else {
      PROFILE_ON();
    }
  }
  return ret;
}


static void AslInitFileReq(void)
{
  AslFileTitle = GetTeXString(MSG_LOAD_NEW_DVI);
  if (AslBase != NULL && AslFileTitle) {
    AslRequestPtr = AllocAslRequestTags(ASL_FileRequest, ASLFR_SleepWindow, TRUE, 
							 ASLFR_InitialPattern, "#?.dvi", 
							 ASLFR_DoPatterns, TRUE,
							 TAG_DONE);
    if (AslRequestPtr == NULL) {
      Warning(MSG_CANT_ALLOC_ASLREQ);
    }
  }
}


static void AslFreeFileReq(void)
{
  if (AslBase != NULL && AslRequestPtr != NULL) {
    FreeAslRequest(AslRequestPtr);
    AslRequestPtr = NULL;
  }
}

#endif /* ASL_FILEREQ  ------------------------------------------------------------- */





int MyGetString(char *title, char *result)
{
#if defined(REQ_LIBRARY)
  struct GetStringStruct gss;

  if (ReqBase != NULL) {
    memset(&gss, 0, sizeof(gss));
    gss.titlebar      = title;
    gss.stringbuffer  = result;
    gss.stringsize    = 100;
    gss.visiblesize   = 30;
    gss.versionnumber = REQVERSION;
    PROFILE_OFF();
    if (NewGetString(&gss)) {
      PROFILE_ON();
      return TRUE;
    }
    else {
      PROFILE_ON();
      return FALSE;
    }
  }
  else {
    Warning(MSG_NEED_REQ_LIB);
    return FALSE;
  }
#else
  return FALSE;
#endif
}

int MyGetLong(char *title, long min, long max, long defval, long *result)
{
#if defined(REQ_LIBRARY)
  struct GetLongStruct	gls;

  if (ReqBase != NULL) {
    gls.titlebar   = title;
    gls.defaultval = defval;
    gls.minlimit   = min;
    gls.maxlimit   = max;
    gls.window     = NULL;
    gls.versionnumber = REQVERSION;
    if (defval == -12321) {	/* magic number for 'no default' */
      gls.flags    = GLNODEFAULTM;
    }
    else {
      gls.flags    = 0;
    }
    gls.rfu2       = 0;
    PROFILE_OFF();
    if (GetLong(&gls)) {
      PROFILE_ON();
      *result = gls.result;
      return TRUE;
    }
    else {
      PROFILE_ON();
      return FALSE;
    }
  }
  else {
    return FALSE;
  }
#else
  return FALSE;
#endif
}


void Okay1(char *text)
{
  (void)MySimpleRequest(1, NULL, NULL, NULL, NULL, text);
}


int Okay2(char *text)
{
  return MySimpleRequest(2, NULL, NULL, NULL, NULL, text);
}


void ChangeFormatFile(void)
{
  char con[100];
  int ret;

  if (is_os2) {
    ret = GetVar("TEXFORMAT", con, 90, GVF_GLOBAL_ONLY);
    if (ret == -1) { 
      strcpy(con, "plain");
    }
    if (MyGetString(GetTeXString(MSG_FORMAT_FILE_NAME), con)) {
      if (!SetVar("TEXFORMAT", con, -1, GVF_GLOBAL_ONLY)) {
        Warning(MSG_CANT_SET_VARIABLE, "TEXFORMAT");
      }
    }
  }
}




static struct TagItem StartComTags[] = {
	{SYS_Input,     NULL },
	{SYS_Output,    NULL },
	{SYS_Asynch,    TRUE },
	{SYS_UserShell, TRUE },
	{NP_Priority,   0    },
	{NP_StackSize,  4096 },
	{NP_WindowPtr,  NULL },
	{TAG_DONE,      NULL } };

int start_command(char *title, char *name, char *PubScr)
{
  char con[150];
  BPTR fh;
  int ret = 0;
  
  if (is_os2) {
    sprintf(con, "CON:%d/%d/%d/%d/%s/AUTO/CLOSE/WAIT/SCREEN %s",
		win2->LeftEdge+win2->BorderLeft+3, win2->TopEdge+win2->BorderTop+3,
		win2->Width-win2->BorderLeft-win2->BorderRight-22,
		(is_lace) ? 200 : 120, title, ((PubScr != NULL) ? PubScr : GetCurrentPubScr()));
    if (fh = Open(con, MODE_NEWFILE)) {
      StartComTags[0].ti_Data = fh;
      StartComTags[6].ti_Data = (ULONG)win2;	/* das Fenster *muss* dann aber auch offen bleiben! */
      if (SystemTagList(name, StartComTags)) {
        Close(fh);
        ret = 1;
      }
    }
    else {
      ret = 2;
    }
  }
  return ret;
}


/*
 * GetScreenMode()
 *
 * Ruft den Screenmode Requester der asl-Library auf (V38)
 *
 * Das Argument DisplayID wird sowohl als Initial-Wert, als auch 
 * als Rueckgabe-Wert verwendet.
 * Das Window (zweite Argument) wird eingeschlaefert, solange der
 * Requester oben ist. Auch win2 wird eingeschlaefert.
 *
 * Rueckgabewert FALSE bedeutet, dass etwas fehlgeschlagen ist.
 * Dann ist das Argument unveraendert.
 *
 */

static struct TagItem ScrModeTags[] = 
 { { ASLSM_Screen, NULL		},
   { ASLSM_InitialDisplayID, 0L	},
   { ASLSM_Window, NULL		},
   { ASLSM_SleepWindow, TRUE	},
   { ASLSM_PrivateIDCMP, FALSE	},
   { TAG_DONE, TRUE		}
 };

int GetScreenMode(ULONG * DisplayID, struct Window * w)
{
  int ret = FALSE;
  struct ScreenModeRequester * requester;
  
  if (AslBase == NULL || AslBase->lib_Version < 38) return ret;	// V38 benoetigt

  ScrModeTags[0].ti_Data = (ULONG)screen;
  ScrModeTags[1].ti_Data = *DisplayID;
  ScrModeTags[2].ti_Data = (long)w;
  
  requester = AllocAslRequest(ASL_ScreenModeRequest, ScrModeTags);
  if (requester != NULL) {
    sleep_pointer();
    PROFILE_OFF();
    if (AslRequest(requester, ScrModeTags)) {
      PROFILE_ON();
      *DisplayID = requester->sm_DisplayID;
      ret = TRUE;
    }
    else {
      PROFILE_ON();
    }
    FreeAslRequest(requester);
    clear_pointer();
  }
  return ret;
}


/************************/

int StartSearch(enum SearchOpt opt)
{
  int ret = 5;
  ULONG ret_sigs;
  enum SearchActions sr = SEARCHWIN_ACTION_NONE;
  char SBuf[100] = "";

  if (is_dvif) {
  
    sleep_pointer();
  
    if (opt == SO_StartSearchAgain) {
      char * ptr = GetCurSearchString();

      if (ptr) {
  	InitBMSearch(ptr);
	SearchStartPage = current_page_phy;
	InSearchMode = TRUE;
	ret = 6;
      }
      else {
        ret = 5;
      }
      
      clear_pointer();
      
      return ret;
    }

    OpenSearchWin();

#if 0    
    do {
      ret_sigs = Wait((1<<sig_searchwin) | SIGBREAKF_CTRL_C);
 
      if (ret_sigs & SIGBREAKF_CTRL_C) {
        CXBRK();		/* CTRL C  --  Prog. Ende 	*/
        return 5;		/* oder falls es nicht geht... 	*/
      }

      sr = DoSearchWin(SBuf, sizeof(SBuf)-1);
      
    } while (sr == SEARCHWIN_ACTION_NONE);
    
    switch (sr) {
      case SEARCHWIN_ACTION_CLOSE:
      case SEARCHWIN_ACTION_CANCEL:
        ret = 5;
      	break;
      case SEARCHWIN_ACTION_SEARCH:
        // das Fenster bleibt noch auf!
        if (*SBuf != '\0') {
  	  InitBMSearch(SBuf);
	  SearchStartPage = current_page_phy;
	  InSearchMode = TRUE;
	  ret = 6;
	}
	else {
	  ret = 5;
	}
	break;
      default:
        ret = 5;	// eigentlich ein Fatal() wert..
    }
#endif
    
    clear_pointer();
  }


  return ret;
}

