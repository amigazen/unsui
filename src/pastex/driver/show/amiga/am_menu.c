/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from am_menu.c
*/
/** am_menu.c **/

#ifdef AMIGA


#include "defines.h"

#include <stdio.h>
#include <intuition/intuition.h>
#include <intuition/imageclass.h>
#include <intuition/screens.h>
#include <libraries/dos.h>
#include <libraries/gadtools.h>
#include <dos/dostags.h>

#include "globals.h"

#ifdef ANSI
#  include <stdlib.h>
#  include <string.h>
#endif

#ifdef AZTEC_C
#  include <functions.h>
#endif


#include <dos.h>

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/dos_protos.h>
#include <clib/graphics_protos.h>
#include <clib/gadtools_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/gadtools_pragmas.h>

#include "amscreen.h"
#include "am_menu.h"
#include "gad_def.h"		/* dir_Gad and fil_Gad */

#include "amscreen.i"
#include "messwin.i"
#include "gadget.i"
#include "am_menu.i"
#include "am_requ.i"
#include "globals.i"
#include "showdvi.i"
#include "config.i"
#include "dvihand.i"
#include "prefwin.i"
#include "local.i"

#include "newcli.i"





/* lokale Funktionen */

static void draw_arrow			Args((struct RastPort *rp,
					      long x,
					      long y));
static void draw_frame			Args((struct RastPort *rp,
					      long x,
					      long y,
					      long width,
					      long height));
static void check_bounds		Args((long *x,
					      long *y,
					      long width,
					      long height));
static void prepare_menu		Args((struct RastPort *rp,
					      struct RastPort *save_rp,
					      long x,
					      long y,
					      long width,
					      long height));
static void clear_current_submenu	Args((int menu));
static void display_submenu_outfit	Args((void));
static void display_submenu_load	Args((void));
static void display_submenu_resolution	Args((void));
static void display_menu		Args((int menu,
        		                      int zeile,
                		              int col,
                		              int sub_zeile));
static void mark_line_sub_menu		Args((struct RastPort *rp,
					      int menu,
					      int zeile));
static void mark_line_main_menu		Args((struct RastPort *rp,
					      int zeile,
					      int spalte));
static void work_with_submenu		Args((struct RastPort *rp,
					      int x,
		                              int y,
        		                      int menu,
                		              int *old_sub_zeile));
static void work_with_menu		Args((struct RastPort *rp,
					      int x,
		                              int y,
        		                      int *menu,
        		                      int *old_zeile,
                		              int *old_col,
                		              int *old_sub_zeile));
static long do_menu			Args((int menu,
		                	      int zeile,
		                	      int col,
		                	      int sub_zeile,
		        	              int mx,
        		        	      int my));
static void init_bmap			Args((struct BitMap *bm,
					      struct RastPort *rp,
					      long width,
					      long height));
static void free_bmap			Args((struct BitMap *bm,
					      long width,
					      long height));

static struct MenuItem *FindMenuEntry	Args((struct Menu *Menu,
					      short menunum, short itemnum, short subnum));
static void MenuAnAus			Args((struct Menu *Men,
					      short menunum, short item, short sub,
					      short on));
static void MyLayoutMenu		Args((void));
static struct MenuItem *LayoutOneMenu	Args((struct RastPort *rp,
					      struct MenuLayout *MLay,
					      int NrEntries,
					      int spacelen,
					      int width));


  
#define MenuAn(men,num,item,sub)	MenuAnAus(men,num,item,sub,TRUE)
#define MenuAus(men,num,item,sub)	MenuAnAus(men,num,item,sub,FALSE)






/* Globale Variablen innerhalb des Moduls */

static struct RastPort		menu_save_rp,
				smenu_o_save_rp,	/* SubM outfit */
				smenu_l_save_rp,	/* SubM load DVI */
				smenu_r_save_rp;	/* SubM resolution */

static struct BitMap		menu_save_bm,
				smenu_o_save_bm,
				smenu_l_save_bm,
				smenu_r_save_bm;

static long			menu_offset_x,
				menu_offset_y,
				current_submenu_x,
				current_submenu_y;

static short menu_width,
	     menu_height,
	     smenu_o_width,
	     smenu_o_height,
	     smenu_l_width,
	     smenu_l_height,
	     smenu_r_width,
	     smenu_r_height;


static short			last_zeile,
				last_sub_zeile,
				last_col;

static short			txt_width,
				txt_height;

static struct TextFont		*menu_font,
				*normal_font;







/* externe Variablen */

extern struct ArpBase		*ArpBase;
extern long			resolution;
extern struct TextFont		*font8,
				*font11;
extern char 			PubScreenName[];
extern char 			MyPubScreenName[];



/**** lokale Funktionen ************/

static void draw_arrow(struct RastPort *rp, long x, long y)
{
  x += 4;

  Move(rp,x,y-4);
  Draw(rp,x+6,y-4);
  Move(rp,x,y-2);
  Draw(rp,x+6,y-2);
  Move(rp,x+4,y-6);
  Draw(rp,x+8,y-3);
  Draw(rp,x+4,y);
}

static void draw_frame(struct RastPort *rp, long x, long y, long width, long height)
{
  Move(rp,x,y);
  Draw(rp,x+width-4,y);
  Draw(rp,x+width-4,y+height-4);
  Draw(rp,x,y+height-4);
  Draw(rp,x,y);

  Move(rp,x+width-1,y+4);
  Draw(rp,x+width-1,y+height-1);
  Draw(rp,x+4,y+height-1);

  Move(rp,x+width-2,y+4);
  Draw(rp,x+width-2,y+height-2);
  Draw(rp,x+4,y+height-2);

  Move(rp,x+width-3,y+4);
  Draw(rp,x+width-3,y+height-3);
  Draw(rp,x+4,y+height-3);
}

static void check_bounds(long *x, long *y, long width, long height)
{
  if (*x + width > x_win_width) {
    *x = x_win_width - width;
  }
  else {
    if (*x < 0) {
      *x = 0;
    }
  }
  if (*y + height > x_win_height) {
    *y = x_win_height - height;
  }
  else {
    if (*y < 0) {
      *y = 0;
    }
  }
}


static void prepare_menu(struct RastPort *rp, struct RastPort *save_rp,
			 long x, long y, long width, long height)
{
  /* save data */
  ClipBlit(rp,(long)x,(long)y,save_rp, 0L, 0L,(long)width,(long)height,(long)192);

  /* clear block */
  SetAPen(rp,0);
  RectFill(rp,x,y,x+width-4,y+height-4);	/* -4 because border */
  SetAPen(rp,1);

  /* draw frame */
  draw_frame(rp,x,y,width,height);
}


static void clear_current_submenu(int menu)
{
  register struct RastPort *rp = win2->RPort, *srp;
  register long width, height;

  if (menu != MAIN_MENU) {
    if (menu == SMENU_OUTFIT) {
      width = SMENU_O_WIDTH;
      height = SMENU_O_HEIGHT;
      srp = &smenu_o_save_rp;
    }
    else if (menu == SMENU_LOAD) {
      width = SMENU_L_WIDTH;
      height = SMENU_L_HEIGHT;
      srp = &smenu_l_save_rp;
    }
    else if (menu == SMENU_RESOLUTION) {
      width = SMENU_R_WIDTH;
      height = SMENU_R_HEIGHT;
      srp = &smenu_r_save_rp;
    }
    else {
      Fatal(20,MSG_UNKNOWN_POP_SUBMENU);
    }
    ClipBlit(srp,0L,0L,rp,current_submenu_x,current_submenu_y,width,height,192L);
  }
}


static void display_submenu_outfit(void)
{
  register struct RastPort *rp = win2->RPort;
  long smenu_o_offset_x, smenu_o_offset_y;
  register long y;

  smenu_o_offset_x = menu_offset_x + SUBMENU_SPALTE;
  smenu_o_offset_y = menu_offset_y + YOFFSET * (SMENU_O_START_LINE-1);

  check_bounds(&smenu_o_offset_x,&smenu_o_offset_y,SMENU_O_WIDTH,SMENU_O_HEIGHT);

  prepare_menu(rp,&smenu_o_save_rp,smenu_o_offset_x,smenu_o_offset_y,
		SMENU_O_WIDTH,SMENU_O_HEIGHT);

  current_submenu_x = smenu_o_offset_x;
  current_submenu_y = smenu_o_offset_y;

  y = smenu_o_offset_y+TXTHEIGHT;
  if (!is_bmenu) y++;

  SetFont(rp,menu_font);

  Move(rp,smenu_o_offset_x+3,y);
  if (is_lace) {
    Text(rp,"unset lace     i",16);
  }
  else {
    Text(rp,"set lace       i",16);
  }
  y += YOFFSET;
  Move(rp,smenu_o_offset_x+3,y);
  if (is_gadg) {
    Text(rp,"hide scrollbar o",16);
  }
  else {
    Text(rp,"show scrollbar o",16);
  }
  y += YOFFSET;
  Move(rp,smenu_o_offset_x+3,y);
  Text(rp,"change color  Ac",16);
  y += YOFFSET;
  Move(rp,smenu_o_offset_x+3,y);
  Text(rp,"save config   Aw",16);

  SetFont(rp,normal_font);
}

static void display_submenu_load(void)
{
  register struct RastPort *rp = win2->RPort;
  long smenu_l_offset_x, smenu_l_offset_y;
  long y;

  smenu_l_offset_x = menu_offset_x + SUBMENU_SPALTE;
  smenu_l_offset_y = menu_offset_y + YOFFSET * (SMENU_L_START_LINE-1);

  check_bounds(&smenu_l_offset_x,&smenu_l_offset_y,SMENU_L_WIDTH,SMENU_L_HEIGHT);

  prepare_menu(rp,&smenu_l_save_rp,smenu_l_offset_x,smenu_l_offset_y,
		SMENU_L_WIDTH,SMENU_L_HEIGHT);

  current_submenu_x = smenu_l_offset_x;
  current_submenu_y = smenu_l_offset_y;

  y = smenu_l_offset_y+TXTHEIGHT;
  if (!is_bmenu) y++;

  SetFont(rp,menu_font);

  Move(rp,smenu_l_offset_x+3,y);
  Text(rp,"load file again a",17);
  y += YOFFSET;
  Move(rp,smenu_l_offset_x+3,y);
  Text(rp,"load new file  Ao",17);

  SetFont(rp,normal_font);
}

static void display_submenu_resolution(void)
{
  register struct RastPort *rp = win2->RPort;
  long smenu_r_offset_x, smenu_r_offset_y;
  long height, i, len;
  long y;
  char str[50], hstr[20];

  smenu_r_offset_x = menu_offset_x + SUBMENU_SPALTE;
  smenu_r_offset_y = menu_offset_y + YOFFSET * (SMENU_R_START_LINE-1);

  height = SMENU_R_HEIGHT;

  check_bounds(&smenu_r_offset_x,&smenu_r_offset_y,SMENU_R_WIDTH,height);

  prepare_menu(rp,&smenu_r_save_rp,smenu_r_offset_x,smenu_r_offset_y,
		SMENU_R_WIDTH,height);

  current_submenu_x = smenu_r_offset_x;
  current_submenu_y = smenu_r_offset_y;

  y = smenu_r_offset_y+TXTHEIGHT;
  if (!is_bmenu) y++;

  SetFont(rp,menu_font);

  for (i=0; i<show_state.menu_res_lines; i++) {
    Move(rp,smenu_r_offset_x+3,y);
    y += YOFFSET;
    if (show_state.mres[i] == resolution) {
      len = sprintf(str,"»%4ld dpi",(long)show_state.mres[i]);
    }
    else {
      len = sprintf(str," %4ld dpi",(long)show_state.mres[i]);
    }
    if (i < 9) {
      len += sprintf(hstr, " A%ld", i+1);
      strcat(str, hstr);
    }
    else {
      if (i == 9) {
        len += 3;
        strcat(str, " A9");
      }
    }
    Text(rp,str,len);
  }

  SetFont(rp,normal_font);
}

static void display_menu(int menu, int zeile, int col, int sub_zeile)
{
  register struct RastPort *rp = win2->RPort;
  register long y;

  check_bounds(&menu_offset_x,&menu_offset_y,MENU_WIDTH,MENU_HEIGHT);

  prepare_menu(win2->RPort,&menu_save_rp,menu_offset_x,menu_offset_y,
		MENU_WIDTH,MENU_HEIGHT);

  SetFont(rp,menu_font);

  /* line 1 */
  y = menu_offset_y+TXTHEIGHT;
  if (!is_bmenu) y++;

  Move(rp,menu_offset_x+3,y);
  Text(rp,"about       HELP",16);

  /* line 2 */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  Text(rp,"+",1);
  Move(rp,menu_offset_x+SPALTE-2,y);
  Text(rp," ++",3);

  /* line 3 */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  Text(rp,"-",1);
  Move(rp,menu_offset_x+SPALTE-2,y);
  Text(rp," --",3);

  /* line 4 */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  if (is_show) {
    Text(rp,"show page      f",16);
  }
  else {
    Text(rp,"show full page f",16);
  }

  /* line 5 */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  Text(rp,"clear counter  c",16);

  /* line 6 => submenu outfit */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  Text(rp,"outfit",6);
  draw_arrow(rp,menu_offset_x+SUBMENU_ARROW,y);

  /* line 7 => submenu load */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  Text(rp,"load DVI",8);
  draw_arrow(rp,menu_offset_x+SUBMENU_ARROW,y);

  /* line 8  => submenu resolution */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  Text(rp,"resolution",10);
  draw_arrow(rp,menu_offset_x+SUBMENU_ARROW,y);

  /* line 9 */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  if (is_print) {
    Text(rp,"cancel print   p",16);
  }
  else {
    Text(rp,"print page     p",16);
  }

  /* line 10 */
  y += YOFFSET;
  Move(rp,menu_offset_x+3,y);
  if (is_escex) {
    Text(rp,"hide",4);
  }
  else {
    Text(rp,"hide ESC",8);
  }
  Move(rp,menu_offset_x+SPALTE,y);
  Text(rp,"quit Aq",7);

  SetDrMd(win2->RPort,COMPLEMENT);
  mark_line_main_menu(rp,zeile,col);
  if (menu != MAIN_MENU) {
    SetDrMd(win2->RPort,JAM1);
    if (menu == SMENU_OUTFIT) {
      display_submenu_outfit();
    }
    else if (menu == SMENU_LOAD) {
      display_submenu_load();
    }
    else {
      display_submenu_resolution();
    }
    SetDrMd(win2->RPort,COMPLEMENT);
    mark_line_sub_menu(rp,menu,sub_zeile);
  }
  SetDrMd(win2->RPort,JAM1);
  SetFont(rp,normal_font);
}

static void mark_line_sub_menu(struct RastPort *rp, int menu, int zeile)
{
  int sub_w;
  long xw, yw;

  if (menu == SMENU_OUTFIT) {
    sub_w = SMENU_O_WIDTH;
  }
  else if (menu == SMENU_LOAD) {
    sub_w = SMENU_L_WIDTH;
  }
  else if (menu == SMENU_RESOLUTION) {
    sub_w = SMENU_R_WIDTH;
  }
  else {
    return; /* nie!! */
  }

  xw = current_submenu_x + 2;
  yw = current_submenu_y + (zeile-1)*YOFFSET+2;

  if (zeile != 0) {
    RectFill(rp,xw,yw,xw+sub_w-8,yw+YOFFSET-1);
  }
}

static void mark_line_main_menu(struct RastPort *rp, int zeile, int spalte)
{
  long xw, yw;

  xw = menu_offset_x+2;
  yw = menu_offset_y+(zeile-1)*YOFFSET+2;
  if (zeile != 0) {
    if (zeile == 3 || zeile == 2 || zeile == 10) {
      if (spalte == 1) {
        RectFill(rp,xw,yw,xw+SPALTE-4,yw+YOFFSET-1);
      }
      else {
        RectFill(rp,xw+SPALTE-3,yw,xw+MENU_WIDTH-8,yw+YOFFSET-1);
      }
    }
    else {
      RectFill(rp,xw,yw,xw+MENU_WIDTH-8,yw+YOFFSET-1);
    }
  }
}

static void work_with_submenu(struct RastPort *rp, int x, int y,
				int menu, int *old_sub_zeile)
{
  int sub_w, sub_h, i;
  int zeile, nr_lines;

  /** Maus innerhalb eines Submenus */
  if (menu == SMENU_OUTFIT) {
    sub_w = SMENU_O_WIDTH;
    sub_h = SMENU_O_HEIGHT;
    nr_lines = NR_SMENU_O_LINES;
  }
  else if (menu == SMENU_LOAD) {
    sub_w = SMENU_L_WIDTH;
    sub_h = SMENU_L_HEIGHT;
    nr_lines = NR_SMENU_L_LINES;
  }
  else if (menu == SMENU_RESOLUTION) {
    sub_w = SMENU_R_WIDTH;
    sub_h = SMENU_R_HEIGHT;
    nr_lines = show_state.menu_res_lines;

  }
  else {
    *old_sub_zeile = 0;
    return;	/* nie! */
  }

  i = y - current_submenu_y-2;
  if (i < 0 || x < current_submenu_x+2 || y < current_submenu_y+2
	|| x > current_submenu_x+sub_w-2 || y > current_submenu_y+sub_h-2) {
    zeile = 0;
  }
  else {
    zeile = 1 + i / YOFFSET;
  }
  if (zeile > nr_lines) zeile = 0;

  if (zeile != *old_sub_zeile) {
    mark_line_sub_menu(rp,menu,*old_sub_zeile);
    mark_line_sub_menu(rp,menu,zeile);
    *old_sub_zeile = zeile;
  }
}

static void work_with_menu(struct RastPort *rp,int x,int y,int *menu,
			int *old_zeile,int *old_col,int *old_sub_zeile)
{
  int zeile, col, i;
  int sub_w, sub_h;

  i = y - menu_offset_y-2;
  if (i < 0 || x < menu_offset_x+2 || y < menu_offset_y+2
	|| x > menu_offset_x+MENU_WIDTH-2 || y > menu_offset_y+MENU_HEIGHT-2) {
    zeile = 0;
  }
  else {
    zeile = 1 + i / YOFFSET;
  }
  if (zeile > NR_MENU_LINES) zeile = 0;

  col = (x-menu_offset_x-2 < SPALTE) ? 1 : 2;
  if (zeile != 2 && zeile != 3 && zeile != 10) col = 0;
  if ((zeile == SMENU_O_START_LINE || zeile == SMENU_L_START_LINE ||
	zeile == SMENU_R_START_LINE) && x-menu_offset_x > SUBMENU_SPALTE) {
    col = 3;
  }

  /** Maus innerhalb eines Submenus */
  if (*menu == SMENU_OUTFIT) {
    sub_w = SMENU_O_WIDTH;
    sub_h = SMENU_O_HEIGHT;
  }
  else if (*menu == SMENU_LOAD) {
    sub_w = SMENU_L_WIDTH;
    sub_h = SMENU_L_HEIGHT;
  }
  else if (*menu == SMENU_RESOLUTION) {
    sub_w = SMENU_R_WIDTH;
    sub_h = SMENU_R_HEIGHT;
  }

  if (*menu != MAIN_MENU && x >= current_submenu_x && 
	x < current_submenu_x+sub_w-2 && y >= current_submenu_y+2 &&
	y < current_submenu_y+sub_h-2) {
    work_with_submenu(rp,x,y,*menu,old_sub_zeile);
  }
  else {
    if (*menu != MAIN_MENU) {
      clear_current_submenu(*menu);
      *menu = MAIN_MENU;
      *old_sub_zeile = 0;
    }

    if (zeile == *old_zeile && col == *old_col) {
      return;		/* keine Anderung --> weg */
    }

    /* loeschen */
    mark_line_main_menu(rp,*old_zeile,*old_col);

    if (col == 3) {
      mark_line_main_menu(rp,zeile,col);		/* setzen */
      SetDrMd(win2->RPort,JAM1);
      if (zeile == SMENU_O_START_LINE) {
        *menu = SMENU_OUTFIT;
        display_submenu_outfit();
      }
      else if (zeile == SMENU_L_START_LINE) {
        *menu = SMENU_LOAD;
        display_submenu_load();
      }
      else {
        *menu = SMENU_RESOLUTION;
        display_submenu_resolution();
      }
      SetDrMd(win2->RPort,COMPLEMENT);
      *old_col = 3;
      *old_zeile = zeile;
      work_with_submenu(rp,x,y,*menu,old_sub_zeile);
    }
    else {
      mark_line_main_menu(rp,zeile,col);
      *old_col = col;
      *old_zeile = zeile;
    }
  }	/* else innerhalb eines Submenus */
  return;
}


/* Auswertung */
static long do_menu(int menu,int zeile,int col,int sub_zeile,int mx,int my)
{
  register long ret = 5L;

  switch (zeile) {
    case 1: AboutWinUp();
	    ret = 5L;
    	    break;
    case 2: if (is_print) {
   	      ret = 6L;
   	    }
   	    else {
	      if (col == 1) {
	        ret = 1L;
    	      }
    	      else {
    	        ret = 2L;
    	      }
    	    }
    	    break;
    case 3: if (is_print) {
   	      ret = 6L;
   	    }
   	    else {
	      if (col == 1) {
	        ret = -1L;
    	      }
    	      else {
    	        ret = -2L;
    	      }
    	    }
    	    break;
    case 4: if (is_dvif) {
	      show_full_page(FALSE);
	      ret = 5L;
	    }
	    else {			/* noch kein DVI-File geladen */
	      ret = 7L;
	    }
    	    break;
    case 5: clear_counter(0);
	    ret = 5L;
    	    break;
    case 6: switch (sub_zeile) {
    	      case 0:
    	      case 1:
		if (is_show) {
		  show_full_page(FALSE);  /* show-Modus ausschalten */
		}
		change_resolution();
		break;
	      case 2:
	        if (!is_show) {
	          toggle_scrollbar(FALSE);
	        }
	        break;
	      case 3:
	        show_col_request();
	        break;
	      case 4:
	        write_config_file();
	        break;
	    }
	    ret = 5L;
    	    break;
    case 7: if (is_print) {
	      ret = 6L;
    	    }
    	    else {
	      switch (sub_zeile) {
	        case 0:
	        case 1:
	          if (is_dvif) {
	            OpenNewDVI(filename, FALSE);
	            ret = 3L;	    /* neues File, Name nicht geaendert. */
	          }
	          else {
	            ret = 7L;
	          }
    	          break;
		case 2:
		  ret = LoadFileReq();
		  break;
	      }
	    }
	    break;
    case 8: if (is_print) {
	      ret = 6L;
    	    }
    	    else {
    	      int new_res;

    	      if (sub_zeile <= show_state.menu_res_lines) {
    	        if (sub_zeile == 0) {
    	          new_res = show_state.mres[0];
    	        }
    	        else {
    	          new_res = show_state.mres[sub_zeile-1];
    	        }
	      }
	      if (new_res != resolution) {
	        resolution = new_res;
	        hconvresolution = resolution;
	        vconvresolution = resolution;
    	        if (is_dvif) {
                  OpenNewDVI(filename, TRUE);
                  set_chres;
                  if (is_show) {
                    show_full_page(TRUE); /* full-page modus off (no_refresh=TRUE) */
                  }
                  ret = 3L;		  /* neues File, Name nicht geaendert. */
                }
		set_checked_os_menu();
              }
	    }
   	    break;
    case 9:  
            if (is_dvif) {
	      printing();
	    }
	    else {
	      Message(MSG_NO_DVI_FILE);
	      beep();
	    }
	    ret = 5L;
    	    break;
    case 10: if (col == 1) {
	       ScreenToBack(screen);		/* Screen weg!! */
	       make_old_active();
	       ret = 5L;
    	     }
    	     else {
	       if (real_prog_end()) {
	         Enable_Abort = 0;	    /* am Ende nicht noch ein ^C */
	         ret = 10L;
	       }
	       else {
	         ret = 5L;
	       }
    	     }
    	     break;
    default: ret = 5L;
    	     break;
  }
  if (ret == 6L) {
    Message(MSG_NOT_WHILE_PRINTING);
    ret = 5L;
  }
  else {
    if (ret == 7L) {
      Message(MSG_NO_DVI_FILE);
      beep();
      ret = 5L;
    }
  }
  return (ret);
}

static void init_bmap(struct BitMap *bm, struct RastPort *rp, long width, long height)
{
  int i;

  for (i=0; i<8; i++) {		/* wichtig fuer free_bmap() */
    bm->Planes[i] = NULL;
  }

  if (is_col4) {
    InitBitMap(bm,2L,width,height);
    bm->Planes[0] = AllocRaster(width,height);
    bm->Planes[1] = AllocRaster(width,height);
  }
  else {
    InitBitMap(bm,1L,width,height);
    bm->Planes[0] = AllocRaster(width,height);
  }
  if (bm->Planes[0] == NULL || (is_col4 && bm->Planes[1] == NULL)) { 
    Fatal(10,MSG_NO_CHIPMEM);
  }
  BltClear((char *)bm->Planes[0],(width*height)/8,1L);
  if (is_col4) {
    BltClear((char *)bm->Planes[1],(width*height)/8,1L);
  }
  InitRastPort(rp);
  rp->BitMap = bm;
}

static void free_bmap(struct BitMap *bm, long width, long height)
{
  int i;
  
  for (i=0; i<8; i++) {
    if (bm->Planes[i] != NULL) {
      FreeRaster(bm->Planes[i],width,height);
      bm->Planes[i] = NULL;
    }
  }
}




/****************************************************************************/
/** Schnittstelle: **/

void SetDosMenu(void)
{
  SetMenuStrip(win2, &DosMenu[0]);
}

void ClearDosMenu(void)
{
  ClearMenuStrip(win2);
}


/* Speicher freigeben */
void free_menu(void)
{
  free_os_menu();
  if (!is_osmenu || is_midmenu) {
    free_bmap(&menu_save_bm,    MENU_WIDTH,    MENU_HEIGHT);
    free_bmap(&smenu_o_save_bm, SMENU_O_WIDTH, SMENU_O_HEIGHT);
    free_bmap(&smenu_l_save_bm, SMENU_L_WIDTH, SMENU_L_HEIGHT);
    free_bmap(&smenu_r_save_bm, SMENU_R_WIDTH, SMENU_R_HEIGHT);
  }
}

/* Speicher allocieren */
void init_menu(void)
{
  if (!is_osmenu || is_midmenu) {
    normal_font = font8;

    if (is_bmenu && font11 != NULL) {
      txt_height = 11;
      txt_width  = 8;
      menu_font  = font11;
    }
    else {
      txt_height = 8;
      txt_width  = 8;
      menu_font  = font8;
      unset_bmenu;
    }

    menu_width	 = CALC_MENU_WIDTH;
    menu_height	 = CALC_MENU_HEIGHT;
    smenu_o_width	 = CALC_SMENU_O_WIDTH;
    smenu_o_height = CALC_SMENU_O_HEIGHT;
    smenu_l_width	 = CALC_SMENU_L_WIDTH;
    smenu_l_height = CALC_SMENU_L_HEIGHT;
    smenu_r_width	 = CALC_SMENU_R_WIDTH;
    smenu_r_height = CALC_SMENU_R_HEIGHT;

    init_bmap(&menu_save_bm,    &menu_save_rp,    MENU_WIDTH,    MENU_HEIGHT);
    init_bmap(&smenu_o_save_bm, &smenu_o_save_rp, SMENU_O_WIDTH, SMENU_O_HEIGHT);
    init_bmap(&smenu_l_save_bm, &smenu_l_save_rp, SMENU_L_WIDTH, SMENU_L_HEIGHT);
    init_bmap(&smenu_r_save_bm, &smenu_r_save_rp, SMENU_R_WIDTH, SMENU_R_HEIGHT);
  }
}


/* Menu anzeigen */
long show_menu(UWORD Code, WORD MouseX, WORD MouseY)
{
  register struct RastPort *rp;
  register struct IntuiMessage *msg2;
  ULONG msg_class;
  int x, y, menu = 0, zeile = 0, col = 0, sub_zeile = 0;
  long ret;
  int middle_menu;
  
  if (win2 == NULL) return 5;
  
  rp = win2->RPort;
  SetDrMd(rp, JAM1);

  menu_offset_x = x = MouseX;
  menu_offset_y = y = MouseY;
  
  middle_menu = (Code == MIDDLEDOWN);

  if (is_osmenu && !middle_menu) {
    return 5;		/* no menu */
  }

  menu = MAIN_MENU;

  if (is_imenu) {
    if (last_zeile != 0) {
      menu_offset_y -= (last_zeile - 1) * YOFFSET;
      zeile = last_zeile;
      if (last_zeile == SMENU_O_START_LINE
		|| last_zeile == SMENU_L_START_LINE
		|| last_zeile == SMENU_R_START_LINE) {
        menu_offset_x -= SUBMENU_SPALTE;
        sub_zeile = last_sub_zeile;
        if (last_sub_zeile > 0) {
          menu_offset_y -= (last_sub_zeile - 1) * YOFFSET;
          if (last_zeile == SMENU_O_START_LINE)	   menu = SMENU_OUTFIT;
          else if (last_zeile == SMENU_L_START_LINE) menu = SMENU_LOAD;
          else if (last_zeile == SMENU_R_START_LINE) menu = SMENU_RESOLUTION;
          //col = 3;
        }
      }
      else {
        if ((last_zeile == 2 || last_zeile == 3) && last_col == 2) {
          menu_offset_x -= SPALTE;
          //col = 2;
        }
      }
      /* die Grenzen werden in display_menu korrigiert */
    }
    menu_offset_x -= 15;
    menu_offset_y -= 7;
  }

  last_zeile = last_sub_zeile = col = 0;

  current_submenu_x = 0;	/* init */
  current_submenu_y = 0;
  
  /* show menu/sub menu and mark the line */
  display_menu(menu,zeile,col,sub_zeile);

  SetDrMd(rp,COMPLEMENT);
  work_with_menu(rp,x,y,&menu,&zeile,&col,&sub_zeile);

  add_mmove;
  MyModifyIDCMP(MOUSEMOVE, 0L);

  do {
    WaitPort(win2->UserPort);
    while ( !((middle_menu && Code == MIDDLEUP) || (!middle_menu && Code == MENUUP)) && 
	   (msg2 = (struct IntuiMessage *)GetMsg(win2->UserPort)) != NULL) {
      msg_class = msg2->Class;
      Code = msg2->Code;
      x = msg2->MouseX;
      y = msg2->MouseY;
      ReplyMsg(&(msg2->ExecMessage));
      if (msg_class == MOUSEMOVE) {
        work_with_menu(rp,x,y,&menu,&zeile,&col,&sub_zeile);
      }
    }
  } while (!((middle_menu && Code == MIDDLEUP) || (!middle_menu && Code == MENUUP)));

  sub_mmove;
  if (!is_mmove) {
    MyModifyIDCMP(0L, MOUSEMOVE);
  }

  if (menu != 0) {
    clear_current_submenu(menu);
  }
  ClipBlit(&menu_save_rp,0L,0L,rp,(long)menu_offset_x,
	(long)menu_offset_y,(long)MENU_WIDTH,(long)MENU_HEIGHT,(long)192);

  SetDrMd(rp,JAM1);

  /* save the menu */
  if (zeile > 0 && zeile <= NR_MENU_LINES) {
    last_zeile = zeile;
    if (zeile == SMENU_O_START_LINE) {
      if (sub_zeile > 0 && sub_zeile <= NR_SMENU_O_LINES) {
        last_sub_zeile = sub_zeile;
      }
    }
    else {
      if (zeile == SMENU_L_START_LINE) {
        if (sub_zeile > 0 && sub_zeile <= NR_SMENU_L_LINES) {
          last_sub_zeile = sub_zeile;
        }
      }
      else {
        if (zeile == SMENU_R_START_LINE) {
          if (sub_zeile > 0 && sub_zeile <= show_state.menu_res_lines) {
            last_sub_zeile = sub_zeile;
          }
        }
        else {
          if (zeile == 2) {
            last_col = col;
          }
          else {
            if (zeile == 3) {
              last_col = col;
            }
          }
        }
      }
    }
  }

  ret = do_menu(menu,zeile,col,sub_zeile,x,y);
  return ((long)ret);
}


/****************************************************************************************/
/****************************************************************************************/
/****************************************************************************************/
/****************************************************************************************/


/************* OS MENU ******************/


static int os_menu_ready = FALSE;


struct MenuItem *MyItemAddress(unsigned long menuNumber)
{
  return ItemAddress(&DosMenu[0], menuNumber);
}


void init_os_menu(void)
{
  MyLayoutMenu();
  os_menu_ready = TRUE;
  set_checked_os_menu();
}


void free_os_menu(void)
{
  os_menu_ready = FALSE;
}


void set_checked_os_menu(void)
{
  short nr_res = show_state.menu_res_lines;
  short i;
  register struct Menu *men;
  

  if (!os_menu_ready) return;	// Menu nicht initialisiert!


  men = &(DosMenu[0]);

  if (win2 != NULL) {
    ClearDosMenu();	/* !!!!!! */
  }

  /* Das ganze CHECKED koennte man sich sparen. Nur wenn die Funktionen per Tastatur */
  /* aufgerufen wird muss das gemacht werden. Also mach ma´s immer. :-()	     */

  for (i=0; i<nr_res; i++) {
    if (show_state.mres[i] == resolution) {
      FindMenuEntry(men, 3, i, NOSUB)->Flags |= CHECKED;
    }
    else {
      FindMenuEntry(men, 3, i, NOSUB)->Flags &= ~CHECKED;
    }
  }

  if (is_lace)  FindMenuEntry(men, 1, 2, NOSUB)->Flags |= CHECKED;	/* lace */
  else 		FindMenuEntry(men, 1, 2, NOSUB)->Flags &= (~CHECKED);	/* lace */

  if (is_gadg)  FindMenuEntry(men, 1, 3, NOSUB)->Flags |= CHECKED;	/* scrollbar */
  else 		FindMenuEntry(men, 1, 3, NOSUB)->Flags &= (~CHECKED);	/* scrollbar */

  if (is_show)  {
    FindMenuEntry(men, 1, 4, NOSUB)->Flags |= CHECKED;			/* full page */
    MenuAus(men, 1, 3, NOSUB); 						/* scrollbar */
  }
  else {
    FindMenuEntry(men, 1, 4, NOSUB)->Flags &= (~CHECKED);		/* full page */
    MenuAn(men, 1, 3, NOSUB);						/* scrollbar */
  }

  if (is_messwin) FindMenuEntry(men, 1, 5, NOSUB)->Flags |= CHECKED;	/* mess-win */
  else		  FindMenuEntry(men, 1, 5, NOSUB)->Flags &= (~CHECKED);	/* mess-win */

  if (is_dotbord) FindMenuEntry(men, 1, 6, NOSUB)->Flags |= CHECKED;	/* border line */
  else 		  FindMenuEntry(men, 1, 6, NOSUB)->Flags &= (~CHECKED);	/* border line */

  if (is_col4)    FindMenuEntry(men, 1, 9, NOSUB)->Flags |= CHECKED;	/* use 4 colors */
  else 		  FindMenuEntry(men, 1, 9, NOSUB)->Flags &= (~CHECKED);	/* use 4 colors */

  //if (is_pscro)   FindMenuEntry(men, 1, 10, NOSUB)->Flags |= CHECKED;	/* page scroll */
  //else 	    FindMenuEntry(men, 1, 10, NOSUB)->Flags &= (~CHECKED);	/* page scroll */

  if (is_usephy)  FindMenuEntry(men, 2, 12, NOSUB)->Flags |= CHECKED;	/* use phy */
  else 		  FindMenuEntry(men, 2, 12, NOSUB)->Flags &= (~CHECKED);/* use phy */

  if (is_autoag)  FindMenuEntry(men, 0, 4, NOSUB)->Flags |= CHECKED;	/* auto again */
  else 		  FindMenuEntry(men, 0, 4, NOSUB)->Flags &= (~CHECKED);	/* auto again */


  switch (show_state.whunit) {
    case 0:								/* inch */
	FindMenuEntry(men, 1, 11, 0)->Flags |= CHECKED;
	FindMenuEntry(men, 1, 11, 1)->Flags &= (~CHECKED);
	FindMenuEntry(men, 1, 11, 2)->Flags &= (~CHECKED);
	break;
    case 1:								/* cm */
	FindMenuEntry(men, 1, 11, 1)->Flags |= CHECKED;
	FindMenuEntry(men, 1, 11, 0)->Flags &= (~CHECKED);
	FindMenuEntry(men, 1, 11, 2)->Flags &= (~CHECKED);
	break;
    case 2:								/* pt */
	FindMenuEntry(men, 1, 11, 2)->Flags |= CHECKED;
	FindMenuEntry(men, 1, 11, 0)->Flags &= (~CHECKED);
	FindMenuEntry(men, 1, 11, 1)->Flags &= (~CHECKED);
	break;
  }

  if (is_ownscr && is_myscr) {
    MenuAn(men, 1, 2, NOSUB);		/* lace */
    MenuAn(men, 1, 9, NOSUB);		/* 4 color */
    MenuAn(men, 1, 13, NOSUB);		/* clone wb color */
    MenuAn(men, 1, 12, NOSUB);		/* color */
  }
  else {
    MenuAus(men, 1, 2, NOSUB);		/* lace */
    MenuAus(men, 1, 9, NOSUB);		/* 4 color */
    MenuAus(men, 1, 13, NOSUB);		/* clone wb color */
    MenuAus(men, 1, 12, NOSUB);		/* color (nicht die Farbe eines fremden Screens aendern) */
  }

  if (!is_os2) {
    MenuAus(men, 0, 7, 1);	/* Execute command... */
    MenuAus(men, 0, 7, 2);	/* TeX script */
    MenuAus(men, 0, 7, 3);	/* ARexx TeX Shell */
    MenuAus(men, 0, 7, 4);	/* Set ENV:TEXFORMAT */
    MenuAus(men, 0, 7, 5);	/* SpecialHost */
    MenuAus(men, 1, 14, NOSUB);	/* set screen size */
  }

  if (!is_print) {
    MenuAn(men, 0, 2, NOSUB);						/* load again */
    MenuAn(men, 0, 3, NOSUB);						/* load new */
    //MenuAn(men, 1, 10, NOSUB);					/* page scroll */
    MenuAn(men, 2, NOITEM, NOSUB);
    MenuAn(men, 3, NOITEM, NOSUB);
    // MenItem[MEN_PRINT].ItemFill = (APTR)&MenItem_Text[START_1+8];
  }
  else {
    MenuAus(men, 0, 2, NOSUB);						/* load again */
    MenuAus(men, 0, 3, NOSUB);						/* load new */
    //MenuAus(men, 1, 10, NOSUB);					/* page scroll */
    MenuAus(men, 2, NOITEM, NOSUB);
    MenuAus(men, 3, NOITEM, NOSUB);
    // MenItem[MEN_PRINT].ItemFill = (APTR)&MenChars_Text[13];
  }
  if (is_dvif) {
    if (!is_print) {
      MenuAn(men, 0, 2, NOSUB);						/* load again */
      MenuAn(men, 0, 9, NOSUB);						/* print page */
      //MenuAn(men, 1, 10, NOSUB);					/* page scroll */
      MenuAn(men, 2, NOITEM, NOSUB);
    }
    MenuAn(men, 1, 4, NOSUB);						/* full page */
    MenuAn(men, 1, 5, NOSUB);						/* mess win */
    MenuAn(men, 1, 6, NOSUB);						/* border line */
  }
  else {
    MenuAus(men, 0, 2, NOSUB);						/* load again */
    MenuAus(men, 0, 9, NOSUB);						/* print page */
    MenuAus(men, 1, 5, NOSUB);						/* mess win */
    MenuAus(men, 1, 6, NOSUB);						/* border line */
    //MenuAus(men, 1, 10, NOSUB);					/* page scroll */
    MenuAus(men, 1, 4, NOSUB);						/* full page */
    MenuAus(men, 2, NOITEM, NOSUB);
  }

#if defined(REQ_LIBRARY)
  if (ReqBase == NULL) {
    MenuAus(men, 0, 3, NOSUB);			/* load new */
    MenuAus(men, 1, 12, NOSUB);			/* color */
  }
#endif

  if (win2 != NULL) {
    SetDosMenu();	/* !!!!!! */
  }
}


static struct TagItem system_tags[] = {
			  { SYS_Input,	NULL	},
			  { SYS_Output,	NULL	},
			  { SYS_Asynch,	NULL	},
                          { TAG_DONE,	0L	},
  };




long work_with_os_menu(UBYTE MenuNum, UBYTE ItemNum, UBYTE SubNum)
{
  long ex = KOMM + 5L;
  long new_res;
  long page;

  /* die Abfrage nach is_print kann gespart werden, */
  /* da die Menues alle nicht anwaehlbar sind.      */
  /* Leider doch nicht mehr, da das Menue nun auch  */
  /* ueber ARexx angesprochen werden kann!	    */
  /* Deshalb nun die Abfrage auf ITEMENABLED!	    */
  /* MENUENABLED lass ich einfach ausser acht!!	    */
  
  if (!FindMenuEntry(&(DosMenu[0]), MenuNum, ItemNum, SubNum)->Flags & ITEMENABLED) {
    return ex;
  }

  switch (MenuNum) {
    case 0:
      switch (ItemNum) {
	case 0:				/* About */
	  AboutWinUp();
	  break;
	case 2:				/* Open */
	    if (is_dvif) {
	      OpenNewDVI(filename, FALSE);
	      ex = KOMM + 3L;	    /* neues File, Name nicht geaendert. */
	    }
	    else {
	      Message(MSG_NO_DVI_FILE);
	      beep();
	    }
	  break;
	case 3:				/* Open new */
 	  if (!is_print) {
	    ex = KOMM + LoadFileReq();
	  }
	  break;
	case 4:				/* auto load again */
          if (is_autoag ^ ((FindMenuEntry(&(DosMenu[0]), 0, 4, NOSUB)->Flags & CHECKED) != 0)) {
	    ToggleAutoAgain();
	  }
	  break;
	case 5:				/* save as IFF file */
	  if (is_dvif) {
	    m_string[0] = '\0';
	    if (MyGetString(GetTeXString(MSG_FILENAME), m_string)) {
              SavePageIFF(m_string);
            }
	  }
	  else {			/* noch kein DVI-File geladen */
	    ex = KOMM + 7L;
	  }
	  break;
	case 7:				/* shell commands */
	  switch (SubNum) {
	    case 0:						/* newcli */
    	      make_newcli(screen);
    	      break;
	    case 1:						/* execute command */
	      if (is_os2) {
	        char buf[200];
	        *buf = '\0';
	        if (MyGetString(GetTeXString(MSG_ENTER_COMMAND), buf)) {
	          if (start_command(GetTeXString(MSG_EXECUTE_COMMAND), buf, NULL) != 0) {
	            Warning(MSG_CANT_EXECUTE_COMMAND);
	          }
	        }
	      }
	      break;
	    case 2:
	      execute_script(show_state.command, FALSE);	/* run command */
	      break;
    	    case 3:						/* TeX-Server */
    	      if (is_os2) {
    	        char buf[MAXPUBSCREENNAME+1];
    	        struct Screen *pscr = NULL;
    	        int loop = TRUE;
    	        
    	        strcpy(buf, GetCurrentPubScr());
    	        while (loop) {
    	          if (MyGetString(GetTeXString(MSG_USE_WHICH_PUBSCR), buf)) {
    	            if ((pscr = LockPubScreen(buf)) == NULL) {
    	              int k = MySimpleRequest(3, NULL, NULL, "New", NULL, 
			  GetTeXString(MSG_DONT_FIND_PUBSCR_USE_WB), buf);
		      if (k == 0) {
		        return ex;		/* CANCEL */
		      }
		      else if (k == 1) {	/* OK */
			loop = FALSE;
			strcpy(buf, "Workbench");
			pscr = LockPubScreen(buf);
		      }
		      else {			/* NEW */
		        ;
		      }
    	            }
    	            else {
    	              loop = FALSE;	/* PubScr gefunden */
    	            }
    	          }
    	        }
    	        /* (void)SetVar("TeXServer-PubScr-Name", buf, -1,GVF_GLOBAL_ONLY); */
    	        sprintf(m_string, "%s %s", show_state.arexxstart, buf);
		if (start_command(GetTeXString(MSG_SHOWDVI_TEX_SHELL), m_string, buf) != 0) {
		  Warning(MSG_CANT_START, show_state.arexxstart);
		}
	  	if (pscr != NULL) {
	  	  UnlockPubScreen(NULL, pscr);
	  	}
    	      }
    	      break;
	    case 4:			/* change format */
	      if (is_os2) {
	        ChangeFormatFile();
	      }
	      break;
    	    case 5:			/* call SpecialHost */
    	      if (is_os2) {
    	        if (start_command(GetTeXString(MSG_START_SPECIALHOST), "SpecialHost", NULL) != 0) {
	  	  Warning(MSG_CANT_START, "SpecialHost");
	  	}
    	      }
    	      break;
	    default:
	      Warning(MSG_UNKNOWN_SUBITEM, (int)MenuNum, (int)ItemNum, (int)SubNum);
	  }
	  break;
	case 9:				/* Print page */
	  printing();
	  break;
	case 11:			/* WB to front */
	  (void)WBenchToFront();
	  make_old_active();
	  break;
	case 12:			/* Hide */
	  ScreenToBack(screen);
	  make_old_active();
	  break;
	case 13:			/* save config */
	  write_config_file();
	  break;
	case 15:			/* Quit */
	  if (real_prog_end()) {
	    Enable_Abort = 0;	    /* am Ende nicht noch ein ^C */
	    ex = KOMM + 10L;
	  }
	  break;
	default:
	  Warning(MSG_UNKNOWN_SUBMENU, (int)MenuNum, (int)ItemNum, (int)SubNum);
      }
      break;
    case 1:
      switch (ItemNum) {
        case 0:				/* copy */
	  if (is_dvif) {
            SavePageIFF("CLIP");
	  }
	  else {			/* noch kein DVI-File geladen */
	    ex = KOMM + 7L;
	  }
          break;
	case 2:				/* lace */
	  if (is_lace ^ ((FindMenuEntry(&(DosMenu[0]), 1, 2, NOSUB)->Flags & CHECKED) != 0)) {
	    if (is_show) {
	      show_full_page(FALSE);  	/* show-Modus ausschalten */
	    }
	    change_resolution();
	  }
	  break;
	case 3:				/* scrollbar */
	  if (is_gadg ^ ((FindMenuEntry(&(DosMenu[0]), 1, 3, NOSUB)->Flags & CHECKED) != 0)) {
	    if (!is_show) {
	      toggle_scrollbar(FALSE);
	    }
	  }
	  break;
	case 4:				/* full page */
	  if (is_show ^ ((FindMenuEntry(&(DosMenu[0]), 1, 4, NOSUB)->Flags & CHECKED) != 0)) {
	    if (is_dvif) {
	      show_full_page(FALSE);
	      ex = KOMM + 5L;
	    }
	    else {			/* noch kein DVI-File geladen */
	      ex = KOMM + 7L;
	    }
	  }
	  break;
	case 5:				/* mess window */
	  if (is_messwin ^ ((FindMenuEntry(&(DosMenu[0]), 1, 5, NOSUB)->Flags & CHECKED) != 0)) {
	    ToggleMessWin(-1, -1);
	  }
	  break;
	case 6:				/* dotted border line */
	  if (is_dotbord ^ ((FindMenuEntry(&(DosMenu[0]), 1, 6, NOSUB)->Flags & CHECKED) != 0)) {
  	    if (is_dvif) {
	      DrawDottedBorder(TRUE, FALSE);	/* toggle == TRUE, no_refresh == FALSE */
	    }
	    else {
	      ex = KOMM + 7L;
	    }
	  }
	  break;
	case 8:				/* set margin point */
	  SetupMargin();
	  break;
	case 9:				/* 4 colors -- 2 colors */
	  if (is_col4 ^ ((FindMenuEntry(&(DosMenu[0]), 1, 9, NOSUB)->Flags & CHECKED) != 0)) {
	    ToggleColorDepth();
	  }
	  break;
	case 11:				/* UNIT */
	  switch (SubNum) {
	    case 0:
	      set_unit_in;
	      break;
	    case 1:
	      set_unit_cm;
	      break;
	    case 2:
	      set_unit_pt;
	      break;
	    default:
	      Warning(MSG_UNKNOWN_SUBITEM, (int)MenuNum, (int)ItemNum, (int)SubNum);
	  }
	  SetUpMessWin(FALSE);		/* no delta */
	  break;
	case 12:			/* color */
	  show_col_request();
	  break;
	case 13:			/* clone wb color */
	  { int old = is_clwbcol;
	    set_clwbcol;
	    init_screen_colors();
	    if (!old) unset_clwbcol;
	    set_screen_colors();
	  }
	  break;
	case 14:			/* set screen size */
	  if (is_os2) {
	    TogglePrefWin();
	  }
	  break;
	default:
	  Warning(MSG_UNKNOWN_SUBMENU, (int)MenuNum, (int)ItemNum, (int)SubNum);
      }
      break;
    case 2:
      if (ItemNum == 13 || ItemNum == 14 || ItemNum == 15 ||ItemNum == 16) {
	set_tusephy;
      }
      switch (ItemNum) {
        case 0:				/* search string */
          ex = KOMM + StartSearch(SO_OpenSearchWin);
          break;
	case 2:				/* prev page */
	case 13:
	  ex = KOMM - 1L;
	  break;
	case 3:				/* next page */
	case 14:
	  ex = KOMM + 1L;
	  break;
	case 4:				/* first page */
	case 15:
	  ex = KOMM - 2L;
	  break;
	case 5:				/* last page */
	case 16:
	  ex = KOMM + 2L;
	  break;
	case 8:				/* jump to page... */
	  if (is_pscro) {
#if 0
	    blatt_ok_gad(&page);
	    if (page != 0L) {
	      ex = page;
	    }
#endif
	  }
	  else {
	    page = clear_counter(0);
	    if (page != -1) {
	      ex = page;
	      if (ex == 0) ex = -1;	/* hack for page number 0 (intui_message) */
	    }
	  }
	  break;
	case 9:				/* clear page counter */
	  (void)clear_counter(0);
	  break;
	case 12:			/* use physical numbering */
          if (is_usephy ^ ((FindMenuEntry(&(DosMenu[0]), 2, 12, NOSUB)->Flags & CHECKED) != 0)) {
            toggle_usephy;
	    write_status();
	    Set_PgGadPageCur();
	  }
	  break;
	default:
	  Warning(MSG_UNKNOWN_SUBMENU, (int)MenuNum, (int)ItemNum, (int)SubNum);
      }
      break;
    case 3:
      new_res = show_state.mres[ItemNum];
      if (new_res != resolution) {
	resolution = new_res;
	hconvresolution = resolution;
	vconvresolution = resolution;
	if (is_dvif) {
	  OpenNewDVI(filename, TRUE);
	  set_chres;
	  if (is_show) {
	    show_full_page(TRUE); /* full-page modus off (no_refresh=TRUE) */
	  }
	  ex = KOMM +3L;		  /* neues File, Name nicht geaendert. */
	}
	set_checked_os_menu();
      }
      break;
    default:
	Warning(MSG_UNKNOWN_MENU, (int)MenuNum, (int)ItemNum, (int)SubNum);
  }
  
  if (ex == KOMM + 7L) {
    Message(MSG_NO_DVI_FILE);
    beep();
    ex = KOMM + 5L;
  }

  return ex;
}



void work_with_os_help_menu(UBYTE MenuNum, UBYTE ItemNum, UBYTE SubNum)
{
  char *ptr, line[128], pattern[40];
  char *buffer;
  int len, found;
  FILE *fp;

  fp = OpenConfigFile("ShowDVI.help", MODE_READ);

  if (fp == NULL) {
    Warning(MSG_CANT_OPEN_HELP_FILE, "ShowDVI.help");
  }
  else {
    /* so nun auf die Suche nach dem Menu-Eintrag */
    sprintf(pattern, "#menu (%d, %d, %d)", (int)MenuNum, (int)ItemNum, (int)SubNum);
    len = strlen(pattern);

    /* suche den Anfang der Hilfe... */
    do {
      ptr = fgets(line, 127, fp);
      found = (strncmp(line, pattern, len) == 0);
    } while (ptr != NULL && !found);
    
    if (found) {
      /* Anfang gefunden, nun muss der Text zusammengesetzt und ausgegeben werden */
      buffer = xmalloc(4000*sizeof(char));
      *buffer = '\0';
      line[127] = '\0';
      do {
        ptr = fgets(line, 127, fp);
        if (ptr == NULL || *ptr == '#') {
          found = FALSE;
        }
        else {
          strcat(buffer, line);
        }
      } while (found);
      
      ptr = strrchr(&(buffer[0]), '\n');
      if (ptr != NULL) *ptr = '\0';	/* letztes Return kommt weg */

      if (MenuNum == 3 && ItemNum != NOITEM) { /* resolution Menu */
        if (ItemNum < show_state.menu_res_lines) {
          MySimpleRequest(1, NULL, NULL, NULL, GetTeXString(MSG_SHOWDVI_MENU_HELP), buffer, (long)show_state.mres[ItemNum]);
        }
      }
      else {
        if (MenuNum == 0 && ItemNum == 6) {
          switch (SubNum) {
            case 2:  MySimpleRequest(1, NULL, NULL, NULL, GetTeXString(MSG_SHOWDVI_MENU_HELP), buffer, show_state.command, GetCurrentPubScr());
		     break;
	    case 3:  MySimpleRequest(1, NULL, NULL, NULL, GetTeXString(MSG_SHOWDVI_MENU_HELP), buffer,
			show_state.arexxstart, GetCurrentPubScr());
		     break;
	    default: MySimpleRequest(1, NULL, NULL, NULL, GetTeXString(MSG_SHOWDVI_MENU_HELP), buffer);
		     break;
          }
        }
        else {
          MySimpleRequest(1, NULL, NULL, NULL, GetTeXString(MSG_SHOWDVI_MENU_HELP), buffer);
        }
      }
      xfree(buffer);
    }
    else {
      Warning(MSG_NO_HELP_FOR_MENU, (int)MenuNum, (int)ItemNum, (int)SubNum);
    }
    fclose(fp);
  }
  
  set_checked_os_menu();	/* das muss sein nach einer Help-Msg.. */
}



static struct MenuItem *FindMenuEntry(struct Menu *Menu, short menunum, short itemnum, short subnum)
{
  int i;
  struct Menu *men;
  struct MenuItem *item, *sub, *ret;
  int reason = 3;
  
  for (men = Menu, i = 0; men != NULL && i < menunum; men = men->NextMenu, i++) ;
  if (men == NULL) {
    ret = NULL;
    reason = 1;
  }
  else {
    for (item = men->FirstItem, i = 0; item != NULL && i < itemnum; item = item->NextItem, i++) ;
    if (item == NULL) {
      ret = NULL;
      reason = 2;
    }
    else {
      if (subnum == NOSUB) {
        ret = item;
      }
      else {
        for (sub = item->SubItem, i = 0; sub != NULL && i < subnum; sub = sub->NextItem, i++) ;
        ret = sub;
      }
    }
  }
  
  if (ret == NULL) {
    Fatal(29,MSG_INTERNAL_ERROR_MENU_ENTRY, menunum, itemnum, subnum, reason);
  }
  
  return ret;
}



/* MenuAnAus macht fast das selbe wie On/Off/MEnu(), nur dass es nicht ein eigenes */
/* Clear() Set() macht, sondern innerhalb eines solchen aufgerufen wird.           */
/* Dies ist erheblich schneller, falls mehr ein oder ausgeschalten werden soll.    */

static void MenuAnAus(struct Menu *Men, short menunum, short item, short sub, short on)
{
  struct Menu *m;
  int i;
  /* struct IntuiText *txt; */

  if (item == NOITEM) {
    for (m = Men, i = 0; m != NULL && i < menunum; m = m->NextMenu, i++) ;
    if (m != NULL) {
      if (on) {
        m->Flags |= MENUENABLED;
        /* printf("Enable Menu %s\n", m->MenuName); */
      }
      else {
        m->Flags &= (~MENUENABLED);
        /* printf("Disable Menu %s\n", m->MenuName); */
      }
    }
  }
  else {
    if (on) {
      FindMenuEntry(Men, menunum, item, sub)->Flags |= ITEMENABLED;
      /* txt = FindMenuEntry(Men, menunum, item, sub)->ItemFill; printf("Enable Item %s\n", txt->IText);*/
    }
    else {
      FindMenuEntry(Men, menunum, item, sub)->Flags &= (~ITEMENABLED);
      /* txt = FindMenuEntry(Men, menunum, item, sub)->ItemFill; printf("Disable Item %s\n", txt->IText);*/
    }
  }
}




static void MyLayoutMenu(void)
{
  register struct RastPort *rp;
  struct MenuItem *mi, *mih;
  int spacelen, len;

  if (screen == NULL || !is_os2) return;

  rp = &(screen->RastPort);  
  
  if (rp == NULL) return;


  spacelen = TextLength(rp, "m", 1);

  DosMenu = xmalloc(4 * sizeof(struct Menu));
  
  DosMenu[0].NextMenu = &(DosMenu[1]);
  DosMenu[0].MenuName = GetTeXString(MSG_PROJECT_MENU);
  DosMenu[0].LeftEdge = 0;
  len = TextLength(rp, DosMenu[0].MenuName, strlen(DosMenu[0].MenuName)) + spacelen;
  DosMenu[0].Width = len;

  DosMenu[1].NextMenu = &(DosMenu[2]);
  DosMenu[1].MenuName = GetTeXString(MSG_OUTFIT_MENU);
  DosMenu[1].LeftEdge = DosMenu[0].LeftEdge + DosMenu[0].Width + spacelen;
  len = TextLength(rp, DosMenu[1].MenuName, strlen(DosMenu[1].MenuName)) + spacelen;
  DosMenu[1].Width = len;

  DosMenu[2].NextMenu = &(DosMenu[3]);
  DosMenu[2].MenuName = GetTeXString(MSG_MOVE_MENU);
  DosMenu[2].LeftEdge = DosMenu[1].LeftEdge + DosMenu[1].Width + spacelen;
  len = TextLength(rp, DosMenu[2].MenuName, strlen(DosMenu[2].MenuName)) + spacelen;
  DosMenu[2].Width = len;

  DosMenu[3].NextMenu = NULL;
  DosMenu[3].MenuName = GetTeXString(MSG_RESOLUTION_MENU);
  DosMenu[3].LeftEdge = DosMenu[2].LeftEdge + DosMenu[2].Width + spacelen;
  len = TextLength(rp, DosMenu[3].MenuName, strlen(DosMenu[3].MenuName)) + spacelen;
  DosMenu[3].Width = len;
  
  DosMenu[0].Flags = DosMenu[1].Flags = DosMenu[2].Flags = DosMenu[3].Flags = MENUENABLED;
  DosMenu[0].Height = DosMenu[1].Height = DosMenu[2].Height = DosMenu[3].Height = screen->BarHeight;
  DosMenu[0].TopEdge = DosMenu[1].TopEdge = DosMenu[2].TopEdge = DosMenu[3].TopEdge = 0;
  

  mi = LayoutOneMenu(rp, ProjectMenu, MEN_1_ENTRIES, spacelen, 0);
  DosMenu[0].FirstItem = mih = mi;

  mi = LayoutOneMenu(rp, ProjectShellMenu, 6, spacelen, mi[0].Width);
  mih[7].SubItem = mi;

  mi = LayoutOneMenu(rp, OutfitMenu, MEN_2_ENTRIES, spacelen, 0);
  DosMenu[1].FirstItem = mih = mi;

  mi = LayoutOneMenu(rp, OutfitUnitMenu, 3, spacelen, mi[0].Width);
  mi[0].MutualExclude = ~1;
  mi[1].MutualExclude = ~2;
  mi[2].MutualExclude = ~3;
  mih[11].SubItem = mi;

  mi = LayoutOneMenu(rp, MoveMenu, MEN_3_ENTRIES, spacelen, 0);
  DosMenu[2].FirstItem = mi;

  /* spacelen = TextLength(rp, "8888", 1); */
  mi = LayoutOneMenu(rp, NULL, MEN_4_ENTRIES, spacelen, 0);
  DosMenu[3].FirstItem = mi;
  mi[show_state.menu_res_lines-1].NextItem = NULL;
}



static struct MenuItem *LayoutOneMenu(struct RastPort *rp, struct MenuLayout *MLay,
				int NrEntries, int spacelen, int width)
{
  /* MLay == NULL => wir sind beim Resolution Menu! */

  register struct MenuItem *mi;
  register struct IntuiText *it;
  struct IntuiText *itArr;
  int i;
  int maxlen, maxlen2, max, len, len2, lineheight, pos;

  mi = xmalloc(NrEntries * sizeof(struct MenuItem));

  lineheight = rp->Font->tf_YSize+1;

  /*
   * Achtung: Es *muss* gelten: sizeof(struct Image) < sizeof(struct IntuiText)
   */
  itArr = xmalloc(NrEntries * sizeof(struct IntuiText));

  maxlen = maxlen2 = max = 0;

  for (i=0; i<NrEntries; i++) {

    /* zuerst wird die Menue Struktur aufgebaut */

    mi[i] = DefaultMenuItem;
    if (i < NrEntries-1) {
      mi[i].NextItem = &(mi[i+1]);
    }
    else {
      mi[i].NextItem = NULL;
    }

    if (MLay == NULL) {
      /* Resolution Menu */
      char buf[8];
      sprintf(buf, "%d", i+1);
      if (i<9) {
        mi[i].Command = buf[0];
        mi[i].Flags = DEFFLAGS|MENUTOGGLE|CHECKIT|COMMSEQ;
      }
      else {
        mi[i].Command = '\0';
        mi[i].Flags = DEFFLAGS|MENUTOGGLE|CHECKIT;
      }
      mi[i].MutualExclude = ~(i+1);
    }
    else {
      mi[i].Command = MLay[i].Command;
      mi[i].Flags = MLay[i].Flags;
    }

    /* nun wird die IText Struktur aufgebaut */

    it = &(itArr[i]);
    *it = DefaultIText;

    // V39 Menue Farben setzen
    if (SDVI_DRI && SDVI_DRI->dri_Version >= 2) {
      it->FrontPen = SDVI_DRI->dri_Pens[BARDETAILPEN];
      it->BackPen  = SDVI_DRI->dri_Pens[BARBLOCKPEN];
    }

    //printf("dri vers: %d, front: %d, back: %d, det: %d, block: %d\n",
    //	SDVI_DRI->dri_Version, it->FrontPen, it->BackPen, BARDETAILPEN, BARBLOCKPEN);

    if (mi[i].Flags & CHECKIT) {
      it->LeftEdge = CHECKWIDTH;
    }
    if (MLay != NULL) {
      if (MLay[i].Special & SPECIAL_EMPTY) {
        ;	/* es wird ein Image verwendet */
      }
      else {
        it->IText = GetTeXString(MLay[i].StringNr);
        if (MLay[i].RightString || (MLay[i].Special & SPECIAL_HAS_SUB)) {
          struct IntuiText * rit = xmalloc(sizeof(struct IntuiText));
          *rit = DefaultIText;

          // V39 Menue Farben setzen
          if (SDVI_DRI && SDVI_DRI->dri_Version >= 2) {
            rit->FrontPen = SDVI_DRI->dri_Pens[BARDETAILPEN];
            rit->BackPen  = SDVI_DRI->dri_Pens[BARBLOCKPEN];
          }

          if (MLay[i].RightString){
            rit->IText = MLay[i].RightString;
          }
          else {
            rit->IText = "»";
          }

          it->NextText = rit;
        }
        else {
          it->NextText = NULL;
        }
      }
    }
    else {
      /* dann sind wir im Resolution Menu */
      char buf[20];
      sprintf(buf,"%4ld dpi",((i<show_state.menu_res_lines) ? (long)show_state.mres[i] : 0));
      it->IText = strdup(buf);
      it->NextText = NULL;
    }


    if (MLay && MLay[i].Special & SPECIAL_EMPTY) {
      mi[i].ItemFill = xmalloc(sizeof(struct Image));
      ((struct Image *)mi[i].ItemFill)->NextImage = xmalloc(sizeof(struct Image));
    }
    else {
      mi[i].ItemFill = (APTR)it;
    }



    /* linker Teil */
    if (it->IText == NULL) {
      len = 0;
    }
    else {
      len = TextLength(rp, it->IText, strlen(it->IText));
    }

    if (mi[i].Flags & CHECKIT) {
      len += CHECKWIDTH;
    }
    if (len > maxlen) maxlen = len;

    /* rechter Teil */
    len2 = 0;
    if (mi[i].Flags & COMMSEQ) {
      char str[2];	/* zur Sicherheit, damit ich nicht & auf BYTE mache */
      str[0] = mi[i].Command;
      str[1] = '\0';
      len2 = COMMWIDTH + TextLength(rp, str, 1);
    }
    if (it->NextText != NULL) {
      len2 += TextLength(rp, it->NextText->IText, strlen(it->NextText->IText));
    }
    if (len2 > maxlen2) maxlen2 = len2;
    if (len+len2 > max) max = len+len2;
  }
#if 0
  len = maxlen + maxlen2 + spacelen*2 + 2;	/* Breite des Menues */
#else
  len = max + spacelen*2 + 2;			/* Ueberlappende Breite */
#endif
  

  /* und nun wird das Menue aufgebaut */
  pos = 0;
  for (i=0; i<NrEntries; i++) {
    it = (struct IntuiText *)mi[i].ItemFill;

    mi[i].TopEdge = pos;
    if (MLay && MLay[i].Special & SPECIAL_IS_SUB) {
      mi[i].LeftEdge = width*3/5;
    }
    mi[i].Width = len;
    if (MLay && MLay[i].Special & SPECIAL_EMPTY) {
      register struct Image * img = (struct Image *)it;
      mi[i].Height = lineheight/2;
      img->Depth    = 1;
      img->TopEdge  = (mi[i].Height-1)/2;
      img->LeftEdge = 1;
      img->Height   = 0;
      img->Width    = 0; //len-2;
      if (is_os3) img->PlaneOnOff = 1;
      img->NextImage->Depth    = 1;
      img->NextImage->TopEdge  = img->TopEdge;
      img->NextImage->LeftEdge = 1;
      img->NextImage->Height   = 2;
      img->NextImage->Width    = len-2;
      if (is_os3) img->NextImage->PlaneOnOff = 1;
      //img->NextImage = NULL;
    }
    else {
      mi[i].Height = lineheight;
    }
    pos += mi[i].Height;

    if (!MLay || !(MLay[i].Special & SPECIAL_EMPTY)) {
      it->ITextFont = NULL;
      it->TopEdge = 1;
      if (it->NextText && it->NextText->IText) {
        int tmplen = TextLength(rp, it->NextText->IText, strlen(it->NextText->IText));
      
        //printf("X rp: %x, it: %x, it->NextText: %x, it->NextText->IText: %x\n", 
        //	rp, it, it->NextText, it->NextText->IText);
      
        if (tmplen < spacelen) tmplen = spacelen;
#if 0
        it->NextText->LeftEdge = maxlen + spacelen*2 + maxlen2 - tmplen;
#else
        it->NextText->LeftEdge = max + spacelen*2 - tmplen;
#endif
        it->NextText->ITextFont = NULL;
        it->TopEdge = 1;
      }
    }
  }
  
  return mi;
}


#endif /* AMIGA */
