/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from prhelp.c
*/
#ifndef DISPLAY
/* Name:prhelp.c	Revision:1	Date:25.4.91
**
**	prhelp.c
**
**	Defines the printer's specific parameters
**
FUNCTIONS:
	ShowPrinters()		Shows the available printers.
	SetupPrinterPara()	After parsing of the command line, set
		the caracteristics of the printer to use
	PrepareHardcopies()	Called *once* after the bitmap has been
		allocated, and the printer.device opened, but before
		any hardcopy is started.
	EndHardcopies()		Called after all the pages have been
		printed, before closing the printer.device.
**
AUTHOR:		J\"org H\"ohle
*/

#include "defines.h"
#include <stdio.h>
#include <string.h>

#if defined(ANSI)
#include <stdlib.h>
#endif

#include "globals.h"
#include "bitmap.h"
#include "prhelp.h"
#include "parsef.h"

#include "globals.i"
#include "prhelp.i"
#ifdef AMIGA
#include "amprhelp.i"
#include "amprint.i"
extern int  is_printer_started;		/* 0: nein, 1: init ok, 2: print gestartet   */
#endif
#include "dvihand.i"	/* wg. OpenConfigFile() */
#include "parsef.i"
#include "new_font.i"
#include "GetOpt.i"	/* wegen dimen_to_inch()  */
#include "newhard.i"	/* extern char *PrnBuffer */



/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"




/*hes: map sollte in ??.h definiert werden, oder ? Ich brauche die Breite */
extern struct bitmap map;
extern int is_printing_aborted;


/* Global var */

int no_printer_given;		/* no printer explicitedly defined 	*/
struct printer_para *Printer = NULL;
long	pp_dots_per_space;	/* as name says				*/
long	pp_dots_per_point;	/* as name says				*/
long	pp_max_dots_line;	/* pp_xdpi * pp_pica_width / 10		*/
/* char *default_printer_name;	 * can only be defined below		*/


/* lots of local vars... */

static char *printer_config	= PRINTER_CONFIG;
// static char ptwice[]=	"%s: Keyword specified twice in line %d \"%s\"!";
// static char pcontext[]=	"%s: Keyword out of context in line %d \"%s\"!";
static char *pname;		/* printer name we are looking for	*/
static int pdraft;		/* draft or not				*/
static int psecure;		/* optimize or not			*/
static int skip_rest_def;	/* skip rest of printer definition	*/
static int seek_end_description;/* look for end of description		*/
static int ldraft;		/* draft defined in this description	*/
static int loptimize;		/* optimization defined			*/
static int lnameok;		/* is this a matching description?	*/

#ifdef ATARI
static char SLM804[]	= "SLM804";
char *default_printer_name = SLM804;
#else
static char Generic[]	= "generic";
char *default_printer_name = Generic;
#endif
static char DeskJet[]	= "DeskJet";
static char CheapDJ[]	= "CheapDJ";
static char LaserJet[]  = "LaserJet";
static char LaserJet4[] = "LaserJet4";
static char Canon[]     = "CanonLBP";
static char *switches[] = {"any ", "no ", ""};

static struct printer_para PrinterData;		/* struct we fill in	*/


static void show_hex_string(char *name, char *contents, short length);

//static void __stdargs pkw_NOP(struct string_parse *, char *l);
static void __stdargs pkw_printer(struct string_parse *, char *l, char *name);
static void __stdargs pkw_ID(struct string_parse *, char *l);
static void __stdargs pkw_first(struct string_parse *, char *l, int onoff);
static void __stdargs pkw_skip_rest_def(struct string_parse *, char *l);
static void __stdargs pkw_end(struct string_parse *, char *l);
static void __stdargs pkw_bytes(struct string_parse *, char *l);
static void __stdargs pkw_filter_context(struct string_parse *, char *l);
static void __stdargs pkw_int(struct string_parse *, char *l, long *arg);
static void __stdargs pkw_resolution(struct string_parse *, char *l, char *resolution);
static void __stdargs pkw_width(struct string_parse *, char *l, char *width);
static void __stdargs pkw_blank(struct string_parse *, char *l, char *methodname);
static void __stdargs pkw_describe_printer(struct string_parse *parse, char *line);
static void __stdargs pkw_end_description(struct string_parse *parse, char *line);

static void ReadPrinterConfig(char *name, int draft, int secure);


static int ToGet;	/* describes actions taken while reading config */
#define GET_FILL		1
#define GET_ID			2
#define GET_EXACT_PRINTER	4
#define GET_EXACT_NAME		8
#define GET_NOFILL_INTERNAL	16

#define SHOW_NAME		256
#define SHOW_ID			512
#define SHOW_CONFIG		1024
#define SHOW_DESCRIPTION	2048

static long fillin;	/* describes values found in configuration file */
#define FILL_PRINTER	1
#define FILL_DRAFT	2
#define FILL_SECURE	4
#define FILL_FIRST	7

#define FILL_GROUPING	(1L<<3)
#define FILL_RES	(1L<<4)
#define FILL_GFX_STR	(1L<<5)
#define FILL_SKIP_STR	(1L<<6)
#define FILL_SKIPS	(1L<<7)
#define FILL_HEIGHT	(1L<<8)
#define FILL_METHOD	(1L<<9)
#define FILL_WIDTH	(1L<<10)
#define FILL_ALL	((1L<<11)-1)
#define FILL_NEEDED	(FILL_ALL-FILL_FIRST)

#define FILL_MAXDOTS	(1L<<11)	/* don't use this anymore */
#define FILL_PRTBUF	(1L<<12)
#define FILL_INIT	(1L<<13)
#define FILL_EXIT	(1L<<14)
#define FILL_DESC	(1L<<15)
#define FILL_ID		(1L<<16)


static char begin_desc[]= "description"; /* describe printer keyword */
static char end_desc[] = "end_desc";


static struct string_parse printer_defs[] = {
	{
	end_desc,
	NULL,
	(string_parse_function) pkw_end_description,
	PAF_NOKEY,
	sizeof(end_desc)
	},	
	{
	begin_desc,	/* optional printer name */
	NULL,
	(string_parse_function) pkw_describe_printer,
	PAF_NO_ARG,
	sizeof(begin_desc)
	},	
	{
	"#",		/*	skip rest of this printer definition	*/
	NULL,		/*	(just speeds thing up a bit).		*/
	(string_parse_function) pkw_skip_rest_def,
	PAF_NOKEY
	},
	{
	"#",		/*R	End of printer definitions	*/
	NULL,
	(string_parse_function) pkw_end,
	PAF_NO_ARG
	},
	{
	"printer",	/*Required*/
	"%14s",
	(string_parse_function) pkw_printer,
	PAF_1_ARG,
	FILL_PRINTER
	},
	{
	"ID_str",	/*Optional, short description */
	"%40s",
	(string_parse_function) pkw_ID,
	PAF_ARGS,
	FILL_ID
	},
	{
	"draft",	/*optional, but must come before keywords below */
	NULL,
	(string_parse_function) pkw_first,
	PAF_BOOL_ARG | PAF_1_ARG,
	FILL_DRAFT
	},
	{
	"optimize",	/*optional, but must come before keywords below */
	NULL,
	(string_parse_function) pkw_first,
	PAF_BOOL_ARG | PAF_1_ARG,
	FILL_SECURE
	},
	{
	NULL,		/*	If keywords below this line are not	*/
	NULL,		/*	allowed anywhere in configuration.	*/
	(string_parse_function) pkw_filter_context,
	PAF_NOKEY
	},
	{
	"resolution",	/*R	resolution (n or x/y)		*/
	"%s",
	(string_parse_function) pkw_resolution,
	PAF_1_ARG,
	FILL_RES
	},
	{
	"gfx_str",	/*R	appropriate gfx command		*/
	NULL,
	(string_parse_function) pkw_bytes,
	PAF_ARGS,
	FILL_GFX_STR
	},
	{
	"skips",	/*R	what skip for each pass ?	*/
	NULL,
	(string_parse_function) pkw_bytes,
	PAF_ARGS,
	FILL_SKIPS
	},
	{
	"skip_str",	/*R	appropriate gfx command		*/
	NULL,
	(string_parse_function) pkw_bytes,
	PAF_ARGS,
	FILL_SKIP_STR
	},
	{
	"height",	/*R Total of skips: Bitmap must be multiple of height */
	"%d",
	(string_parse_function) pkw_int,
	PAF_1_ARG,
	FILL_HEIGHT
	},
	{
	"grouping",	/*R	1 or 3, for 8 24 or 48 pins (erlaubt 1-MAX_GROUPING)	*/
	"%d",
	(string_parse_function) pkw_int,
	PAF_1_ARG,
	FILL_GROUPING
	},
	{
	"blank",	/*R	blanking method			*/
	"%10s",
	(string_parse_function) pkw_blank,
	PAF_1_ARG,
	FILL_METHOD
	},
	{
	"paper_width",	/*R	number of pica chars on one line */
	"%s",
	(string_parse_function) pkw_width,
	PAF_1_ARG,
	FILL_WIDTH
	},
	{
	"init_str",	/*O	initialize printer		*/
	NULL,
	(string_parse_function) pkw_bytes,
	PAF_ARGS,
	FILL_INIT
	},
	{
	"exit_str",	/*O	send string on exit		*/
	NULL,
	(string_parse_function) pkw_bytes,
	PAF_ARGS,
	FILL_EXIT
	},
	{
	"prtbuffer",	/*O	same as DVIprint option		*/
	"%ld",
	(string_parse_function) pkw_int,
	PAF_1_ARG,
	FILL_PRTBUF
	},
#if 0
	{
	"pica_width",	/* remove as soon as possible		*/
	"%d",
	(string_parse_function) pkw_NOP,
	PAF_1_ARG
	},
#endif
	{
	NULL
	},
};



#if 0
static void __stdargs pkw_NOP(struct string_parse *parse, char *line)
{
}
#endif


/*	pkw_describe_printer
 *
 * we found the beginning of a description.
 */
static void __stdargs pkw_describe_printer(struct string_parse *parse, char *line)
{
  if (!(fillin & FILL_PRINTER))
    Fatal(5, MSG_KEY_CONTEXT, printer_config, Parse_Linenr, line);
  /*fillin |= FILL_DESC;*/
  seek_end_description = 1;
}


/*	pkw_end_description
 *
 * dump the description until the end marker is reached.
 */
static void __stdargs pkw_end_description(struct string_parse *parse, char *line)
{
  if (seek_end_description) {
    if (0!=strnicmp(parse->paf_keyword,line, parse->paf_userdata)) {
      if (ToGet & SHOW_DESCRIPTION && lnameok)	MessageStr(line);
    }
    else {
      seek_end_description = 0;
    }
    Parse_Control |= PAC_END_SEARCH;	/* skip search for other keywords */
  }
}


/*	pkw_printer
 *
 * found the 'printer' keyword, analyze configuration or not?
 */
static void __stdargs pkw_printer(struct string_parse *parse, char *line, char *name)
{
  if (fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);	/* no aliases supported any more */
  else {
    if (ToGet & GET_EXACT_NAME)
      if (0 != stricmp(name, pname))
	skip_rest_def = 1;
      else {
	lnameok = 1;
	if (ToGet & SHOW_NAME)
	  Message(MSG_PRINTER_NAME,name);
      }
    else {
      if (ToGet & SHOW_NAME)
	Message(MSG_PRINTER_NAME,name);
      if (!(ToGet & GET_NOFILL_INTERNAL))
	PrinterData.pp_name = strdup(name);
      lnameok = 1;
    }
    fillin |= FILL_PRINTER;
  }
}


/*	pkw_skip_rest_def
 *
 * we are looking for another configuration, so we skip the current one.
 */
static void __stdargs pkw_skip_rest_def(struct string_parse *parse, char *line)
{
  if (skip_rest_def)
    if (*parse->paf_keyword != *line)	/* special case of strcmp() */
      Parse_Control |= PAC_END_SEARCH;	/* skip search for other keywords */
}


/** Message(), Logging() and Warning() prototypes *
typedef void __stdargs (*show_function)(char *format, ...);
**/

/*	pkw_end
 *
 * End of a printer configuration : lots of things to do!
 */
static void __stdargs pkw_end(struct string_parse *parse, char *line)
{
  if (!(fillin & FILL_PRINTER))
    Fatal(5, MSG_KEY_CONTEXT, printer_config, Parse_Linenr, line);
  else {
/**	Wie bringe ich Lattice das bei ? :-(
(in BLINK _Warning durch @Warning zu ersetzen ist nicht so das Wahre...)
    show_function show;
    show = Stats ? (show_function)Warning : (show_function)Message;
**/
    if (!skip_rest_def) { /* means definition matches requirements */
      int missing = FILL_NEEDED ^ (fillin & FILL_NEEDED);
      if (ToGet & SHOW_ID && PrinterData.pp_ID_string) {
	Message(MSG_PRINTER_ID, PrinterData.pp_ID_string);
      }
      if (ToGet & GET_FILL && missing && !(ToGet & GET_NOFILL_INTERNAL)) {
	struct string_parse *p;
	for (p = &printer_defs[3]; p->paf_function; p++) {
	  if (p->paf_userdata & missing)
	    Message(MSG_MISSING_KEYWORD, p->paf_keyword);
	}
	Fatal(5,MSG_INCOMPLETE_PRT_DESC, printer_config, Parse_Linenr);
      }
      else {
	if (ToGet & SHOW_NAME) {
	  Message(MSG_USE_DRAFT_OPT,
	    switches[ldraft],
	    switches[loptimize]);
	}
	if (ToGet & SHOW_CONFIG && !(ToGet & GET_NOFILL_INTERNAL)) {
	  Message(MSG_PRT_RESO,PrinterData.pp_xdpi,PrinterData.pp_ydpi);
	  Message(MSG_PRT_WIDTH,PrinterData.pp_pica_width);
	  if (PrinterData.pp_init_string)
	    show_hex_string("\tinit_str ", PrinterData.pp_init_string, PrinterData.pp_init_len);
	  if (PrinterData.pp_gfx_cmd)
	    show_hex_string("\tgfx_str  ", PrinterData.pp_gfx_cmd, PrinterData.pp_gfx_cmd_len);
	  Message(MSG_PRT_PASSES,
	    PrinterData.pp_passes, 8 * PrinterData.pp_grouping);
	  Message(MSG_PRT_BITMAP_HEIGHT, PrinterData.pp_passes_height);
	  if (PrinterData.pp_skip)
	    show_hex_string("\tskips    ", PrinterData.pp_skip, PrinterData.pp_passes);
	  if (PrinterData.pp_skip_cmd)
	    show_hex_string("\tskip_str ", PrinterData.pp_skip_cmd, PrinterData.pp_skip_cmd_len);
	  if (PrinterData.pp_exit_string)
	    show_hex_string("\texit_str ", PrinterData.pp_exit_string, PrinterData.pp_exit_len);
	  if (PrinterData.pp_buffer_size)
	    Message(MSG_PRT_DEF_BUF_SIZE, PrinterData.pp_buffer_size);
	  /**/
	  switch (PrinterData.pp_method) {
	    case METHOD_MOVE_POINT:
	      Message(MSG_PRT_MOVE_TO_POINT);
	      break;
	    case METHOD_GFX_ONLY:
	      Message(MSG_PRT_ONE_GRAPHIC_COMMAND);
	      break;
	    case METHOD_USE_SPACES:
	      Message(MSG_PRT_SKIP_WITH_SPACES);
	      break;
	  }
	}
	if (ToGet & SHOW_NAME) {
	  //Message("End of this configuration."); Ende Meldung wird nicht benoetigt
	}
	if (ToGet & GET_EXACT_PRINTER) {
	  if (ToGet & GET_FILL) {
	    Printer = &PrinterData;
	    PrinterData.pp_special |= SPECIAL_STD;
	    PrinterData.pp_printer = STANDARD_PRINTER;
	  }
	  Parse_Control |= PAC_END;
	}
      }	/* !Fatal */
    }	/* !skip_rest_def */
    if (!(Parse_Control & PAC_END)) {      /* reset data for another use */
	if (PrinterData.pp_ID_string)	{
	  free(PrinterData.pp_ID_string);	// kein xfree() da durch strdup() alloc
	  PrinterData.pp_ID_string = NULL;
	}
	if (PrinterData.pp_name)	xfree(PrinterData.pp_name);
	/* no need to free all the strings, combination not used yet */
	if (!(ToGet & GET_NOFILL_INTERNAL))
	  memset(&PrinterData, 0, sizeof(struct printer_para));
	ldraft = 0;
	loptimize = 0;
	lnameok = 0;
	fillin = 0L;
    }
  }
  skip_rest_def = 0;
}


/*	pkw_first
 *
 * some keywords must come first because they characterize the current
 * configuration. This way we can skip the end of non matching
 * configurations.
 */
static void __stdargs pkw_first(struct string_parse *parse, char *line, int onoff)
{
  int candidate = 1;
  if (!(fillin & FILL_PRINTER))
    Fatal(5, MSG_KEY_CONTEXT, printer_config, Parse_Linenr, line);
  else if (parse->paf_userdata & fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);
  /* check if not towards beginning ? */
  switch (parse->paf_userdata) {
    case FILL_DRAFT:
	if (ToGet & GET_EXACT_PRINTER && onoff != pdraft) candidate = 0;
	else ldraft = 1+ onoff;
	  /*PrinterData.pp_flags |= onoff ? P_DRAFT_Q : P_HIGH_Q;*/
	break;
    case FILL_SECURE:
	 /* option is named optimize, thus optimize == !secure	*/
	if (ToGet & GET_EXACT_PRINTER && onoff == psecure) candidate = 0;
	else loptimize = 1+ onoff;
	  /*PrinterData.pp_flags |= onoff ? 0 : P_SECURE;*/
	break;
  }
  fillin |= parse->paf_userdata;
  if (!candidate) skip_rest_def = 1;
}


/*	pkw_ID
 *
 * One line characterization of current configuration.
 */
static void __stdargs pkw_ID(struct string_parse *parse, char *line)
{
  if (!(fillin & FILL_PRINTER))
    Fatal(5, MSG_KEY_CONTEXT, printer_config, Parse_Linenr, line);
  else if (FILL_ID & fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);
  else if (ToGet  & GET_ID) {
    if (PrinterData.pp_ID_string) free(PrinterData.pp_ID_string); // kein xfree() da durch strdup() allociert
    PrinterData.pp_ID_string = strdup(args_line(line));
    fillin |= FILL_ID;
  }
}


/*	pkw_filter_context
 *
 * The internal drivers do not allow most keywords. Otherwise they
 * wouldn't be internal. Only a description may be associated with
 * these printers.
 */
static void __stdargs pkw_filter_context(struct string_parse *parse, char *line)
{
  if (!(fillin & FILL_PRINTER)
   || (GET_NOFILL_INTERNAL|GET_FILL)==(ToGet & (GET_NOFILL_INTERNAL|GET_FILL)))
    Fatal(5, MSG_KEY_CONTEXT, printer_config, Parse_Linenr, line);
  else if (!(ToGet & GET_FILL)) Parse_Control |= PAC_END_SEARCH;
}


/*	pkw_resolution
 *
 * get the resolution of this printer configuration.
 */
static void __stdargs pkw_resolution(struct string_parse *parse, char *line, char *resolution)
{
  if (FILL_RES & fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);
  else if (ToGet & GET_FILL) {
      char c;
      if (2 != sscanf(resolution, "%hd/%hd%c",
		&PrinterData.pp_xdpi,
		&PrinterData.pp_ydpi, &c)) {
        if (1 != sscanf(resolution, "%hd%c", &PrinterData.pp_xdpi, &c)) {
	   Fatal(5,MSG_PRT_BAD_RESO,
		GetTeXString(MSG_PRT_USE_RES),
		printer_config, Parse_Linenr, resolution);
	}
	else PrinterData.pp_ydpi = PrinterData.pp_xdpi;
      }
      fillin |= FILL_RES;
  }
  else skip_rest_def = 1;	/*J: too strong ? */
}


/*	pkw_bytes
 *
 * Several keywords are follwed by a sequence of bytes which define a
 * string sent to the printer. (Usually a printer command)
 */
static void __stdargs pkw_bytes(struct string_parse *parse, char *line)
{
  if (parse->paf_userdata & fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);
  else if (ToGet & GET_FILL) {
    char *array;
    array = parse_bytes(line);
    if (array[0]) {
      switch(parse->paf_userdata) {
        case FILL_INIT:			/*	init string	*/
	  PrinterData.pp_init_len = *(array++);
          PrinterData.pp_init_string = array;
	  break;
	case FILL_EXIT:			/*	exit string	*/
	  PrinterData.pp_exit_len = *(array++);
          PrinterData.pp_exit_string = array;
	  break;
	case FILL_GFX_STR:		/*	gfx commands	*/
	  PrinterData.pp_gfx_cmd_len = *(array++);
	  PrinterData.pp_gfx_cmd = array;
	  break;
	case FILL_SKIP_STR:		/*	skip line commands	*/
	  PrinterData.pp_skip_cmd_len = *(array++);
	  PrinterData.pp_skip_cmd = array;
	  break;
	case FILL_SKIPS:		/*	skip heights	*/
	  PrinterData.pp_passes = *(array++);
	  PrinterData.pp_skip = array;
	  break;
#if defined(HARDDEB)
	default : Fatal(20,"pkw_bytes(): Illegal switch!");
#endif
      }
      fillin |= parse->paf_userdata;
      /**/
    }
  }
  else skip_rest_def = 1;	/*J: too strong  ? */
}


/*	pkw_blank
 *
 * Get the blanking method for use with this printer.
 */
static void __stdargs pkw_blank(struct string_parse *parse, char *line, char *methodname)
{
  if (FILL_METHOD & fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);
  else if (ToGet & GET_FILL) {
    short method = 0;
         if (0==stricmp(methodname,"POINT"))	method = METHOD_MOVE_POINT;
    else if (0==stricmp(methodname,"SPACES"))	method = METHOD_USE_SPACES;
    else if (0==stricmp(methodname,"GFX"))	method = METHOD_GFX_ONLY;
    else Fatal(5,MSG_UNKNOWN_BLANKING, printer_config, Parse_Linenr, methodname);
    PrinterData.pp_method = method;
    fillin |= FILL_METHOD;
  }
  else skip_rest_def = 1;		/*J: too strong ? */
}


/*	pkw_width
 *
 * Get the paper/printer width for use with this printer.
 */
static void __stdargs pkw_width(struct string_parse *parse, char *line, char *width)
{
  if (FILL_WIDTH & fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);
  else if (ToGet & GET_FILL) {
    float dimen_inch;
    int isTrue;
    if (0!=dimen_to_inch(width, &dimen_inch, &isTrue))
      Fatal(5,MSG_ILLEG_PARM_FOR_KEY,
	printer_config, parse->paf_keyword, Parse_Linenr, width);
    else {		/* 	10 pica chars fit in one inch	*/
	PrinterData.pp_pica_width = (char) (dimen_inch * 10);
	fillin |= FILL_WIDTH;
    }
  }
  else skip_rest_def = 1;		/*J: too strong ? */
}


/*	pkw_int
 *
 * Certain keywords are followed by an integer value.
 */
static void __stdargs pkw_int(struct string_parse *parse, char *line, long *value)
{
  if (parse->paf_userdata & fillin)
    Fatal(5, MSG_KEY_TWICE, printer_config, Parse_Linenr, line);
  else if (ToGet & GET_FILL) {
    switch(parse->paf_userdata) {
      case FILL_PRTBUF:
	PrinterData.pp_buffer_size = *value;
	break;
      case FILL_HEIGHT:
        PrinterData.pp_passes_height = *value;
	break;
      case FILL_GROUPING:
	if (1L > *value && 3L < *value)
	  Fatal(5,MSG_GROUPING_RANGE, printer_config, *value);
        PrinterData.pp_grouping = *value;
	break;
#if 1 || defined(HARDDEB)
      default: FatalStr(20,"pkw_int() : Illegal switch!");
#endif
    }
    fillin |= parse->paf_userdata;
  }
  else skip_rest_def = 1;		/*J: too strong ? */
}


/*	show_hex_string
 *
 * Output a byte sequence as read by pkw_bytes().
 */
static void show_hex_string(char *name, unsigned char *contents, short length)
{
  short i;
  int n;
  n = sprintf(m_string,"%s: %hd byte(s) :",name, length);
  for (i =0; length; i++, length--) {
    switch(contents[i]) {
      case PP_INS_LOW:
        n += sprintf(&m_string[n]," LOW");
	break;
      case PP_INS_HIGH:
        n += sprintf(&m_string[n]," HIGH");
	break;
      case PP_INS_DEC:
        n += sprintf(&m_string[n]," DECIMAL NUMBER");
	break;
      case PP_INS_NR100:
        n += sprintf(&m_string[n]," NR100");
	break;
      case PP_INS_NR10:
        n += sprintf(&m_string[n]," NR10");
	break;
      case PP_INS_NR1:
        n += sprintf(&m_string[n]," NR1");
	break;
      default:
	n += sprintf(&m_string[n]," %02X", (int)contents[i]);
    }
  }
  MessageStr(m_string);
}



/*******	ReadPrinterConfig()
**
*/

static void ReadPrinterConfig(char *name, int draft, int secure)
{
  int phelp;
  FILE *f;

  ToGet = GET_ID;
  /*	no config file for these special printers, unless we want help	*/
#ifdef AMIGA
  if (0==stricmp(name,Generic)) {
    Printer = &PrinterData;
    PrinterData.pp_passes_height = 1;
    PrinterData.pp_special = SPECIAL_NO_REDIR | SPECIAL_PREFS;
    PrinterData.pp_printer = GENERIC_PRINTER;
    /* pp_max_dots_line will be filled in by amprhelp.c:get_printer_resolution() */
    if (!o_showprinter) return; /* without reading config file */
    else ToGet |= GET_NOFILL_INTERNAL;
  }
#endif
#ifdef ATARI
  if (0==stricmp(name,SLM804)) {
    Printer = &PrinterData;
    PrinterData.pp_passes_height = 1;
    PrinterData.pp_xdpi = PrinterData.pp_ydpi = draft ? 100 : 300;
    PrinterData.pp_special = SPECIAL_NO_RDIR;
    PrinterData.pp_printer = SLM_804;
    if (!o_showprinter) return; /* without reading config file */
    else ToGet |= GET_NOFILL_INTERNAL;
  }
#endif
  { short hp = 0;
    if (0==stricmp(name,DeskJet))	 hp = DESKJET;
    else if (0==stricmp(name,CheapDJ))	 hp = CHEAPDJ;
    else if (0==stricmp(name,LaserJet))	 hp = LASERJET;
    else if (0==stricmp(name,LaserJet4)) hp = LASERJET4;
    else if (0==stricmp(name,Canon))	 hp = CANON;
    if (hp) {
      Printer = &PrinterData;
      PrinterData.pp_passes_height = 2; 	/*hes: im Cheap nur jede 2.Zeile */
      if (hp == LASERJET4) {
        PrinterData.pp_xdpi = PrinterData.pp_ydpi = (draft) ? 300 : 600;
      }
      else {
        PrinterData.pp_xdpi = PrinterData.pp_ydpi = (draft) ? 100 : 300;
      }
      PrinterData.pp_printer = hp;
      PrinterData.pp_special = 0;
      if (!o_showprinter) return; /* without reading config file */
      else ToGet |= GET_NOFILL_INTERNAL;
    }
  }

  /* set lots of flags, nur mit Tabelle verstaendlich... */
  if (o_showprinter && !(no_printer_given && !*filename))
    ToGet |= SHOW_DESCRIPTION;
  phelp = 0 == stricmp(name,"help") || 0 == strcmp(name,"?");
  if (!phelp && !(no_printer_given && !*filename))
    ToGet |= GET_EXACT_PRINTER | GET_EXACT_NAME | GET_FILL;
  if (!no_printer_given && !phelp)
    ToGet |= GET_FILL;
  if (phelp || no_printer_given || o_showprinter)
    ToGet |= SHOW_ID | SHOW_NAME;
  if (!phelp && !no_printer_given && o_showprinter)
    ToGet |= SHOW_CONFIG;

  if (ToGet & GET_NOFILL_INTERNAL)
    ToGet &= ~GET_FILL;

#if 0 || defined(HARDDEB)
printf("SHOWDESC %d\n", ToGet & SHOW_DESCRIPTION);
printf("SHOWID   %d\n", ToGet & SHOW_ID);
printf("SHOWCONF %d\n", ToGet & SHOW_CONFIG);
printf("SHOWNAME %d\n", ToGet & SHOW_NAME);
printf("GETFILL  %d\n", ToGet & GET_FILL);
printf("GETID    %d\n", ToGet & GET_ID);
printf("GETEXACT %d\n", ToGet & GET_EXACT_PRINTER);
printf("GETNOFILL%d\n", ToGet & GET_NOFILL_INTERNAL);
#endif

  if (NULL == (f = OpenConfigFile(printer_config, MODE_READ)))
    Fatal(10,MSG_CANT_OPEN_PRT_CONFIG, printer_config);
  else {
    pname=name;
    pdraft=draft;
    psecure=secure;

    Logging(MSG_READ_PRT_CONFIG, printer_config);
    parse_file(&printer_defs[0], f, PAC_END_UNKNOWN);
    fclose(f);

    /* exit gracefully ? */
    if (phelp || (o_showprinter && !*filename)) {
      Message(MSG_THATS_ALL);
      AbortRun(0);
    }
  }
}



#ifdef OLDARGS
/*******	ShowPrinters()
**
*/

void ShowPrinters(int longlist) {
  switch (longlist) {
    case 2: {	/*	show everything		*/
      struct printer_para *p;
      printf(GetTeXString(MSG_AVAILABLE_PRINTERS));
      for (p = possible_printers; p->pp_name; p++) {
        printf("%-7s %5s %3s : %s\n",
		p->pp_name,
		(p->pp_draft == DRAFT_Q) ? "DRAFT" : "",
		(p->pp_secure == SECURE) ? "OPT" : "",
		p->pp_ID_string);
      }	/* oder ins Logfile ?	*/
      break;
    }
    case 0: {	/* show only short names	*/
      char **pn;
      for (pn= printer_names; *pn; pn++) {
        printf(" %s",*pn);
      }
      printf("\n");
      break;
    }
    default: {	/* show only first of each type	*/
      char **pn;
      for (pn= printer_names; *pn; pn++) {
	struct printer_para *pp;
	for (pp = possible_printers; pp->pp_name; pp++) {
	  if (*pn == pp->pp_name) {
	    printf("\t\t%-7s: %s\n", *pn, pp->pp_ID_string);
	    break;
	  }
	}
      }
    }
  }
}
#endif /* OLDARGS */


/*	PrepareHardcopies
 *
 * Called only *once* in the programm, before we start dumping things
 * to the printer.
 */
void PrepareHardcopies(void)
{
   if (Printer->pp_grouping >= MAX_GROUPING){   
     Fatal(5, MSG_MAX_GROUPING);
   }

   if (iffprint) return;	/* nothing to do then */

   /* we check pp_grouping in order to recognize a Hardcopy_Standard() printer */
   if (Printer != NULL && Printer->pp_grouping > 0) {
     pp_dots_per_space = Printer->pp_xdpi / 10;
     pp_dots_per_point = Printer->pp_xdpi / 60;
     pp_max_dots_line  = pp_dots_per_space * Printer->pp_pica_width;

     if (ToDo & DO_GFXLINEBUF) {
       unsigned size = ((pp_max_dots_line+WP_GROESSE-1)&~(WP_GROESSE-1)) * Printer->pp_grouping + 5;
       PrnBuffer = xmalloc(size);
     }

     /*J: only with standard printers ? */
     if (Printer->pp_init_string && PrnBuffer) {
       string_out(Printer->pp_init_string, Printer->pp_init_len, Printer->pp_pica_width);
     }
   }

#if 0	/* lassen wir den Reset halt weg */
   if (Printer != NULL && Printer->pp_printer == LASERJET) {
      string_out("\33E", 2, PP_NORMAL_STRING);		/* Reset */
   }
#endif
    

   if (Printer != NULL && (Printer->pp_printer == LASERJET  ||
			   Printer->pp_printer == LASERJET4 ||
			   Printer->pp_printer == DESKJET   ||
			   Printer->pp_printer == CHEAPDJ)) {
     /* Peforationsskip aus */
     string_out("\33&l0L", 5, PP_NORMAL_STRING);
   }
   
   if (Printer != NULL && Printer->pp_printer == CANON) {
     initialize_canon_printer();
   }

   if (Printer->pp_ID_string) {
     Logging(MSG_PRINT_WITH, Printer->pp_ID_string);
   }
}



/*	EndHardcopies
 *
 * Called only *once* in the programm, before printer shutdown
 */
void EndHardcopies(void)
{
  if (!iffprint && Printer && Printer->pp_grouping) {
    extern int Skip_buffered;
    Skip_buffered = 0;	/* Skip lines at end */
    if (!is_printing_aborted && PrnBuffer) {
      if (Printer->pp_exit_string) {
        string_out(Printer->pp_exit_string,Printer->pp_exit_len, PP_NORMAL_STRING);
      }
#ifdef	APPEND_CR /*hes: das ist ein Zeichen, dass der User nicht
	veraendern kann, also sehe ich es lieber in exit_string. */
      else getout(CR);
#endif
    }
  }

#if 0
  if (Printer != NULL && Printer->pp_printer == LASERJET) {
     Reset lassen wir besser weg...
     string_out("\33E", 2, PP_NORMAL_STRING);
  }
#endif

  if (Printer != NULL && Printer->pp_printer == CANON) {
    end_canon_printer();
  }

#ifdef AMIGA
  prnflush(); /* possible in all cases ? */
#endif

  ToDo |= DO_NOZERO;
}


/*******	SetupPrinterpara	*******
**
** We look for a printer of given type and draft.
*/

struct printer_para *SetupPrinterPara(char *name, int draft, int secure)
{
  Printer = NULL;

  ReadPrinterConfig(name, draft, secure);

  if (NULL == Printer) {
     Fatal(5,MSG_UNKNOWN_PRT_CONFIG,printer_config);
  }

  Printer->pp_draft = (draft) ? DRAFT_Q : HIGH_Q;
  Printer->pp_secure = (secure) ? SECURE : 0;

  print_width	= Printer->pp_passes_height;
  resolution		=
  hconvresolution	= Printer->pp_xdpi;
  vconvresolution	= Printer->pp_ydpi;

  /* einige Tests durchfuehren */
  if (ToDo & DO_OUTFILE && !iffprint) { /* not with iffprint */
    if (Printer->pp_special & SPECIAL_NO_REDIR) {
	 Fatal(5,MSG_PRT_NO_OUTPUT_REDIRECTION);
    }
    else {
      output_file_ptr = fopen(output_file_name, "w");
      if (output_file_ptr == NULL) {
	   Fatal(5, MSG_CANT_OPEN_OUTPUT_FILE, output_file_name);
      }
    }
  }

  switch (Printer->pp_printer) {
#ifdef ATARI
	case SLM_804:
	  if (landscape) Fatal(5,"No landscape modus with this printer!");
	  break;
#endif
#ifdef AMIGA
	case GENERIC_PRINTER:
	  if (landscape) Fatal(5,MSG_NO_LAND_WITH_GENERIC);
	  ToDo |= DO_PDEVICE | DO_PPREFS;
	  break;
#endif
        case DESKJET:
	case CHEAPDJ:
	case LASERJET:
	case LASERJET4:
	case CANON:
#ifdef AMIGA
	  ToDo |= DO_PDEVICE | DO_PBUFFERS;
#else
	  ToDo |= DO_GFXLINEBUF;
#endif
	  break;
	case STANDARD_PRINTER:
	  if (!iffprint) {
#ifdef AMIGA
	    ToDo |= DO_PDEVICE | DO_PBUFFERS | DO_GFXLINEBUF;
#else
	    ToDo |= DO_GFXLINEBUF;
#endif
	  }
	  break;
	default:
	  Fatal(20,MSG_NO_PRT_TYPE_FLAG);
  }
  

  /*	nun geht es richtig los	*/

#ifdef AMIGA
 (void) InitPrinterDevice();	/* sig_nr wird nicht benoetigt */

  if (ToDo & DO_PPREFS) {
    setup_printer_preferences((UBYTE)o_density);
    get_printer_resolution((long*)&hconvresolution, (long*)&vconvresolution, &print_width);
    resolution = hconvresolution;
    if (print_width == 0) {
      print_width = Printer->pp_passes_height;
      if (print_width == 0) print_width = 2;	// ?? irgendwo soll da was nicht stimmen (FAX) ??
    }
  }
#endif

  if (ToDo & DO_REALPRINT && Printer->pp_ID_string) {
    WarningStr(Printer->pp_ID_string);
  }

  return Printer;
}

/*	T	A	B	E	L	L	E
 *
			get:			show:
			desc	exact	fill	name	id
nopr	nosh	nodvi:	 auf Hilfe verweisen, abgefangen
nopr	show	nodvi:	- -	-	-	v	v	;Ende
nopr	nosh	dvi  :		<Konf. nicht lesen>		;+drucken
nopr	show	dvi  :	v v	v	?v	v?v	v	;+drucken
help	nosh	nodvi:	- -	-	-	v	v	;Ende
help	show	nodvi:	v v	-	-	v	v	;Ende
help	nosh	dvi  :	- -	-	-	v	v	;Ende
help	show	dvi  :	v v	-	-	v	v	;Ende
name	nosh	nodvi:	- -	v	?v	v?-	v?-	;Fehler:DVI
name	show	nodvi:	v v	v	v v	v	v	;Ende
name	nosh	dvi  :	- -	v	v	-	-	;+drucken
name	show	dvi  :	v v	v	v v	v	v	;+drucken
internal name: Konf. nicht lesen.
 *
 *
don't use  !GET_EXACT_PRINTER & GET_FILL for now or correct
pkw_end(): free(lots_of_malloc'ed_stuff)
 */

#endif /* DISPLAY */
