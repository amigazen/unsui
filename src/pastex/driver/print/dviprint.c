/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from dviprint.c
*/
/*
 *
 * AUTHOR(s) -- Porting SUN-Version to ATARI ST / AMIGA
 *  Robert Stabl   -- managing dvi-file, hardcopy for NEC P6
 *  Georg Hessmann -- porting ATARI ST version to AMIGA 1000   
 */



/* Change log:
 *
 * 15-Mar-88 (rbs) -- ported sun version to atari st
 *                 -- v3.00
 * 06-Apr-88 (rbs) -- v3.12
 * 30-Apr-88 (rbs) -- v3.13 
 * 31-May-88 (rbs) -- v3.14
 * 04-Jul-88 (hes) / (rbs) -- ported atari version to amiga
 *                 -- v3.20
 * 26-Nov-89 (hes) -- Change log now in file util/version.h
 *                 -- v0.60
 */



/**********************************************************************/
/***********************  external definitions  ***********************/
/**********************************************************************/

#define MAIN		/*	for globals.h		*/

#ifdef AMIGA
/*	For now only the Amiga knows about GetOpt.c	*/
#define LONG_ARGS
#define TEX		/*	for GetOpt.h		*/
#endif

#include "defines.h"

#include <stdio.h>
#include <ctype.h>
#ifdef ANSI
#  include <stdlib.h>
#  include <string.h>
#endif

#include "globals.h"

#ifdef AMIGA
#  include <signal.h>
#  include <exec/types.h>
#  include <exec/exec.h>
#  include <exec/ports.h>
#  include <devices/printer.h>
extern struct ExecBase		*SysBase;
#  include <clib/exec_protos.h>
#  include <clib/dos_protos.h>
#  include <pragmas/exec_pragmas.h>
#  include <pragmas/dos_pragmas.h>
#endif

#ifdef AZTEC_C
#  include <functions.h>
#endif

#include "commands.h"
#include "dvihand.h"
#include "flmt.h"
#include "new_font.h"
#include "bitmap.h"
#ifdef LONG_ARGS
#  include "GetOpt.h"
#endif
#ifdef AMIGA
#  include "amprint.h"
#endif


#include "dviprint.i"
#include "newhard.i"
#include "new_font.i"
#include "globals.i"
#include "dvihand.i"
#include "dospecia.i"
#include "bitmap.i"
#include "muiprint.i"

#ifdef LONG_ARGS
#  include "GetOpt.i"
#  include "PrintOpt.i"
#  include "prhelp.i"
#endif

#ifdef AMIGA
#  include "fast_cp.i"
#  include "amprint.i"
#  include "amprhelp.i"
#endif
#ifdef ATARI
#  include "atscreen.i"
#endif


/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



#define EQ(a,b) (strcmp(a,b)==0)


/**********************************************************************/
/*************************  lokale Funktionen *************************/
/**********************************************************************/

#ifndef LONG_ARGS
static void PrintHelp		Args((void));
static void not_a_valid_integer	Args((void));
static void offset_to_inch	Args((double *inch,
				      float *offset,
				      char *einh));
static void DecodeArgs		Args((int argc,
       		     	              char **argv));

#ifdef AZTEC_C
#pragma regcall ( offset_to_inch (a0,a1,a2) )
#pragma regcall ( DecodeArgs (d0,a1) )
#endif
#endif /* LONG_ARGS */


/**********************************************************************/
/*************************  Global Variables  *************************/
/**********************************************************************/

/*	See globvars.h		*/

extern struct bitmap	map;

extern struct WBStartup	*WBenchMsg;
int __buffsize = 2048;	// setze fuer jedes File ein etwas groeseren Buffer


struct stack_entry {  /* stack entry */
    long hh, h, vv, v, w, x, y, z;  /* what's on stack */
};

static struct stack_entry stack[STACKSIZE];	/* stack		*/
static char ParamStr[STRSIZE];			/* used by GetBytes()	*/


/**********************************************************************/
/*******************************  main  *******************************/
/**********************************************************************/
void main(int argc, char *argv[])
{

    int command;            /* current command                       */
    long count[10];         /* the 10 counters at begining of each page */
    long cpagep;            /* current page pointer                  */
    long leftpagep;         /* left page pointer for twopage         */
    long tpagep;	    /* temporary page pointer		     */
    register int i;         /* command parameter; loop index         */
    long k;                 /* temporary parameter                   */
    int SkipMode = FALSE;   /* in skip mode flag                     */
    int sp;                 /* stack pointer                         */
    long val, val2;          /* temporarys to hold command information*/
    long w;                  /* current horizontal spacing            */
    long x;                  /* current horizontal spacing            */
    long y;                  /* current vertical spacing              */
    long z;                  /* current vertical spacing              */
    int Pass;                /* actual Pass                           */
    int is_first_print_page; /* used for FormFeed		      */

    /*	Initialize the non NULL Variables	*/
    g_logging =	-1;	/* disable it until DecodeArgs()	*/
    g_Logname =	DVIPRINT_LOGFILE;

#ifdef ATARI
    g_progname = "dviprint"; /* (rbs)  -- changed for atari st */
#else
#  ifdef AMIGA
    Enable_Abort = 1;
    task_priority = 0;
    check_background();
    if (argc) {
      g_progname = argv[0];
      WBenchMsg = NULL;
    }
    else {
      g_progname = "DVIprint";
      WBenchMsg = (struct WBStartup *)argv;
    }
#  else
    g_progname = argv[0];
#  endif
#endif

    /* defaults */
    MaxDviBufSize = 0;	// ueberhaupt kein Caching
    ncopies	= 1;
    last_form_feed = TRUE;		/* a formfeed at the last page?	*/
    is_first_print_page = TRUE;
    nr_printed_pages = 0;
    bytesperlong = sizeof (long);

    // -13.13: Zeigt GetOpt(), daß nichts definiert wurde
    user_paper_height_in = -13.13;
    user_paper_width_in  = -13.13;
    
    start_specialhost = FALSE;
    

    DecodeArgs( argc, argv );

    WarningStr(NULL);	/* print copyright string */

    
#if defined(BETACOPYRIGHT)
    PrintBetaCopy();
#endif

#ifdef AMIGA
    old_task_priority = (unsigned long)SetTaskPri(FindTask(NULL), task_priority);
#endif

    /* Set resolution for quality and printer */
    { int save_hresolution = hconvresolution;
      int save_vresolution = vconvresolution;
      int save_resolution = resolution;	/* ist == 0 falls -z xxx/yyy angegeben wurde */

      (void)SetupPrinterPara(o_printer_name, draft, !o_optimize);

      if (save_hresolution != 0) {	/* -z option are given */
        if (save_resolution == 0) { 	/* -z hhh/vvv */
          /* hier wird die dpi unveraendert uebernommen */
          resolution      = hconvresolution = save_hresolution;
          vconvresolution = save_vresolution;
        }
        else {				/* -z ddd */
          /* hier wird die Aufloesung dem Drucker angepasst */
          /* halte Ratio zwischen h und v ein */
          resolution	    = save_hresolution;
          vconvresolution = (int)((long)save_hresolution * (long)vconvresolution / (long)hconvresolution);
          hconvresolution = save_hresolution;
        }
      }
    }

    hoffset = (int)((double)hconvresolution * hoffset_in);
    voffset = (int)((double)vconvresolution * voffset_in);

#ifdef DEBUG
    if (DeBug) {
      printf("hoffset in inch: %f, hoffset in pixel: %d\n",hoffset_in,hoffset);
      printf("voffset in inch: %f, voffset in pixel: %d\n",voffset_in,voffset);
    }
#endif

    if (abs(user_paper_width_in+13.13) > 0.01) {
      paper_width = (long)((float)hconvresolution * user_paper_width_in);
    }
    else {
      paper_width  = hconvresolution * HSIZE;		/* for !preload */
    }							/*   default    */
							/*    size      */
    if (abs(user_paper_height_in+13.13) > 0.01) {
      paper_height = (long)((float)vconvresolution * user_paper_height_in);
    }
    else {
      paper_height = vconvresolution * VSIZE;
    }
							
    
#ifdef ATARI
    LogTOSVersion();
#endif

    /*	Hier wird nun die .dvi Datei analysiert.	*/

    if ('\0' == *filename)
      Fatal(5,MSG_NO_DVI_FILENAME);
    else if ((dvifp=OpenDVI(filename, MaxDviBufSize)) == NULL) {
      Fatal(5,MSG_CANT_OPEN_DVI_FILE,(char *)filename);
    }

    Pass=0;

    init_fontmt (0);	/* we are DVIPRINT */

    Logging(MSG_LOADING_DVI, filename);

    if ((i = (int) NoSignExtend(dvifp, 1)) != PRE)  {
        Fatal(5, MSG_MISSING_PRE);
    }

    i = SignExtend(dvifp, 1);
    if (i != DVIFORMAT)  {
        Fatal(5,MSG_WRONG_DVI_TYPE, i, DVIFORMAT);
    }

/* it is important that these be the very first things output !!! */


#ifdef DEBUG
    if (DeBug)
     {
      Message("Title: %s\n", filename);
      Message("Creator: %s\n", g_progname);
      if ( ncopies > 1 )
        {
         Message("%d @copies\n", ncopies);
        }
     }
#endif        
    tpagep = DVIftell(dvifp);

    if (Reverse) {
      if (ReadPostAmble(PreLoad))
       {
        Warning(MSG_INCOMPLETE_DVI_REVERSE);
        Reverse = FALSE;
        if (PreLoad)
         {
          Warning(MSG_INCOMPLETE_DVI_PRELOAD);
          PreLoad = FALSE;
         }
        DVIfseekSet(dvifp, tpagep);
        num = NoSignExtend(dvifp, 4);
        den = NoSignExtend(dvifp, 4);
        mag = NoSignExtend(dvifp, 4);
        k = NoSignExtend(dvifp, 1);
        GetBytes(dvifp, ParamStr, k);
       }
      else
       {
        if (PreLoad) {
          GetFontDef(1);
        }
        DVIfseekSet(dvifp, ppagep);
       }
    }
    else {
       if (PreLoad) {
         if (ReadPostAmble(TRUE))
          {
           Warning(MSG_INCOMPLETE_DVI_PRELOAD);
           PreLoad = FALSE;
           DVIfseekSet(dvifp, tpagep);
           num = NoSignExtend(dvifp, 4);
           den = NoSignExtend(dvifp, 4);
           mag = NoSignExtend(dvifp, 4);
          }
         else
          {
            GetFontDef(1);
            DVIfseekSet(dvifp, 14L);
          }
        }
       else 
        {
         if (ReadPostAmble(FALSE)) 
          {
            /* DVI file not complete */
            Warning(MSG_INCOMPLETE_DVI);
            DVIfseekSet(dvifp, tpagep);
            num = NoSignExtend(dvifp, 4);
            den = NoSignExtend(dvifp, 4);
            mag = NoSignExtend(dvifp, 4);
          }
         DVIfseekSet(dvifp, 14L);
        }
        k = NoSignExtend(dvifp, 1);
        GetBytes(dvifp, ParamStr, k);
    }
    
    if (Reverse) {
      current_page_phy = NumOfPages; // letzte Seite
    }
    else {
      current_page_phy = 1; // erste Seite
    }
        
    hconv = DoConv(num, den, hconvresolution);
    vconv = DoConv(num, den, vconvresolution);
    alpha = (((double)den / 7227.0) / 0x100000) * (25400000.0 / (double) num) ;
    
    if (landscape) {
      /*
       * Die paper_height und paper_width werden in ReadPostAmble() gesetzt.
       * Bei Landscape muss das aber umgeaendert werden. Dort muss der voffset
       * an die rechte Seite gesetzt werden und der hoffset nach oben.
       * Also wird nun noch etwas an den Werten nachtraeglich rumgefummelt.
       * Direkt in ReadPostAmble() geht's leider nicht, da dvihand.c *keine*
       * ShowDVI/DVIprint Abhaengigkeiten bekommen soll.
       * Bei paper_heigh kommt voff weg und hoff dazu,
       * bei paper_width kommt (1in-hoff) dazu und (1in-voff) weg.
       */
      
      paper_height += hoffset - voffset;
      //paper_width  += (hconvresolution - hoffset) - (vconvresolution - voffset);
      paper_width  -= hoffset;	// das wurde schon frueher mal addiert
      
      if (!twopage) paper_width += voffset;
    }

    if (twopage) {
      // linke Seite + rechte Seite + Mitte + unterer Rand (fix 1in) + oberer Rand (voff)
      InitBitmap(paper_height, 2 * paper_width + moffset + vconvresolution + voffset);
    }
    else {
      InitBitmap(paper_height, paper_width);
    }

#ifdef PROTOCOL
    protocol ();
#endif

#if 0 /* das war meine Version (hes)
    if (hconvresolution <= 599)		hmaxdrift = hconvresolution / 100 ;
    else if (hconvresolution < 1199)	hmaxdrift = hconvresolution / 200 + 3 ;
    else				hmaxdrift = hconvresolution / 400 + 6 ;

    if (vconvresolution <= 599)		vmaxdrift = vconvresolution / 100 ;
    else if (vconvresolution < 1199)	vmaxdrift = vconvresolution / 200 + 3 ;
    else				vmaxdrift = vconvresolution / 400 + 6 ;

    thinspace      = (long)(0.025*hconvresolution*hconv) ; /* 0.025 inches */
    vertsmallspace = (long)(0.025*vconvresolution*vconv) ; /* 0.025 inches */
#else	/* das ist Bernd's Version */
      if (hconvresolution < 100)	hmaxdrift = 0;
      else if (hconvresolution < 200)	hmaxdrift = 1;
      else				hmaxdrift = 2;

      if (vconvresolution < 100)	vmaxdrift = 0;
      else if (vconvresolution < 200)	vmaxdrift = 1;
      else				vmaxdrift = 2;

      /* Setup initial spaces for 10pt Font: */
		/* wordspace  =approx.  0.2 * 10pt =  0.027674 inches */
      thinspace      =  (long)(0.027674 * hconvresolution * hconv);
		/* -backspace =approx. -0.9 * 10pt = -0.124533 inches */
      backspace      = -(long)(0.124533 * hconvresolution * hconv);
		/* vertspace  =approx.  0.8 * 10pt =  0.110696 inches */
      vertsmallspace =  (long)(0.110696 * vconvresolution * vconv);
#endif

    PrepareHardcopies();

    /*	Hier werden nun einzelne Seiten gedruckt.	*/

    h = v = w = x = y = z = 0;
    hh = vv = 0;
    sp = 0;


    while (TRUE) {

     command=NoSignExtend(dvifp, 1);

     if (command >= SETC_000 && command <= SETC_127) {
      if (!SkipMode) { 
        SetChar((long) command, command);
       } 
     }
     else {
      if (command >= FONT_00 && command <= FONT_63) {
	if (!SkipMode) {
          SetFntNum((long) (command - FONT_00));
        } 
      }
      else {
       if (command <= POP) {
        switch (command)  {
         case SET1:case SET2:case SET3:case SET4:
            val = NoSignExtend(dvifp, command-SET1+1);
            if (!SkipMode) SetChar(val, command);
            break;

         case SET_RULE:
            val = NoSignExtend(dvifp, 4);
            val2 = NoSignExtend(dvifp, 4);
            if (!SkipMode) SetRule(val, val2, 1);
            break;

         case PUT1:case PUT2:case PUT3:case PUT4:
            val = NoSignExtend(dvifp,command-PUT1+1);
            if (!SkipMode) SetChar(val, command);
            break;

         case PUT_RULE:
            val = NoSignExtend(dvifp, 4);
            val2 = NoSignExtend(dvifp, 4);
            if (!SkipMode) SetRule(val, val2, 0);
            break;

         case NOP:
            break;

         case BOP:
            cpagep = DVIftell(dvifp) - 1;

	    if (twopage) {
              if (leftpage) {

	        leftpagep = cpagep;	/* for twopage mode */
	        
	        // die linke Seite ist die unterere 
	        if (landscape) {
	          OffsetBitmap_X = vconvresolution; // map.width - 2 * paper_width - moffset - voffset;
	          OffsetBitmap_Y = hoffset;
	        }
	        else {
	          OffsetBitmap_X = hoffset;
	          OffsetBitmap_Y = voffset;
	        }
	      }
	      else {
	        // rechte Seite
	        if (landscape) {
	          OffsetBitmap_X = vconvresolution + paper_width + moffset; // map.width - paper_width - voffset;
  	          OffsetBitmap_Y = hoffset;
	        }
	        else {
	          OffsetBitmap_X = paper_width + moffset;
  	          OffsetBitmap_Y = voffset;
	        }
	      }
	    }
	    else {
	      // !twopage

	      if (landscape) {
	        OffsetBitmap_X = hconvresolution;
	        OffsetBitmap_Y = hoffset;
	      }
	      else {
	        OffsetBitmap_X = hoffset;
	        OffsetBitmap_Y = voffset;
	      }
	    }

	    // printf("map w: %ld, pw: %ld, OX: %ld, OY: %ld, h: %ld, v: %ld, m: %ld\n", map.width, paper_width, OffsetBitmap_X, OffsetBitmap_Y, hoffset, voffset, moffset);

            for (i=0; i<=9; i++)
                count[i] = NoSignExtend(dvifp, 4);
            ppagep = NoSignExtend(dvifp, 4);

            CurrentPage = count[0];

            h = v = w = x = y = z = 0;
            hh = vv = 0;
            sp = 0;
            
            {
              long TmpPage = (PhyPageNumbers) ? current_page_phy : CurrentPage;
              
              SkipMode = FALSE;
              
              if (TmpPage < FirstPage || TmpPage > LastPage) {
                SkipMode = TRUE;
              }
              else {
                if (twopage) {
                  // zwei Seiten auf ein Blatt...also (un)gerade hat eine etwas andere Bedeutung
                  int tp = TmpPage & 3;

                  switch (print_page_numbers) {
                    case 1:					/* nur ungerade Seiten */
                      if (tp == 0 || tp == 3) SkipMode = TRUE;
                      break;
                    case 2:					/* nur gerade Seiten */
                      if (tp == 1 || tp == 2) SkipMode = TRUE;
                      break;
                  }
                }
                else {
                  switch (print_page_numbers) {
                    case 1:					/* nur ungerade Seiten */
                      if (!(TmpPage & 1)) SkipMode = TRUE;
                      break;
                    case 2:					/* nur gerade Seiten */
                      if (TmpPage & 1) SkipMode = TRUE;
                      break;
                  }
                }
              }
            }
 
            if( !SkipMode ) 
             {
              if( !g_quiet && Pass==0)
               { 
                if (!usegui) MessageStr("[%ld]", count[0] );		// im GUI ist das uninteressant!
		MUISetWorkCurPage((PhyPageNumbers) ? current_page_phy: count[0]);

                if (!is_first_print_page && !(twopage && !leftpage)) {
                  FormFeed();
                }
                else {
                  is_first_print_page = FALSE;
                }
               }
             }
            break;

         case EOP:
            i = 1;

            if (!SkipMode) {
            
              if (twopage && leftpage) {
                // die rechte Seite muss noch aufgebaut werden, bevor es was zu drucken gibt 

                leftpage = FALSE;

                // hier muesste noch der Offset fuer die rechte Seite gesetzt werden!
                // Nachtrag: Dies wird nun in BOP gemacht!
                // ABER: Es muss auch die linke Seite gedruckt werden, wenn es die letzte ist!
                // Wie testen wir, ob das nun die letzte Seite ist??
                // Antwort: In POST wird getestet, ob wir auf der rechten Seite sind...
                break;
              }
              else {
                leftpage = TRUE;
              }

              if ((i=PrintPage()) == 0) {	// RETURN == 1 : fertig, == 0 : weitere Durchgänge nötig
                 Pass = 1;		// noch nicht fertig, weitere Durchgaenge folgen
                 // ACHTUNG: Pass ist hier *lokal* und nimmt nur die Werte 0 und 1 an!
                 // Die eigentliche Pass Anzahl wird nur in bitmap.c bestimmt!!!
                 if (twopage) DVIfseekSet(dvifp,(long) leftpagep);
                 else         DVIfseekSet(dvifp,(long) cpagep);
              }
            }

            if (i != 0) {
               Pass = 0;
               
               if (Reverse) current_page_phy--;
               else         current_page_phy++;
               
               if (!SkipMode) NrOfPagesToPrint--;	// wieder eine Seite gedruckt

		/*
		 *  War's das, oder sollen noch mehr Seiten gedruckt werden?
		 *  Abbruch-Abfrage, damits schneller geht.
		 */
               if ((NrOfPagesToPrint == 0) || 
		   (Reverse && PhyPageNumbers && current_page_phy < FirstPage) ||
		   (!Reverse && PhyPageNumbers && current_page_phy > LastPage)) {

                 if (last_form_feed) {
                   FormFeed();
                 }
 	         EndHardcopies();
                 AbortRun(0);
                 /* never reached */
               }

               if( Reverse ) 
                { 
                  if (ppagep > 0L)
                    DVIfseekSet(dvifp, ppagep);
                  else {
                    if (last_form_feed) {
                      FormFeed();
                    }
		    EndHardcopies();
                    AbortRun(0);
                  }
                }
            }   
            break;

         case PUSH:
            if (sp >= STACKSIZE)
                Fatal(5, MSG_STACK_OVER);
            stack[sp].hh = hh;
            stack[sp].vv = vv;
            stack[sp].h  = h;
            stack[sp].v  = v;
            stack[sp].w  = w;
            stack[sp].x  = x;
            stack[sp].y  = y;
            stack[sp].z  = z;
            sp++;
            break;

         case POP:
            --sp;
            if (sp < 0)
                Fatal(5, MSG_STACK_UNDER);
            hh = stack[sp].hh;
            vv = stack[sp].vv;
            h  = stack[sp].h;
            v  = stack[sp].v;
            w  = stack[sp].w;
            x  = stack[sp].x;
            y  = stack[sp].y;
            z  = stack[sp].z;
            break;

         default:
/*
 *              ** Fatal(5, "%d is an undefined command", command);
 */
		if (!Pass)
		 {
 		  Warning(MSG_INCOMPLETE_DVI);
 		 }
                //i = 1;
                if (!SkipMode)
                 {
                  if ((i=PrintPage()) == 0)
                   {
                    Pass = 1;
                    DVIfseekSet(dvifp,(long) cpagep);
                   }
                  else
                   {
                    if (last_form_feed) {
                      FormFeed();
                    }
		    EndHardcopies();
                    AbortRun(1);
                   }
                 }
                else
                 {
                  if (last_form_feed) {
                    FormFeed();
                  }
		  EndHardcopies();
                  AbortRun(1);
                 }
                break;
         }	/* end switch */
        }	/* end if <= POP */
	else {

	 switch (command) {
          case RIGHT1:
	  case RIGHT2:
	  case RIGHT3:
	  case RIGHT4:
            val = SignExtend(dvifp,command-RIGHT1+1);
            if (!SkipMode) MoveOver(val);
            break;

          case W0:
            if (!SkipMode) MoveOver(w);
            break;

          case W1:
	  case W2:
	  case W3:
	  case W4:
            w = SignExtend(dvifp,command-W1+1);
            if (!SkipMode) MoveOver(w);
            break;

          case X0:
            if (!SkipMode) MoveOver(x);
            break;

          case X1:
	  case X2:
	  case X3:
	  case X4:
            x = SignExtend(dvifp,command-X1+1);
            if (!SkipMode) MoveOver(x);
            break;

          case DOWN1:
	  case DOWN2:
	  case DOWN3:
	  case DOWN4:
            val = SignExtend(dvifp,command-DOWN1+1);
            if (!SkipMode) MoveDown(val);
            break;

          case Y0:
            if (!SkipMode) MoveDown(y);
            break;

          case Y1:
	  case Y2:
	  case Y3:
	  case Y4:
            y = SignExtend(dvifp,command-Y1+1);
            if (!SkipMode) MoveDown(y);
            break;

          case Z0:
            if (!SkipMode) MoveDown(z);
            break;

          case Z1:
	  case Z2:
	  case Z3:
	  case Z4:
            z = SignExtend(dvifp,command-Z1+1);
            if (!SkipMode) MoveDown(z);
            break;

          case FNT1:
	  case FNT2:
	  case FNT3:
	  case FNT4:
            if (!SkipMode) {
                SetFntNum(NoSignExtend(dvifp,command-FNT1+1));
                }
            break;

          case XXX1:
	  case XXX2:
	  case XXX3:
	  case XXX4:
		{ unsigned long len = NoSignExtend(dvifp, command-XXX1+1);
		  if (SkipMode) {
		    SkipDoSpecial(dvifp, len);
		  }
		  else {
		    DoSpecial(dvifp, len);
		  }
		}
		break;
#ifdef OLD_DOSPECIAL
            k = NoSignExtend(dvifp,command-XXX1+1);
            GetBytes(dvifp, ParamStr, k);
            if (!SkipMode) {
	      DoSpecial(ParamStr, k);
	    }
            break;
#endif
 
          case FNT_DEF1:
	  case FNT_DEF2:
	  case FNT_DEF3:
	  case FNT_DEF4:
            k = NoSignExtend(dvifp, command-FNT_DEF1+1);
            if (PreLoad   || HasBeenRead(k)  )
            {
                SkipFontDef ();
            }
            else
            {
                ReadFontDef (k, !SkipMode);
            }
            break;

          case PRE:
            Fatal(5, MSG_PRE_IN_FILE);
            break;

          case POST:
            if (!leftpage && twopage) {
              // linke Seite wurde erstellt, File ist zu Ende --> linke Seite muss noch gedruckt werden!
              if (PrintPage() == 0) {
                 Pass = 1;		// noch nicht fertig, weitere Durchgaenge folgen (??)
                 // ACHTUNG: Pass ist hier *lokal* und nimmt nur die Werte 0 und 1 an!
                 // Die eigentliche Pass Anzahl wird nur in bitmap.c bestimmt!!!
                 leftpage = TRUE;	// und wieder die linke Seite...
                 DVIfseekSet(dvifp,(long) leftpagep);
		 break;
              }
            }
            if (last_form_feed) {
              FormFeed();
            }
	    EndHardcopies();
            AbortRun(0);
            break;

          case POST_POST:
            Fatal(5, MSG_POST_IN_FILE);
            break;

          default:
                Fatal(5, MSG_UNDEFINED_DVI_COMMAND, command);
            break;

         }	/* end switch */
        }	/* end else <= POP */
      }		/* end else font */
     }		/* end else char */
    } 		/* while TRUE */

}


#ifndef LONG_ARGS
/*-->PrintHelp*/
/*********************************************************************/
/***************************** PrintHelp *****************************/
/*********************************************************************/

static void PrintHelp(void)
{
      Message(NULL);
#ifdef AMIGA
      Warning("(c)Copyright 1990-91, (hes/rbs) , All rights reserved. %s",__DATE__);
#else
      Warning("(c)Copyright 1988-90, (hes/rbs) , All rights reserved. %s",__DATE__);
#endif
      Warning("usage: %s [-?] [-a fontarea] [-b bytes] [-m bytes] [-1] [-2]",g_progname);
#ifdef AMIGA
      Warning("\t\t[-f page] [-t page] [-z dpi] [-o {0|1|2|3}] [-O density");
      Warning("\t\t[-d {0|1|2|3|4|5|6|7|8|9}] [-u] [-g] [-i] [-x] [-r] [-p]");
      Warning("\t\t[-q] [-e bytes] [-l] [-s] [-S] [-h offset] [-v offset]");
      Warning("\t\t[-T] [-> file]");	/* only temporary */
      Warning("\t\tdvifile");
#else
      Warning("\t\t[-f page] [-t page] [-z dpi] [-o {0|1|2|3}] [-d {0|1|2|3|4|5|6|7|8|9}]");
      Warning("\t\t[-u] [-g] [-x] [-r] [-p] [-q] [-l] [-s]");
      Warning("\t\t[-h offset] [-v offset] dvifile");
#endif
      Warning("\t\t  where offset = real number{pt|pc|in|bp|cm|mm|dd|cc}");
      Warning("\t-?   this help,");
#ifdef NAJA
      Warning("\t-c   the authors,");         
#endif
      Warning("\t-a   additional directory for the fontlibs and pk-files,");         
      Warning("\t-b   size of the memory for the fonts (def.: %ld bytes),",FONTMEMSIZE);
      Warning("\t-m   maximum size of the memory for the bitmap (def.: %ld bytes),",MAXBITMAPSIZE);
#ifdef AMIGA
      Warning("\t-e   size of the two printer-buffers (def.: %ld bytes),",BUFFLEN);
#endif
      Warning("\t-f   start at page,");
      Warning("\t-t   stop at page,");
      Warning("\t-1   print only the odd page numbers,");
      Warning("\t-2   print only the even page numbers,");
      Warning("\t-h   horizontal offset (def.: %.2fin),",hoffset_in_fix);
      Warning("\t-v   vertical offset (def.: %.2fin),",voffset_in_fix);
/**   Warning("\t-n   number of copies,"); **/
      Warning("\t-d   printer type, one of the following numbers:");
#ifdef ATARI
      Warning("\t\t%d: Atari Laser Printer SLM 804",SLM804);
#else
      Warning("\t\t%d: generic (preferences) printer",GENERIC_PRINTER);
      Warning("\t\t    (use -O to set your printer resolution/density)");
#endif
      Warning("\t\t%d: NEC P6/P7 (24 pins)",NEC_P6);
      Warning("\t\t%d: NEC P6/P7 (24 pins) (no 'ESC $' skips) ",NEC_P6_NOO);
      Warning("\t\t%d: HP DeskJet",DESKJET);
      Warning("\t\t%d: HP DeskJet (only PCL level III)",DESKJET_NOO);
      Warning("\t\t%d: Epson FX (9 pins)",EPSON_X);
      Warning("\t\t%d: Epson FX (9 pins) (no 'ESC $', with spaces)",EPSON_X_NO);
      Warning("\t\t%d: Epson FX (9 pins) (no 'ESC $', only gfx)",EPSON_X_NOO);
      Warning("\t\t%d: Epson LQ (24 pins)",EPSON_LQ);
      Warning("\t\t%d: Epson LQ (24 pins) (no 'ESC $')",EPSON_LQ_NOO);
      Warning("\t\tdefault is: %d",DEFAULT_PRINTER);
      Warning("\t-o   printing quality (0: high quality, 1: draft),");
      Warning("\t\tonly for HP DeskJet (2: cheap hq, 3: cheap draft),");
      Warning("\t\tdefault is: %d",DEFAULT_QUALITY);
#ifdef AMIGA
      Warning("\t-O   printing quality for the generic printer (density 1-7),");
      Warning("\t\tdefault is: entry of your preferences");
#endif
      Warning("\t-u   print bidirectional (default unidirectional),");
      Warning("\t-g   print in landscape modus (only for HP DeskJet and NEC P6/P7),");
#ifdef AMIGA
      Warning("\t-i   print pages to an IFF-file");
#endif
      Warning("\t-x   no form feed at the end of last page,");
      Warning("\t-r   print in reverse order,");
      Warning("\t-z   resolution (of the bitmap) in dpi (e.g. -z 100 or -z 180/360),");
      Warning("\t\tthis doesn't set the printer resolution!! (use -d option)");
      Warning("\t-p   preload fonts,");
      Warning("\t-q   quiet,");
      Warning("\t-s   print statistics into logfile,");
#ifdef AMIGA
      Warning("\t-S   same as -s, but close the logfile after every line (for debug),");
      Warning("\t-T   turbo-mode for very fast printers (needs under 1.3 puffer.device),");
      Warning("\t\t(The puffer.device is not jet finished!)");
      Warning("\t->   output to file not to the printer,");
#endif
      Warning("\t-l   no logfile.");
}

static void not_a_valid_integer(void)
{
   PrintHelp();
   fprintf(stderr,"** Argument is not a valid (long) integer\n"); 
   AbortRun(5);
}

static void offset_to_inch(double *inch, float *offset, char *einh)
{
  double temp;

  /** einh == pt|pc|in|bp|cm|mm|dd|cc  !! einh : word alignment !! **/
  switch (*((short*)einh)) {
    case 0x7074:		/* pt */
	temp = (double)*offset / 72.27;
	break;
    case 0x7063:		/* pc */
	temp = (double)*offset / 6.0225;
	break;
    case 0x696e:		/* in */
	temp = (double)*offset;
	break;
    case 0x6270:		/* bp */
	temp = (double)*offset / 72.0;
	break;
    case 0x636d:		/* cm */
	temp = (double)*offset / 2.5322;
	break;
    case 0x6d6d:		/* mm */
	temp = (double)*offset / 25.322;
	break;
    case 0x6464:		/* dd */
	temp = (double)*offset / 67.3467;
	break;
    case 0x6363:		/* cc */
	temp = (double)*offset / 5.6146;
	break;
    default    :
	PrintHelp();
	fprintf(stderr,"** Argument '%2s' is not a valid unit\n",einh);
	AbortRun(5);
	break;
  }
  *inch = temp;
}


/*-->DecodeArgs*/
/*********************************************************************/
/***************************** DecodeArgs ****************************/
/*********************************************************************/

static void
DecodeArgs(int argc, char *argv[])
{
    int argind;             /* argument index for flags              */
    char curarea[STRSIZE];  /* current file area                     */
    char curname[STRSIZE];  /* current file name                     */
    char *tcp, *tcp1;       /* temporary character pointers          */
    char einh[4];	    /* Einheit  !! word alignment !!         */
    float offset;

    /* set defaults */
    hoffset_in_fix = HOFFSET_IN;
    voffset_in_fix = VOFFSET_IN;

    if (argc == 1) {
      PrintHelp();
      AbortRun(0);
    }

    argind = 1;
    while (argind < argc) {
        tcp = argv[argind];
        if (*tcp == '-')
            switch(*++tcp) {

		case '?':
		   PrintHelp();
		   AbortRun(0);
		   break;	/* never reached */
		case 'c':
		    g_authors = 1;
   		    break;
                case 'a':       /* a selects different pxl font area */
                    PXLpath = argv[++argind];
                    break;
                    
                case 'b':
                    if( ++argind >= argc || 
                        sscanf(argv[argind], "%ld", &fontmemsize) != 1 )
                          {
			   not_a_valid_integer();
                          }
                    break;
                    
#ifdef DEBUG
                case 'D':       /* d selects DeBug output */
                    DeBug = TRUE;
                    break;
#endif

                case 'f':       /* next arg is starting pagenumber */
                    if( ++argind >= argc || sscanf(argv[argind], "%d", &FirstPage) != 1 ) {
			   not_a_valid_integer();
                    }
                    break;

		case '1':	/* print only the odd page numbers */
		    print_page_numbers = 1;
		    break;

		case '2':	/* print only the even page numbers */
		    print_page_numbers = 2;
		    break;

                case 'z':       /* next arg is dpi */
		    { char *ptr;
		      int res;
		      
		      if (++argind >= argc) {
			   not_a_valid_integer();
		      }
		      if ((ptr = strchr(argv[argind],'/')) != NULL) {
		        /* -z hor/vert */
		        *ptr = '\0';
		        if (sscanf(argv[argind], "%d", &res) != 1 ) {
			   not_a_valid_integer();
                        }
                        /* resolution = bleibt 0 um xx/yy von dd unterscheiden zu koennen! */
			hconvresolution = res;
		        if (sscanf(ptr+1, "%d", &res) != 1 ) {
			   not_a_valid_integer();
                        }
                        vconvresolution = res;
		      }
		      else {
		        if (sscanf(argv[argind], "%d", &res) != 1 ) {
			   not_a_valid_integer();
                        }
                        resolution = hconvresolution = vconvresolution = res;
		      }
                    }
                    break;
                
                case 'h':       /* next arg is value for horizontal offset */
                    if( ++argind >= argc || sscanf(argv[argind], "%f%2s", &offset, einh) != 2 ) {
			PrintHelp();
			fprintf(stderr,"** Argument is not a valid offset\n"); 
			AbortRun(5);
                    }
                    offset_to_inch(&hoffset_in_fix,&offset,einh);
                    break;
                
                case 'l':       /* l prohibits logging of errors */
                    g_logging = -1;
                    break;

                case 'm':       /* next arg is maxbitmapsize */
                    if( ++argind >= argc || sscanf(argv[argind], "%ld", &maxbitmapsize) != 1 ) {
			   not_a_valid_integer();
                    }
                    if (maxbitmapsize != 0L && maxbitmapsize < MINBITMAPSIZE) {
		      PrintHelp();
		      Warning("** not a valid value, minimum is %ld or 0 for unlimited size.",
				MINBITMAPSIZE);
		      AbortRun(5);
                    }
                    break;    

#ifdef NOT_YET_IMPLEMENTED
                case 'n':       /* next arg is number of copies to print */
                    if( ++argind >= argc || sscanf(argv[argind], "%d", &ncopies) != 1 ) {
			   not_a_valid_integer();
                    }
                    break;    
#endif

                case 'o':       /* next arg is quality for printer output */
                    if( ++argind >= argc || sscanf(argv[argind], "%d", &draft) != 1 ) {
			   not_a_valid_integer();
                    }
                    if (!(draft == HIGH_Q || draft == DRAFT ||
			  draft == HIGH_Q_CHEAP || draft == DRAFT_CHEAP)) {
                      fprintf(stderr,"** -o %d is not in [0,3]\n", draft);
                    }
                    break;    

                case 'O':       /* next arg is quality for printer output */
                    if( ++argind >= argc || sscanf(argv[argind], "%d", &o_density) != 1 ) {
			   not_a_valid_integer();
                    }
                    if (!(o_density>0 && o_density<8)) {
                      fprintf(stderr,"** -O %d is not in [1,7]\n", o_density);
                    }
                    break;    

                case 'd':       /* next arg is the printer-type */
                    if( ++argind >= argc || sscanf(argv[argind], "%d", &printer_type) != 1 ) {
			not_a_valid_integer();
                    }
#ifdef ATARI
                    if (!(printer_type == NEC_P6 || printer_type == NEC_P6_NOO ||
			  printer_type == DESKJET || printer_type == DESKJET_NOO ||
			  printer_type == EPSON_X || printer_type == EPSON_X_NOO || printer_type == EPSON_X_NO ||
			  printer_type == EPSON_LQ || printer_type == EPSON_LQ_NOO ||
			  printer_type == SLM804 )) {
                      fprintf(stderr,"** -d %d is not in [0-%d]\n",printer_type,HIGHPRNTYPES);
                      AbortRun(5);
                    }
#else
                    if (!(printer_type == NEC_P6 || printer_type == NEC_P6_NOO ||
			  printer_type == DESKJET || printer_type == DESKJET_NOO ||
			  printer_type == EPSON_X || printer_type == EPSON_X_NOO || printer_type == EPSON_X_NO ||
			  printer_type == EPSON_LQ || printer_type == EPSON_LQ_NOO ||
			  printer_type == GENERIC_PRINTER)) {
                      fprintf(stderr,"** -d %d is not in [0-%d]\n",printer_type,HIGHPRNTYPES);
                      AbortRun(5);
                    }
#endif
                    break;

                case 'u':       /* print bidirectional */
                    unidirect = 0;
                    break;

                case 'p':       /* p enables pre-font loading */
                    PreLoad = TRUE;
                    /* Reverse = FALSE; */   /* must then process in forward order */
                    break;

                case 'q':       /* quiet operation */
                    g_quiet = TRUE;
                    break;

                case 'r':       /* process pages in reverse order */
                    Reverse = TRUE;
                    PreLoad = TRUE;
                    break;

                case 's':       /* print statistics */
                    Stats = 1;
                    break;
                     
                case 'S':       /* print statistics (and close the file) */
                    Stats = 2;
                    break;
                     
                case 'g':       /* print in landscape modus */
                    landscape = TRUE;
                    full_page_in_ram = TRUE;
                    break;

                case 'x':       /* no form feed at the last page */
                    last_form_feed = FALSE;
                    break;
                     
                case 't':       /* next arg is ending pagenumber */
                    if( ++argind >= argc || sscanf(argv[argind], "%d", &LastPage) != 1 ) {
			   not_a_valid_integer();
                    }
                    break;
                    
                case 'v':       /* next arg is value for vertical offset */
                   if( ++argind >= argc || sscanf(argv[argind], "%f%2s", &offset, einh) != 2 ) {
			PrintHelp();
			fprintf(stderr,"** Argument is not a valid offset\n"); 
			AbortRun(5);
                    }
                    offset_to_inch(&voffset_in_fix,&offset,einh);
                    break;
                
#ifdef AMIGA                    
                case 'e':       /* size of the printer-buffer */
                    if( ++argind >= argc || sscanf(argv[argind], "%d", &bufflen) != 1 ) {
			   not_a_valid_integer();
                    }
                    break;
                     
                case 'i':       /* print to IFF file */
                    iffprint = TRUE;
                    full_page_in_ram = TRUE;
                    break;    

                case 'T':       /* TURBO Mode */
                    turbo_mode = TRUE;
                    break;

                case '>':       /* save output to a file */
		    output_to_file = TRUE;
		    output_file_name = strdup(argv[++argind]);
                    break;
#endif
                    
                default:
		    PrintHelp();
                    fprintf(stderr,"** %c is not a legal flag\n", *tcp);
		    AbortRun(5);
                }

        else  
         {
            tcp = strrchr(argv[argind], 
#ifdef ATARI 
                                      '\\'    /* split into directory + file name */
#else
                                      '/'    /* split into directory + file name */
#endif
                        );
            if (tcp == NULL)  {
                curarea[0] = '\0';
                tcp = argv[argind];
                }
            else  {
                strcpy(curarea, argv[argind]);
                curarea[tcp-argv[argind]+1] = '\0';
                tcp += 1;
                }
        
            strcpy(curname, tcp);
            tcp1 = strrchr(curname, '.');   /* split into file name + extension */
            if (tcp1 == NULL) {
                strcpy(rootname, curname);
                strcat(curname, ".dvi");
                }
            else {
                *tcp1 = '\0';
                strcpy(rootname, curname);
                *tcp1 = '.';
                }
        
            strcpy(filename, curarea);
            strcat(filename, curname);
        
            if ((dvifp=OpenDVI(filename, MaxDviBufSize)) == NULL)  
             {
              fprintf(stderr,"%s: can't find DVI file \"%s\"\n\n", g_progname, filename);
              AbortRun(5);
             }

	    strcpy(g_Logname, DVIPRINT_LOGFILE);

            if (g_logging==1)
              if ((g_logfp = fopen(g_Logname,"w")) == NULL)
               {
                fprintf(stderr,"\n");
                fprintf(stderr,"%s: can't open LOG-file \"%s\"\n\n", g_progname, g_Logname);
                AbortRun(1);
               }
                
            break;
        }
        argind++;
        }

    if (dvifp == NULL)  {
	fprintf(stderr, "** found no dvifile!\n");
	AbortRun(5);
   }
   if (printer_type != DESKJET && printer_type != DESKJET_NOO && 
		(draft == HIGH_Q_CHEAP || draft == DRAFT_CHEAP)) {
	fprintf(stderr, "** cheap modus only allowed for HP DeskJet!\n");
	AbortRun(5);
   }
#if 0
   if (printer_type == DESKJET_NOO && draft != HIGH_Q) {
   	fprintf(stderr, "** this print modus works only in high quality modus!\n");
	AbortRun(5);
   }
#endif
   if ((printer_type == EPSON_X || printer_type == EPSON_X_NO || printer_type == EPSON_X_NOO || 
#ifdef ATARI
	printer_type == SLM804
#else
	printer_type == GENERIC_PRINTER
#endif
	) && landscape) {
	fprintf(stderr, "** landscape modus don't work with this printer!\n");
	AbortRun(5);
   }
#ifdef AMIGA
   if (printer_type != GENERIC_PRINTER && o_density != 0) {
     fprintf(stderr, "*** -O option is only useful with the generic printer (-d 0)!\n");
   }
   if (iffprint) {
     if (turbo_mode) {
       fprintf(stderr, "*** print to IFF file in \"turbo\" mode is senseless!\n");
       AbortRun(5);
     }
#if 0
     if (output_to_file) {
       fprintf(stderr, "*** only one is possible: print to IFF file or redirection to a file!\n");
       AbortRun(5);
     }
#endif
   }
   if (output_to_file && turbo_mode) {
     fprintf(stderr, "*** output to a file in \"turbo\" mode is senseless!\n");
     AbortRun(5);
   }
   if (output_to_file && printer_type == GENERIC_PRINTER) {
     fprintf(stderr, "*** output to a file with generic-printer isn't possible!\n");
     fprintf(stderr, "    Use the 'cmd' utility.\n");
     AbortRun(5);
   }
   
#endif
}

#endif /* LONG_ARGS */
