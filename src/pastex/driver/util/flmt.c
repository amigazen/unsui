/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from util/flmt.c
*/
/**** flmt.c		(c) Georg Hessmann 11.02.90 		****/


#include "defines.h"

/* standard includes */
#include <stdio.h>
#include "globals.h"

#ifdef ANSI
#  include <stdlib.h>
#  include <string.h>
#  ifdef AMIGA
#    ifdef LATTICE
#      include <dos.h>
#    endif
#  endif
#  ifdef ATARI
#    include <tos.h>
#  endif 
#endif 

#include "flmt.h"
#include "globals.i"

#ifdef AMIGA
#  ifdef LATTICE
#    define perror(x)	poserr(x)
#  endif 
#endif 


#ifndef FALSE
#  define FALSE		0
#endif 
#ifndef TRUE
#  define TRUE		(!FALSE)
#endif 



/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



/********* lokal funktions ************/
	/* read the directory structure					*/
static int   freaddir			Args((union direntry *dir,
					      int version,
					      FILE *f));
	/* read a four byte number <hihi lohi hilo lolo>		*/
static int   freadlong			Args((long *buf,
					      FILE *f));
	/* read a two byte number <hi lo>				*/
static int   freadshort			Args((unsigned short *buf,
					      FILE *f));


#ifdef AZTEC_C
#pragma regcall( freaddir(a0,d0,a1) )
#pragma regcall( freadlong(a0,a1) )
#pragma regcall( freadshort(a0,a1) )
#endif


#ifdef OLDDD
/* open a flib and test the magic-number */
FILE *open_flib(char *name, char *mode, int *version)
{
  FILE *f;
  long magic;

  if ((f = fopen(name,mode)) == NULL) {
	Logging(MSG_CANT_OPEN_FONTLIB,name);
	return NULL;
  }
  if (!freadlong(&magic,f) || (magic != LIBMAGIC && magic != OLD_LIBMAGIC)) {
	fclose(f);
	Warning(MSG_NOT_A_FONTLIB,name);
	return NULL;
  }
  if (magic == LIBMAGIC) {
	*version = NEW_VERSION;
  }
  else {
	*version = OLD_VERSION;
	Logging(MSG_OLD_FONTLIB,name);
  }

  return f;
}
#endif

/* open a flib and test the magic-number */
FILE *open_flib(char *name, char *mode, int *version, short levels)
{
  FILE *f;
  long magic;

  if ((f = fopen(name,mode)) == NULL) {
	return NULL;
  }
  if (!freadlong(&magic,f) ||
	(magic != LIBMAGIC && magic != OLD_LIBMAGIC && magic != LNKMAGIC)) {
		fclose(f);
		return NULL;
  }
  if (magic == LNKMAGIC) {
	char link_name[DOSNAMESIZE], newname[DOSNAMESIZE], *ptr, *p;
	
	(void)fread(link_name,sizeof(char),DOSNAMESIZE,f);
	fclose(f);
	if (link_name[0] != '<') {
		return NULL;
	}
	ptr = strrchr(link_name,'>');
	if (ptr == NULL) {
		return NULL;
	}
	levels++;
	if (levels > MAXLINKLEVELS) {
		Warning(MSG_TOO_MANY_FONTLIB_LEVELS);
		return NULL;
	}
	*ptr = '\0';
	ptr = link_name;
	ptr++;
	strcpy(newname, name);
	/* is 'ptr' (target of the link) a relative path ? */
	if (
#ifdef AMIGA
	    strchr(ptr,':') == NULL
#else
# ifdef ATARI
	    !((*ptr & 0x40) == 0x40 && *(ptr + 1) == ':')
# else
	    *ptr != '/'
# endif
#endif
	    ) {
		/* if yes, take the dir of the link-file and append the target name */
		if ((p = strrchr(newname,'/')) == NULL) {
		  p = strchr(newname,':');
		  /* if the link-file has no dir -> ok, we are already in the right dir */
		}
		if (p != NULL) {
		  *(p+1) = '\0';
		  strcat(newname, ptr);
		  ptr = strcpy(link_name, newname);
		}
	}
	f = open_flib(ptr,mode,version,levels);
  }
  else {
	if (magic == LIBMAGIC) {
		*version = NEW_VERSION;
	}
	else {
		*version = OLD_VERSION;
	}
  }

  return f;
}

/* read the directory from the flib (file-pointer must be on the first dir) */
/* only this directory entries a correct where "where != 0" the others are unused */
int read_dir(FILE *f, struct dir *directory)
{
  long alloc;
  union direntry dir;
  struct dirlist *direntr, *old_direntry;
  int i, j, nr;

  if (!freadlong(&alloc,f)) {
	Warning(MSG_ERROR_READING_FONTLIB_DIR);
	return FALSE;
  }
  direntr = old_direntry = NULL;
  for (i=0, nr=0; i<alloc && !feof(f); i++) {
	if (!freaddir(&dir,directory->version,f)) {
		Warning(MSG_ERROR_READING_FONTLIB_DIR);
		return FALSE;
	}
	if ((directory->version == NEW_VERSION && dir.new.where != 0) ||	/* used entry */
		(directory->version == OLD_VERSION && dir.old.where != 0)) {
		nr++;
		direntr = (struct dirlist *)xmalloc(sizeof(struct dirlist));
		for (j=0; j<NEWFILENAMELEN; j++) {	/* clear the string */
			direntr->dirent.mname[j] = '\0';
		}
		if (old_direntry == NULL ) {
			directory->dirlist = direntr;
		}
		else {
			old_direntry->next = direntr;
		}
		if (directory->version == NEW_VERSION) {
			direntr->dirent = dir.new;
		}
		else {
			strncpy(direntr->dirent.mname,dir.old.mname,FILENAMELEN);
			direntr->dirent.size     = dir.old.size;
			direntr->dirent.where    = dir.old.where;
			direntr->dirent.checksum = 0;
		}
		old_direntry = direntr;
	}
  }
  if (direntr != NULL) {
	direntr->next = NULL;
  }
  directory->total    = nr;
  directory->alloc    = alloc;
  if (nr == 0) {
	directory->dirlist = NULL;
  }
  return TRUE;
}



struct dirlist *findmod (struct dir *directory, char *mname)
{ 
  struct dirlist *temp;

  /* find the module */
  for (temp = directory->dirlist; temp != NULL
	&& stricmp(temp->dirent.mname,mname) != 0; temp = temp->next);

  return temp;
}


/* read the directory structure				*/
static int freaddir(union direntry *dir, int version, FILE *f)
{
  if (version == OLD_VERSION) {
	if (fread(dir->old.mname,FILENAMELEN,1,f) != 1) {
		return FALSE;
	}
	dir->new.mname[FILENAMELEN] = '\0';
	if (!freadlong(&(dir->old.size),f)) {
		return FALSE;
	}
	if (!freadlong(&(dir->old.where),f)) {
		return FALSE;
	}
  }
  else {
	if (fread(dir->new.mname,1,NEWFILENAMELEN,f) != NEWFILENAMELEN) {
		return FALSE;
	}
	if (!freadshort(&(dir->new.checksum),f)) {
		return FALSE;
	}
	if (!freadlong(&(dir->new.size),f)) {
		return FALSE;
	}
	if (!freadlong(&(dir->new.where),f)) {
		return FALSE;
	}	
  }
  return TRUE;
}



/* read a four byte number <hihi lohi hilo lolo> */
static int freadlong(long *buf, FILE *f)
{
  unsigned char b[4];

  if (fread((char *)b,1,4,f) != 4) {
	return FALSE;
  }
  *buf = (long)(((unsigned long)b[0]) << 24) | (((unsigned long)b[1]) << 16) | 
			(((unsigned long)b[2]) << 8) | ((unsigned long)b[3]);

  return TRUE;
}

/* read a two byte number <hi lo> */
static int freadshort(unsigned short *buf, FILE *f)
{
  unsigned char b[2];

  if (fread((char *)b,1,2,f) != 2) {
	return FALSE;
  }
  *buf = (unsigned short) (((unsigned short)b[0]) << 8) | ((unsigned short)b[1]);

  return TRUE;
}
