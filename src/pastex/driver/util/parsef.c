/*
**	This file generated by localize 2.9 (AmigaDOS 2.1) from parsef.c
*/
/** parsef.c **/
#include "defines.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

#ifndef TEST
#include "globals.h"
#include "prhelp.h"
#include "globals.i"
#endif

#include "parsef.h"
#include "parsef.i"

int Parse_Control;
int Parse_Linenr;

static union arg_align {
	char buf[ARG_STRING_SIZE];
	long value;
};

static void parse_line(struct string_parse *parse, char *line);


/*
 * Fuer die locale-Library:
 *
 * Hier duerfen *nur* die MSG_#? Nummern eingebunden werden!
 * Achtung:
 * Es muss/sollte 'multiple-include' erlaubt sein!
 */
#include "local.i"

#undef  CATCOMP_ARRAY
#undef  CATCOMP_BLOCK
#undef  CATCOMP_STRINGS
#define CATCOMP_NUMBERS
#include "localstr.h"



#ifdef TEST

/* Beispieldatei:
init		27,42,2,LOW,HIGH
printer epson
; comment
hallo!
draft on
resolution	91,100,120; ja dann!
printer foo ; weiterer Kommentar
draft off;naja
*/

char maxline[512];

void __stdargs Fatal(int ret, char *fmt,...);
void __stdargs Warning(char *fmt,...);
void __stdargs Message(char *fmt,...);
void *xmalloc(unsigned);

void main(int argc, char *argv[]);

static void __stdargs kw_printer(struct string_parse *, char *line, char *arg1);
static void __stdargs kw_draft  (struct string_parse *, char *line, int on);
static void __stdargs kw_string (struct string_parse *, char *line);
static void __stdargs kw_ints   (struct string_parse *, char *line);

static struct string_parse printer_defs[] = {
	{
	"printer",
	"%s",
	(string_parse_function) kw_printer,
	PAF_1_ARG
	},
	{
	"draft",
	NULL,
	(string_parse_function) kw_draft,
	PAF_BOOL_ARG | PAF_1_ARG
	},
	{
	"init",
	NULL,
	(string_parse_function) kw_string,
	PAF_ARGS
	},
	{
	"resolution",
	NULL,
	(string_parse_function) kw_ints,
	PAF_ARGS
	},
	{
	NULL
	}
};

#endif /* TEST */


void parse_file(struct string_parse *parse, FILE *file, int parse_control)
{
  char line[ARG_MAXLINE];
  line[ARG_MAXLINE-1] = '\0';
  Parse_Linenr = 0;
  Parse_Control = parse_control & ~(PAC_END|PAC_END_SEARCH);

  while(fgets(line,ARG_MAXLINE-1,file) != NULL && !(Parse_Control & PAC_END)) {
    char *s;
    s = strrchr(line,'\n');
    if (s != NULL) *s = '\0';

    s = strchr(line,';');		/* skip comment, koennte auch	*/
    if (s != NULL) *s = '\0';		/* von Flags abhaengig sein.	*/

    Parse_Linenr++;
    parse_line(parse,line);
  }
}


static void parse_line(struct string_parse *parse, char *line)
{
  while (*line == ' ' || *line == '\t') line++;
  if (*line == '\0') {		/* empty line */
    return;
  }

  for (; parse->paf_function; parse++) {
    if (parse->paf_flags & PAF_NOKEY) {
      /* let the function do everything */
      (*parse->paf_function) (parse, line);
      if (Parse_Control & PAC_END_SEARCH) {
	Parse_Control &= ~PAC_END_SEARCH;
        return;		/* allows for local control	*/
      }
      else continue;	/* continue keyword search	*/
    }
    else {
      union arg_align arg1, arg2, arg3;		/* stack ?!	*/
      char format[MAX_FORMAT_LEN];		/* Na ja...	*/
      char key[MAX_KEY_LEN];
      int num_args;
      strcpy(format,"%13s ");			/*	(MAX_KEY_LEN)	*/
      if (parse->paf_flags & PAF_BOOL_ARG || (	/* allow BOOL w/o paf_format */
#ifndef USE_PAFARGS
	   PAF_ARGS != (parse->paf_flags & PAF_ARGS) &&
#endif
	   parse->paf_format)) {
	strcat(format, parse->paf_format ? parse->paf_format : "%s");
#if defined(HARDDEB)
	if (MAX_FORMAT_LEN <= strlen(format))
	  Fatal(20,"parse_file : format overflow!");
#endif
      }
      num_args = sscanf(line,
	format, key, (void *)&arg1, (void *)&arg2, (void *)&arg3);
      if (0 == num_args) {/*	looks like an empty line	*/
#if defined(HARDDEB)
	Message("Empty line");	/* how did we get this ? */
#endif
	return;
      }
      if (0 == stricmp(key,parse->paf_keyword)) {
        if (parse->paf_flags & PAF_ARGS) {
	  if (PAF_ARGS == (parse->paf_flags & PAF_ARGS)) {
	    /* let the function deal with all arguments	*/
	    (*parse->paf_function) (
	      parse,
	      line
#ifdef USE_PAFARGS
	      , (void *)&arg1, (void *)&arg2, (void *)&arg3
#endif
	      );
	  }
	  else if (num_args != (parse->paf_flags & PAF_ARGS)) {
	    Warning(MSG_PARSE_BAD_NR_ARGS,
	      Parse_Linenr, line);
	  }
	  else {
	    if (parse->paf_flags & PAF_BOOL_ARG) {
	      int true = -1;
	      /* on or off is needed here, you may change that behaviour */
	      if (0 == stricmp(arg1.buf,"on"))		true = 1;
	      else if (0 == stricmp(arg1.buf,"off"))	true = 0;
	      if (-1 != true) {
		(*parse->paf_function) (parse, line, true);
	      }
	      else Fatal(5,MSG_PARSE_BAD_ON_OFF,
		Parse_Linenr, arg1.buf);
	    }
	    else {
	      /* call the function	*/
	      (*parse->paf_function) (
		parse,
		line,
		(void *)&arg1, (void *)&arg2, (void *)&arg3);
	    }
	  }
	}
#if defined(HARDDEB) /* Waehrend Testphase benutzen */
	else Fatal(20,"parse_file : illegal flags!");
#endif
	return;
      }
    }
  }
  if (Parse_Control & PAC_END_UNKNOWN) {
    Warning(MSG_PARSE_CANT_PARSE,Parse_Linenr, line);
    Parse_Control |= PAC_END;
  }
  else Logging(MSG_PARSE_CANT_PARSE_IGNORE, Parse_Linenr, line);
}


/* non destructively skips the first field, which is known to be the
	keyword. */
char *args_line(char *line)
{
  while (!isspace(*line)) line++;
  while (isspace(*line))  line++;
  return line;
}

/*J:	strtok() benutzen?	*/
/*	zero out all separators, note that the buffer is modified	*/
char *split_line(char *line, char *separators)
{
  char *pos;
  for (pos = line; *pos; pos++) {
    char *stops;
    for (stops = separators; *stops; stops++) {
      if (*stops == *pos) {
        *pos='\0';
	break;
      }
    }
  }
  return pos;	/* future lastpos	*/
}

/*	start from a zero position	*/
char *nextpos_line(char *line, char *lastpos)
{
  while(line != lastpos && '\0' == *line) line++;
  return line;
}

/*	start from an argument		*/
char *endpos_line(char *line)
{
  while (*line) line++;
  return line;
}


/*	count the arguments		*/
unsigned fields_line(char *line, char *lastpos)
{
  char *pos = line;
  unsigned fields = 0;
  do {		/*	this shows how to parse the arguments	*/
    pos = nextpos_line(pos, lastpos);
    if (pos == lastpos) break;
    fields++;
    pos = endpos_line(pos);
  } while (1);
  return fields;
}


/*	this will parse a sequence of chars like printer commands	*/
char *parse_bytes(char *line)
{
  char *resarray, num;
  unsigned size;
  char *pos, *lastpos;

  lastpos = split_line(line," \t");
  size = fields_line(line,lastpos);

  /* the first position (corresponding to the former keyword)
	will held the number of arguments.	*/
  resarray = xmalloc(size * sizeof(char));
  
  /* first skip the keyword arg.	*/
  pos = nextpos_line(line,lastpos);
  if (pos == line) pos = nextpos_line(endpos_line(pos),lastpos);

  for (num = 0;
       pos != lastpos;
       pos= nextpos_line(endpos_line(pos),lastpos)) {
    int i;
    unsigned char c;

    /* I hope that this sscanf() works this way on all systems: */
    /* make sure there's no char left after the number. */
    if (0==strnicmp(pos, "0x", 2) && 1==sscanf(pos,"%x%c",&i,&c)) resarray[++num] = (char)i;
    else if (1==sscanf(pos,"%d%c",&i,&c))	resarray[++num] = (char)i;
    else if (0==stricmp(pos,"LOW"))	resarray[++num] = PP_INS_LOW;
    else if (0==stricmp(pos,"HIGH"))	resarray[++num] = PP_INS_HIGH;
    else if (0==stricmp(pos,"NR100"))	resarray[++num] = PP_INS_NR100;
    else if (0==stricmp(pos,"NR10"))	resarray[++num] = PP_INS_NR10;
    else if (0==stricmp(pos,"NR1"))	resarray[++num] = PP_INS_NR1;
    else if (0==stricmp(pos,"ESC"))	resarray[++num]	= ESC;
    else if (0==stricmp(pos,"FS"))	resarray[++num]	= FS;
    else if (sscanf(pos, "'%c'", &c) == 1) resarray[++num] = c; 
    /*else if (*(pos+1) == '\0')	resarray[++num] = *pos;*/
    else Message(MSG_PARSE_ILLEG_ARG,line, pos);
  }
  resarray[0] = num;
#if defined(HARDDEB)	/*	needed ?	*/
  if (num != size-1) Message("Data missing for keyword : %s.",line);
#endif
  return resarray;
}


#if 0 || defined(TEST)	/* function is not used */
/*	this will parse a sequence of integer values	*/
int *parse_ints(char *line)
{
  int *resarray, num;
  unsigned size;
  char *pos = line, *lastpos;

  lastpos = split_line(line," \t,");
  size = fields_line(line,lastpos);

  /* the first position (corresponding to the former keyword)
	will held the number of arguments.	*/
  resarray = xmalloc(size * sizeof(int));
  
  /* first skip the keyword arg.	*/
  pos = nextpos_line(line,lastpos);
  if (pos == line) pos = nextpos_line(endpos_line(pos),lastpos);

  for (num = 0;
       pos != lastpos;
       pos= nextpos_line(endpos_line(pos),lastpos)) {
    if (1 == sscanf(pos,"%d",&resarray[num+1])) num++;
    else Message("Erroneous argument %s with keyword %s.",pos,line);
  }
  resarray[0] = num;
  if (num < 1) Warning("At least one parameter required with keyword %s.",line);
#if defined(HARDDEB)
  if (num != size-1) Message("Data missing for keyword : %s.",line);
#endif
  return resarray;
}
#endif /* 0 || TEST */



#ifdef TEST

static void __stdargs kw_printer(struct string_parse *p, char *line, char *arg1)
{
  Message("Printer %s selected.",arg1);
}


static void __stdargs kw_draft(struct string_parse *p, char *line, int on)
{
  Message( on ? "draft selected." : "draft unselected.");
}


static void __stdargs kw_string(struct string_parse *p, char *line)
{
  char *stringarray = parse_bytes(line);
  int num;
  Message("Keyword %s: (%d printer chars)",line,stringarray[0]);
  for (num=0; num < stringarray[0]; num++)
    Message("\tchar %d=%x", num+1, stringarray[num+1]);
}


static void __stdargs kw_ints(struct string_parse *p, char *line)
{
  int *array = parse_ints(line);
  int num;
  Message("Keyword %s: (%d ints)",line,array[0]);
  for (num=0; num < array[0]; num++)
    Message("\tint %d=%d", num+1, array[num+1]);
}


void *xmalloc(unsigned size)
{
  void *here = malloc(size);
  if (!here) Fatal(10,"Memory allocation failure (size %u)!",size);
  return here;
}


void __stdargs Fatal(int ret, char *fmt,...)
{
  va_list argptr;

  va_start(argptr, fmt);
  /* sprintf() should return the number of chars output */
  vsprintf(&maxline[sprintf(maxline,"FATAL-- ")], fmt, argptr);
  va_end(argptr);
  puts(maxline);

  exit(ret);
}

void __stdargs Warning(char *fmt,...)
{
  va_list argptr;

  va_start(argptr, fmt);
  vsprintf(maxline, fmt, argptr);
  va_end(argptr);
  puts(maxline);
}

void __stdargs Message(char *fmt,...)
{
  va_list argptr;

  va_start(argptr, fmt);
  vsprintf(maxline, fmt, argptr);
  va_end(argptr);
  puts(maxline);
}


void main(int argc, char *argv[]) {
#if 1
  if (argc !=2) {
    Fatal(20,"Usage : parsef <filename>.");
  }
  else {
    FILE *file;
#if defined(HARDDEB)
    Message("File :\"%s\".",argv[1]);
#endif
    file = fopen(argv[1],"r");
    if (!file) Fatal(10,"Can't not open file \"%s\"!",argv[1]);
    else {
      parse_file(printer_defs, file);
      fclose(file);
    }
  }
#else
  int num, *array;
  array = parse_numbers("printer 1 2 3 4 5 6",PARSE_INTS);
  for (num = 0; num < array[0]; num++) {
    Message("%d = %d",num+1, array[num+1]);
  }
#endif
}

#endif /* TEST */
