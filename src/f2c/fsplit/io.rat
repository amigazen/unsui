#  io.rat - I/O primitives. This file is part of FSPLIT.
#
#    Copyright (C) 1994 Torsten Poulin
#    Email: torsten@diku.dk
#    Version of 25-JUL-94
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#  3. All advertising materials mentioning features or use of this software
#     must display the following acknowledgement:
#     This product includes software developed by Torsten Poulin.
#  4. The name of Torsten Poulin may not be used to endorse or
#     promote products derived from this software without specific prior
#     written permission.
#
#  This software is provided by Torsten Poulin "as is" and any
#  express or implied warranties, including, but not limited to, the
#  implied warranties of merchantability and fitness for a particular
#  purpose are disclaimed.  In no event shall Torsten Poulin be liable
#  for any direct, indirect, incidental, special, exemplary, or
#  consequential damages (including, but not limited to, procurement
#  of substitute goods or services; loss of use, data, or profits; or
#  business interruption) however caused and on any theory of
#  liability, whether in contract, strict liability, or tort
#  (including negligence or otherwise) arising in any way out of the
#  use of this software, even if advised of the possibility of such
#  damage.


include io.h
include fsplit.h


# Open file 'funit' according to 'mode':
#
#  MOLD       open the file 'name', fail if nonexistent.
#  MNEW       open the file 'name', create it if nonexistent.
#  MSCRATCH   open a temporary scratch file, name is ignored.
#
#  All other values of 'mode' are taken to mean unknown status.
#
#  Returns OK if the file was opened successfully, ERR otherwise.
#  The file is opened for both reading and writing.

integer function openf(funit, name, mode)
   integer funit, mode, ios
   character name*LINELEN, st*7

   if (mode == MSCRATCH)
      open (funit, iostat=ios, status='scratch', form='formatted')
   else
   {
      switch (mode)
      {
         case MOLD: st = 'old'
         case MNEW: st = 'new'
         default:   st = 'unknown'
      }
      open (funit, file=name, iostat=ios, status=st, form='formatted')
   } 

   if (ios != 0) return (ERR)
   else return (OK)
end


# Close file 'funit'

subroutine closef(funit)
   integer funit
   close (funit)
end


# Read a single line from 'funit' into 'buf'.
# At most max(length,LINELEN) characters are read.
# Returns OK if a line was read, EOF upon reaching the
# end of the file, and ERR if something went awry.

integer function getlin(funit, buf, length)
   integer funit, length, ios
   character*LINELEN buf

   read (funit,'(A)',iostat=ios) buf

   if (ios < 0) return (EOF)
   else if (ios > 0) return (ERR)
   else return (OK)              # Line was read successfully
end


# Output line on funit.
# Trailing blanks are not written.
# (Hopefully it works with all Fortrans...)
# If you want trailing blanks (VM/CMS) just
# comment out the FOR loop.

subroutine putlin(funit, line, length)
   integer funit, length
   character line*LINELEN
   integer l

   # Determine the true length of the line
   # i.e., "remove" blanks at the end of it

   for (l = length; l > 1; l = l - 1)
      if (line(l:l) != ' ')
         break

   write (funit,'(A)') line(:l)
end
