These are a bunch of small shell programs I wrote in the last year.
I wrote them because  a) I needed them and  b) similar commands (from
AmiNet or elsewhere) were poorly written, had huge executables and/or
came without source.

Requirements:
    Except for the NOP command, AmigaOS 2.04 (V37.175) or higher is
    required. The MATCH command requires pattern.library V5.0 (available
    at ftp.informatik.uni-oldenburg.de, /pub/amiga/archive/dev/pattern.lha
    All executables are "pure" and can be made resident.

Author:
    Ingo Wilken
    Bloherfelder Str. 72
    26129 Oldenburg
    Germany

Legal stuff:
    All programs are Copyright (C) by Ingo Wilken.
    Permission to use, copy, modify, and distribute this software and
    its documentation for any purpose and without fee is hereby granted,
    provided that the above copyright notice appear in all copies and that
    both that copyright notice and this permission notice appear in supporting
    documentation.  This software is provided "as is" without express or
    implied warranty.


Regards,
Ingo
--
Ingo Wilken, CS Student, Univ.of Oldenburg, FRG | I'll admit dat I'm not one
http://www.informatik.uni-oldenburg.de/~ingo/   | of da beautiful people, but
E-mail: Ingo.Wilken@informatik.uni-oldenburg.de | I'm not as ugly as da spooks
IRC: Nobody or TeaMan      Fido: 2/2426/2020.15 | dat hang 'round here.  -Snarf

--------------------------------------------------------------------------

EXEC
    Template:
        STACK/K/N,PRI=PRIORITY/K/N,IGNORE/K/N,SYSSHELL/S,CMD=COM=COMMAND/A/F

    Function:
        Executes a command synchronously.  This is useful if you want to
        run a command with a specific stack size or priority, but do not
        want change them in the shell or write a script for it.
        It is also useful for programs that execute commands in a way that
        does not support all features of a shell.  For example, I use a
        "make" clone where the I/O redirection does not work, and internal
        commands of the shell cannot be used.  Wrapping the commands in an
        EXEC fixes the problem.

    Options:
        IGNORE <rc>     Ignore any returncode from the command upto <rc>.
        PRIORITY <pri>  Run the command with priority <pri> instead of the
                        current priority.
        STACK <size>    Run the command with a stack of <size>.  It defaults
                        to 4000 bytes if this option is not used.
        SYSSHELL        Run the command in the system (boot) shell instead
                        of the usershell.


GETPUBSCREEN
    Template:
        DEFAULT/S

    Function:
        Prints the name of the frontmost screen if it is a public screen,
        else prints the name of the default public screen.

    Options:
        DEFAULT         Print the name of the default public screen.

    Example:
        Alias to run the XDME editor on the frontmost screen (if it is a
        public screen).  Note that the substitution marks must be escaped
        to prevent an immediate execution of the GETPUBSCREEN command.
            alias e     run xdme pubscreen *`getpubscreen*` []


GETVOLUME
    Template:
        DEVICE,NOREQ/S

    Function:
        Prints the volume name of current directory, or of any device
        or file.

    Options
        NOREQ           Do not display a "Please insert volume..."
                        requester if the device or volume is not mounted.

    Example:
        getvolume           -> print current volume
        getvolume pc0:      -> print name of volume in device pc0:
        getvolume foo/bar   -> print name of volume the file is on


LINES
    Template:
        FIRST/A/N,LAST/A/N,FROM,TO

    Function:
        Extracts lines from from a text file.  Positive line number are
        counted from the beginning of the file (first line is 1), negative
        numbers from the end (last is -1).  The file arguments (FROM, TO) can
        be omitted, in this case LINES reads from it's input stream and
        writes to it's output stream.

        If lines numbers are counted from the end of the file, then the
        utility must store some lines in a FIFO:
            lines 10 20     => no FIFO, read & write one line at a time
            lines 10 -200   => no FIFO until line 10, then uses a FIFO of
                               199 lines [-(LAST+1) lines]
            lines -500 -100 => FIFO size of 500 lines [-FIRST lines]
        There is no limit to the length of a line, except that it must fit
        into available RAM, and it's length into a LONG :-).

    Example:
        lines 10 20 infile.txt outfile.txt
            Copies line 10 to line 20 from infile.txt to outfile.txt.
        lines 1 10 infile.txt outfile.txt
            Copies the first 10 lines.
        lines -10 -1 infile.txt outfile.txt
            Copies the last 10 lines.
        lines 2 -2 infile.txt outfile.txt
            Copies everything except the first and the last line.
        lines 10 -1 infile.txt outfile.txt
            Copies from line 10 to the end of file (everything except
            the first nine lines).
        lines -3 -2 infile.txt outfile.txt
            Copies the two lines before the last line (lines 2 and 3,
            counted from the end)
        lines 10 -7 infile.txt outfile.txt
            Copies everything except the first nine and the last six lines.


MATCH
    Template:
        STRING/A,PAT=PATTERN/A,NOCASE/S

    Function:
        Tries to match a string to a pattern, sets a WARN returncode if
        they do not match.

    Options:
        NOCASE          Perform a case-insensitve match.

    Examples:
        match Amiga A#?a            -> OK (0)
        match Foo Bar               -> WARN (5)
        match Amiga amiga           -> WARN (5)
        match Amiga amiga nocase    -> OK (0)


NOP
    Template:
        DUMMY/M

    Function:
        Does nothing, always returns OK.  All arguments are ignored.


SETRC
    Template:
        OK/S,WARN/S,ERROR/S,FAIL/S,RC=RESULT/N,RC2=RESULT2/N

    Function:
        Does nothing but to set a returncode.  If none of the
        OK/WARN/ERROR/FAIL/RESULT options is used, it checks
        it's program name:
            "ok", "warn", "error" or "fail":  same as the option
            "true":     returncode 1
            "false":    returncode 0
                These allow constructs like
                    IF `true` ...
                in scripts.
            anything else: returncode 0

    Options:
        OK              Set an OK (0) returncode.
        WARN            Set a WARN (5) returncode.  Overrides OK.
        ERROR           Set an ERROR (10) returncode.  Overrides WARN.
        FAIL            Set a FAIL (20) returncode.  Overrides ERROR.
        RESULT <num>    Set a returncode of <num>.  Overrides FAIL.
        RESULT2 <num>   Set the secondary result to <num>.  This is the
                        error code used by the WHY command.  Note that
                        WHY ignores this if the returncode is 0.


TEE
    Template:
        FILE,APPEND/S,BUF=BUFFER/K/N

    Function:
        This is a clone of the Unix 'tee' command.  It copies it's input
        stream to it's output stream, and to a file or the shell window.

    Options:
        APPEND          Append data to the file, instead of overwriting it.
        BUFFER <n>      Use <n> 512byte buffers instead of the default 100.
                        This option is ignored if tee-ing to an interactive
                        stream (i.e. a console window), in this case only
                        one block is buffered.

